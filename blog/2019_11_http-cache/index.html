<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=main.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <script src=//unpkg.com/valine/dist/Valine.min.js></script> <script src=https://unpkg.com/ajax-hook@2.0.3/dist/ajaxhook.min.js></script> <link href=client/main.1029972362.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>Http缓存-GzhiYi's Blog</title><meta content=Http缓存 name=description><meta content=http,缓存 name=keywords><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-1wr5yce><ul class=svelte-1wr5yce> <li class=svelte-1wr5yce><a aria-current=blog class=svelte-1wr5yce href=/ rel=prefetch>blog</a></ul></nav> <main class=svelte-iwmse4> <div class="svelte-mzxg2z content"><h1>Http缓存</h1> <p class="svelte-mzxg2z desc">11/28/2019 <span class="svelte-mzxg2z label">学习</span></p> <h2 id=缓存相关头>缓存相关头</h2> <h3 id=响应头>响应头</h3> <ul> <li>Expire。资源过期时间。</li> <li>Cache-Control。缓存控制字段，精确控制缓存策略。</li> <li>Last-Modified。资源最近修改时间。</li> <li>Etag。资源标识。</li> </ul> <h3 id=请求头>请求头</h3> <ul> <li>Cache-Control。缓存控制字段，精确控制缓存策略。</li> <li>If-Modified-Since。资源最新修改时间。</li> <li>If-None-Match。缓存资源标识。</li> </ul> <h3 id=字段匹配>字段匹配</h3> <p>If-Modified-Since和Last-Modified Etag和If-None-Match</p> <h2 id=浏览器和服务器约定资源过期时间>浏览器和服务器约定资源过期时间</h2> <p>服务器和浏览器之间约定文件的过期时间，控制的字段为：Expires。在这个时间未到之前，浏览器对同一个文件不会向服务器发起请求。</p> <p><strong>缺点：</strong>Expire到期后，如果文件未进行过改动，浏览器还是会向服务器请求读取文件。</p> <h2 id=服务器告诉浏览器资源上次的修改时间（解决上面的问题）>服务器告诉浏览器资源上次的修改时间（解决上面的问题）</h2> <p>服务器返回文件的时候，在响应头上增加一个最近修改时间（Last-Modified）。浏览器在Expires时间到之后，会向服务器发起文件请求，这时带上一个最近修改时间（If-Modified-Since = Last-Modified）。服务器在接受到请求之后，会拿这个时间和服务器上目标文件的上一次修改时间做对比：</p> <ul> <li>相等。进行304跳转，不要读取服务器文件了，读取缓存就行了。</li> <li>不相等。读取服务器上的文件。</li> </ul> <p><strong>缺点：</strong></p> <ol> <li>Expires过期时间浏览器断可以修改，这样会导致缓存不准确。</li> <li>Last-Modified过期时间只能精确到秒。（一秒内可能多次改动，这样会造成两个可能的问题：文件一秒内改动多次，但还是通知浏览器读缓存。如果文件修改了，但内容不变，那就会去读服务器文件了。）</li> </ol> <h2 id=增加相对时间控制，引入cache-control>增加相对时间控制，引入Cache-Control</h2> <p>服务器在返回资源给浏览器的时候，会增加一个相对时间：Cache-Control：max-age=1000s。这个的意思是告诉浏览器，1000s内使用浏览器缓存的文件。</p> <p><strong>优先级：</strong> Cache-Control优先于Expires。有Cache-Control就以Cache-Control为准。</p> <h2 id=继续升级缓存机制>继续升级缓存机制</h2> <p>带上Etag-可以理解为文件的唯一Id，由服务器返回到浏览器上。 在有效期过后，带上一个等同于Etag值的If-None-Match请求头，比较后处理是否读取文件。</p> <h2 id=最后是我前端的一个技巧啦>最后是我前端的一个技巧啦</h2> <p>由于上面那么多的缓存判断条件，都不能满足一个情况，既浏览器永远无法主动知道服务器的文件已经更新。那好：静态资源在请求链接上更新就行了。</p> <pre><code class=language-javascript>&lt;script src=<span class=hljs-string>"http://test.com/a.【hash值】.js"</span>>&lt;/script></code></pre> </div> <div class=my-8 id=vcomments></div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,(function(a){return {post:{title:"2019\u002F11\u002Fhttp-cache.md",path:"2019\u002F11\u002Fhttp-cache",slug:"2019_11_http-cache",html:"\u003Ch2 id=\"缓存相关头\"\u003E缓存相关头\u003C\u002Fh2\u003E\n\u003Ch3 id=\"响应头\"\u003E响应头\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003EExpire。资源过期时间。\u003C\u002Fli\u003E\n\u003Cli\u003ECache-Control。缓存控制字段，精确控制缓存策略。\u003C\u002Fli\u003E\n\u003Cli\u003ELast-Modified。资源最近修改时间。\u003C\u002Fli\u003E\n\u003Cli\u003EEtag。资源标识。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"请求头\"\u003E请求头\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003ECache-Control。缓存控制字段，精确控制缓存策略。\u003C\u002Fli\u003E\n\u003Cli\u003EIf-Modified-Since。资源最新修改时间。\u003C\u002Fli\u003E\n\u003Cli\u003EIf-None-Match。缓存资源标识。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"字段匹配\"\u003E字段匹配\u003C\u002Fh3\u003E\n\u003Cp\u003EIf-Modified-Since和Last-Modified\nEtag和If-None-Match\u003C\u002Fp\u003E\n\u003Ch2 id=\"浏览器和服务器约定资源过期时间\"\u003E浏览器和服务器约定资源过期时间\u003C\u002Fh2\u003E\n\u003Cp\u003E服务器和浏览器之间约定文件的过期时间，控制的字段为：Expires。在这个时间未到之前，浏览器对同一个文件不会向服务器发起请求。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E缺点：\u003C\u002Fstrong\u003EExpire到期后，如果文件未进行过改动，浏览器还是会向服务器请求读取文件。\u003C\u002Fp\u003E\n\u003Ch2 id=\"服务器告诉浏览器资源上次的修改时间（解决上面的问题）\"\u003E服务器告诉浏览器资源上次的修改时间（解决上面的问题）\u003C\u002Fh2\u003E\n\u003Cp\u003E服务器返回文件的时候，在响应头上增加一个最近修改时间（Last-Modified）。浏览器在Expires时间到之后，会向服务器发起文件请求，这时带上一个最近修改时间（If-Modified-Since = Last-Modified）。服务器在接受到请求之后，会拿这个时间和服务器上目标文件的上一次修改时间做对比：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E相等。进行304跳转，不要读取服务器文件了，读取缓存就行了。\u003C\u002Fli\u003E\n\u003Cli\u003E不相等。读取服务器上的文件。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E缺点：\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003EExpires过期时间浏览器断可以修改，这样会导致缓存不准确。\u003C\u002Fli\u003E\n\u003Cli\u003ELast-Modified过期时间只能精确到秒。（一秒内可能多次改动，这样会造成两个可能的问题：文件一秒内改动多次，但还是通知浏览器读缓存。如果文件修改了，但内容不变，那就会去读服务器文件了。）\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"增加相对时间控制，引入cache-control\"\u003E增加相对时间控制，引入Cache-Control\u003C\u002Fh2\u003E\n\u003Cp\u003E服务器在返回资源给浏览器的时候，会增加一个相对时间：Cache-Control：max-age=1000s。这个的意思是告诉浏览器，1000s内使用浏览器缓存的文件。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E优先级：\u003C\u002Fstrong\u003E \nCache-Control优先于Expires。有Cache-Control就以Cache-Control为准。\u003C\u002Fp\u003E\n\u003Ch2 id=\"继续升级缓存机制\"\u003E继续升级缓存机制\u003C\u002Fh2\u003E\n\u003Cp\u003E带上Etag-可以理解为文件的唯一Id，由服务器返回到浏览器上。\n在有效期过后，带上一个等同于Etag值的If-None-Match请求头，比较后处理是否读取文件。\u003C\u002Fp\u003E\n\u003Ch2 id=\"最后是我前端的一个技巧啦\"\u003E最后是我前端的一个技巧啦\u003C\u002Fh2\u003E\n\u003Cp\u003E由于上面那么多的缓存判断条件，都不能满足一个情况，既浏览器永远无法主动知道服务器的文件已经更新。那好：静态资源在请求链接上更新就行了。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E&lt;script src=\u003Cspan class=\"hljs-string\"\u003E\"http:\u002F\u002Ftest.com\u002Fa.【hash值】.js\"\u003C\u002Fspan\u003E&gt;&lt;\u002Fscript&gt;\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n",fmData:{attributes:{title:a,description:a,keywords:"http,缓存",labels:["学习"],date:"2019-11-28T00:00:00.000Z"},body:"## 缓存相关头\n\n### 响应头\n\n- Expire。资源过期时间。\n- Cache-Control。缓存控制字段，精确控制缓存策略。\n- Last-Modified。资源最近修改时间。\n- Etag。资源标识。\n\n### 请求头\n\n- Cache-Control。缓存控制字段，精确控制缓存策略。\n- If-Modified-Since。资源最新修改时间。\n- If-None-Match。缓存资源标识。\n\n### 字段匹配\n\nIf-Modified-Since和Last-Modified\nEtag和If-None-Match\n\n## 浏览器和服务器约定资源过期时间\n\n服务器和浏览器之间约定文件的过期时间，控制的字段为：Expires。在这个时间未到之前，浏览器对同一个文件不会向服务器发起请求。\n\n**缺点：**Expire到期后，如果文件未进行过改动，浏览器还是会向服务器请求读取文件。\n\n## 服务器告诉浏览器资源上次的修改时间（解决上面的问题）\n\n服务器返回文件的时候，在响应头上增加一个最近修改时间（Last-Modified）。浏览器在Expires时间到之后，会向服务器发起文件请求，这时带上一个最近修改时间（If-Modified-Since = Last-Modified）。服务器在接受到请求之后，会拿这个时间和服务器上目标文件的上一次修改时间做对比：\n- 相等。进行304跳转，不要读取服务器文件了，读取缓存就行了。\n- 不相等。读取服务器上的文件。\n**缺点：**\n1. Expires过期时间浏览器断可以修改，这样会导致缓存不准确。\n2. Last-Modified过期时间只能精确到秒。（一秒内可能多次改动，这样会造成两个可能的问题：文件一秒内改动多次，但还是通知浏览器读缓存。如果文件修改了，但内容不变，那就会去读服务器文件了。）\n\n## 增加相对时间控制，引入Cache-Control\n\n服务器在返回资源给浏览器的时候，会增加一个相对时间：Cache-Control：max-age=1000s。这个的意思是告诉浏览器，1000s内使用浏览器缓存的文件。\n\n**优先级：** \nCache-Control优先于Expires。有Cache-Control就以Cache-Control为准。\n\n## 继续升级缓存机制\n\n带上Etag-可以理解为文件的唯一Id，由服务器返回到浏览器上。\n在有效期过后，带上一个等同于Etag值的If-None-Match请求头，比较后处理是否读取文件。\n\n## 最后是我前端的一个技巧啦\n\n由于上面那么多的缓存判断条件，都不能满足一个情况，既浏览器永远无法主动知道服务器的文件已经更新。那好：静态资源在请求链接上更新就行了。\n\n```javascript\n\u003Cscript src=\"http:\u002F\u002Ftest.com\u002Fa.【hash值】.js\"\u003E\u003C\u002Fscript\u003E\n```",bodyBegin:9,frontmatter:"title: Http缓存\ndescription: Http缓存\nkeywords: http,缓存\nlabels: ['学习']\ndate: 2019-11-28"}}}}("Http缓存"))]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.34d3e2bd.js"}catch(e){main="/client/legacy/client.9a4bf57e.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1" async></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 