<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <link href=client/client-8d9aba14.css rel=stylesheet><link href=client/[slug]-636f444e.css rel=stylesheet> <title>Http缓存-GzhiYi's blog</title><meta content=Http缓存 name=description data-svelte=svelte-2vncnt><meta content=http,缓存 name=keywords data-svelte=svelte-2vncnt> <link href=/client/client.796a17e3.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-8d9aba14.css rel=preload as=style><link href=/client/[slug].9001d1d3.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/config.026ad977.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/[slug]-636f444e.css rel=preload as=style></head> <body> <div id=sapper> <nav class=svelte-1dbd5up><ul class=svelte-1dbd5up> <li class=svelte-1dbd5up><a href=blog aria-current=page class=svelte-1dbd5up rel=prefetch>blog</a></ul></nav> <main class=svelte-1y51i2> <div class="svelte-1cnt1lz base"><div class=label>学习</div> <div class="svelte-1cnt1lz title">Http缓存</div> <span class="svelte-1cnt1lz author">GzhiYi · 2019-11-28</span></div> <div class="svelte-1cnt1lz content"><h2 id=缓存相关头>缓存相关头</h2> <h3 id=响应头>响应头</h3> <ul> <li>Expire。资源过期时间。</li> <li>Cache-Control。缓存控制字段，精确控制缓存策略。</li> <li>Last-Modified。资源最近修改时间。</li> <li>Etag。资源标识。</li> </ul> <h3 id=请求头>请求头</h3> <ul> <li>Cache-Control。缓存控制字段，精确控制缓存策略。</li> <li>If-Modified-Since。资源最新修改时间。</li> <li>If-None-Match。缓存资源标识。</li> </ul> <h3 id=字段匹配>字段匹配</h3> <p>If-Modified-Since和Last-Modified Etag和If-None-Match</p> <h2 id=浏览器和服务器约定资源过期时间>浏览器和服务器约定资源过期时间</h2> <p>服务器和浏览器之间约定文件的过期时间，控制的字段为：Expires。在这个时间未到之前，浏览器对同一个文件不会向服务器发起请求。</p> <p><strong>缺点：</strong>Expire到期后，如果文件未进行过改动，浏览器还是会向服务器请求读取文件。</p> <h2 id=服务器告诉浏览器资源上次的修改时间（解决上面的问题）>服务器告诉浏览器资源上次的修改时间（解决上面的问题）</h2> <p>服务器返回文件的时候，在响应头上增加一个最近修改时间（Last-Modified）。浏览器在Expires时间到之后，会向服务器发起文件请求，这时带上一个最近修改时间（If-Modified-Since = Last-Modified）。服务器在接受到请求之后，会拿这个时间和服务器上目标文件的上一次修改时间做对比：</p> <ul> <li>相等。进行304跳转，不要读取服务器文件了，读取缓存就行了。</li> <li>不相等。读取服务器上的文件。</li> </ul> <p><strong>缺点：</strong></p> <ol> <li>Expires过期时间浏览器断可以修改，这样会导致缓存不准确。</li> <li>Last-Modified过期时间只能精确到秒。（一秒内可能多次改动，这样会造成两个可能的问题：文件一秒内改动多次，但还是通知浏览器读缓存。如果文件修改了，但内容不变，那就会去读服务器文件了。）</li> </ol> <h2 id=增加相对时间控制，引入cache-control>增加相对时间控制，引入Cache-Control</h2> <p>服务器在返回资源给浏览器的时候，会增加一个相对时间：Cache-Control：max-age=1000s。这个的意思是告诉浏览器，1000s内使用浏览器缓存的文件。</p> <p><strong>优先级：</strong> Cache-Control优先于Expires。有Cache-Control就以Cache-Control为准。</p> <h2 id=继续升级缓存机制>继续升级缓存机制</h2> <p>带上Etag-可以理解为文件的唯一Id，由服务器返回到浏览器上。 在有效期过后，带上一个等同于Etag值的If-None-Match请求头，比较后处理是否读取文件。</p> <h2 id=最后是我前端的一个技巧啦>最后是我前端的一个技巧啦</h2> <p>由于上面那么多的缓存判断条件，都不能满足一个情况，既浏览器永远无法主动知道服务器的文件已经更新。那好：静态资源在请求链接上更新就行了。</p> <pre><code class=language-javascript><span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>src</span>=<span class=hljs-string>"http://test.com/a.【hash值】.js"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>
</code></pre> </div> <div class="svelte-1cnt1lz contact"><div>如果你对这页内容有疑问，欢迎联系我！</div> <a href="mailto:zhiyi.gong@outlook.com?subject=【重要】Http缓存&body=gzhiyi.top/blog/2019_11_http-cache" target=_blank>邮箱 </a> <br> <a href=https://github.com/gzhiyi target=_blank>github </a> </div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,(function(a){return {post:{title:a,description:a,keywords:"http,缓存",labels:["学习"],date:"2019-11-28",path:"2019\u002F11\u002Fhttp-cache.md",slug:"2019_11_http-cache",html:"\u003Ch2 id=\"缓存相关头\"\u003E缓存相关头\u003C\u002Fh2\u003E\n\u003Ch3 id=\"响应头\"\u003E响应头\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003EExpire。资源过期时间。\u003C\u002Fli\u003E\n\u003Cli\u003ECache-Control。缓存控制字段，精确控制缓存策略。\u003C\u002Fli\u003E\n\u003Cli\u003ELast-Modified。资源最近修改时间。\u003C\u002Fli\u003E\n\u003Cli\u003EEtag。资源标识。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"请求头\"\u003E请求头\u003C\u002Fh3\u003E\n\u003Cul\u003E\n\u003Cli\u003ECache-Control。缓存控制字段，精确控制缓存策略。\u003C\u002Fli\u003E\n\u003Cli\u003EIf-Modified-Since。资源最新修改时间。\u003C\u002Fli\u003E\n\u003Cli\u003EIf-None-Match。缓存资源标识。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"字段匹配\"\u003E字段匹配\u003C\u002Fh3\u003E\n\u003Cp\u003EIf-Modified-Since和Last-Modified\nEtag和If-None-Match\u003C\u002Fp\u003E\n\u003Ch2 id=\"浏览器和服务器约定资源过期时间\"\u003E浏览器和服务器约定资源过期时间\u003C\u002Fh2\u003E\n\u003Cp\u003E服务器和浏览器之间约定文件的过期时间，控制的字段为：Expires。在这个时间未到之前，浏览器对同一个文件不会向服务器发起请求。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E缺点：\u003C\u002Fstrong\u003EExpire到期后，如果文件未进行过改动，浏览器还是会向服务器请求读取文件。\u003C\u002Fp\u003E\n\u003Ch2 id=\"服务器告诉浏览器资源上次的修改时间（解决上面的问题）\"\u003E服务器告诉浏览器资源上次的修改时间（解决上面的问题）\u003C\u002Fh2\u003E\n\u003Cp\u003E服务器返回文件的时候，在响应头上增加一个最近修改时间（Last-Modified）。浏览器在Expires时间到之后，会向服务器发起文件请求，这时带上一个最近修改时间（If-Modified-Since = Last-Modified）。服务器在接受到请求之后，会拿这个时间和服务器上目标文件的上一次修改时间做对比：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E相等。进行304跳转，不要读取服务器文件了，读取缓存就行了。\u003C\u002Fli\u003E\n\u003Cli\u003E不相等。读取服务器上的文件。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E\u003Cstrong\u003E缺点：\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003EExpires过期时间浏览器断可以修改，这样会导致缓存不准确。\u003C\u002Fli\u003E\n\u003Cli\u003ELast-Modified过期时间只能精确到秒。（一秒内可能多次改动，这样会造成两个可能的问题：文件一秒内改动多次，但还是通知浏览器读缓存。如果文件修改了，但内容不变，那就会去读服务器文件了。）\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"增加相对时间控制，引入cache-control\"\u003E增加相对时间控制，引入Cache-Control\u003C\u002Fh2\u003E\n\u003Cp\u003E服务器在返回资源给浏览器的时候，会增加一个相对时间：Cache-Control：max-age=1000s。这个的意思是告诉浏览器，1000s内使用浏览器缓存的文件。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E优先级：\u003C\u002Fstrong\u003E \nCache-Control优先于Expires。有Cache-Control就以Cache-Control为准。\u003C\u002Fp\u003E\n\u003Ch2 id=\"继续升级缓存机制\"\u003E继续升级缓存机制\u003C\u002Fh2\u003E\n\u003Cp\u003E带上Etag-可以理解为文件的唯一Id，由服务器返回到浏览器上。\n在有效期过后，带上一个等同于Etag值的If-None-Match请求头，比较后处理是否读取文件。\u003C\u002Fp\u003E\n\u003Ch2 id=\"最后是我前端的一个技巧啦\"\u003E最后是我前端的一个技巧啦\u003C\u002Fh2\u003E\n\u003Cp\u003E由于上面那么多的缓存判断条件，都不能满足一个情况，既浏览器永远无法主动知道服务器的文件已经更新。那好：静态资源在请求链接上更新就行了。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Esrc\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;http:\u002F\u002Ftest.com\u002Fa.【hash值】.js&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n"}}}("Http缓存"))]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.796a17e3.js"}catch(e){main="/client/legacy/client.c6fed283.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 