<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=main.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <script src=//unpkg.com/valine/dist/Valine.min.js></script> <script src=https://unpkg.com/ajax-hook@2.0.3/dist/ajaxhook.min.js></script> <link href=client/main.1029972362.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>小程序egg后台简要文档-GzhiYi's Blog</title><meta content=如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。 name=description><meta content=mp,小程序,eggjs,微信开发后台 name=keywords><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-1wr5yce><ul class=svelte-1wr5yce> <li class=svelte-1wr5yce><a href=/ aria-current=blog class=svelte-1wr5yce rel=prefetch>blog</a></ul></nav> <main class=svelte-iwmse4> <div class="svelte-mzxg2z content"><h1>小程序egg后台简要文档</h1> <p class="svelte-mzxg2z desc">6/6/2019 <span class="svelte-mzxg2z label">小程序</span></p> <p>如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。</p> <p>如果未接触过node编写接口，首先还是需要基本过一下<a href=https://eggjs.org/zh-cn/intro/ target=_blank>egg官方文档</a>，至少得把快速入门看完。</p> <p>不会从头开始把每一步都详细写下来，只针对微信对接的一些处理列出来。</p> <h2 id=数据库>数据库</h2> <p>使用mongo，示例通过<a href=https://github.com/eggjs/egg-mongoose target=_blank>egg-mongoose</a>进行连接处理。</p> <p>安装插件后，在<code>/config/plugin.js</code>进行基本配置：</p> <pre><code class=language-javascript>mongoose: {
  <span class=hljs-attr>enable</span>: <span class=hljs-literal>true</span>,
  <span class=hljs-attr>package</span>: <span class=hljs-string>'egg-mongoose'</span>
}</code></pre> <p>在<code>/config/config.default.js</code>文件中配置mongodb的连接（保证本地测试环境数据库连接好）：</p> <pre><code class=language-javascript><span class=hljs-comment>// connect mongo</span>
  config.mongoose = {
    <span class=hljs-attr>client</span>: {
      <span class=hljs-attr>url</span>: <span class=hljs-string>'mongodb://127.0.0.1/fulishe'</span>,
      <span class=hljs-attr>options</span>: {},
    }
  }</code></pre> <p>在<code>/app/models</code>文件夹编写相关的model，在程序运行时会自动在mongo上创建对应的表。也可以优先创建好数据库和表设计等。</p> <h2 id=编写接口>编写接口</h2> <p>在<code>controller</code>写主要的业务逻辑，接受接口请求参数并返回。 对于入参，需要进行验证的可以做验证处理，需要处理返回结果，即使请求出错也不要返回非200的状态码。 可以将处理结果设置为一个函数，如：</p> <pre><code class=language-javascript><span class=hljs-comment>// data: 返回给前端的数据，code: 状态，1为成功，0为失败，message：状态信息</span>
<span class=hljs-attr>formatResponse</span>: <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>data, code, message</span>) </span>{
  <span class=hljs-keyword>return</span> {
    code,
    data,
    message
  }
}</code></pre> <p>!> 为避免出现出现问题而导致程序中断，最好在每一个容易出现问题的地方进行<code>try catch</code>将异常抛出并返回到前端。</p> <p>在<code>service</code>编写数据库操作函数等，通过在<code>controller</code>进行调用，统一管理数据库数据进出。 注意在数据新增的时候需要进行<code>save</code>操作：</p> <pre><code class=language-javascript><span class=hljs-keyword>const</span> addUser = <span class=hljs-keyword>await</span> <span class=hljs-keyword>this</span>.ctx.model.Users(data)
addUser.save() <span class=hljs-comment>// 不要遗漏</span></code></pre> <p>相关的增删改查操作，需要直接点的可以看仓库<code>app/service</code>下的写法。</p> <h2 id=小程序接口相关>小程序接口相关</h2> <p>以下是eggjs对小程序包括获取openId、获取unionId、获取手机号码、判断用户是否关注公众号、客服信息发送进行编写说明。<br>如果某个对象不知道是什么，一般都是可以根据名字找到对于的js文件或者通过npm引入，不再表述引入什么了。</p> <h3 id=获取openid>获取openId</h3> <p>参数说明：</p> <ul> <li>APPID： 小程序的appId</li> <li>SECRET： 小程序的secret，跟appId在同一个地方能找到</li> <li>CODE：小程序在前端通过wx.login()获取的jscode</li> </ul> <pre><code class=language-javascript><span class=hljs-keyword>const</span> openIdRes = <span class=hljs-keyword>await</span> rp(<span class=hljs-string>`https://api.weixin.qq.com/sns/jscode2session?appid=<span class=hljs-subst>${APPID}</span>&secret=<span class=hljs-subst>${SECRET}</span>&js_code=<span class=hljs-subst>${CODE}</span>&grant_type=authorization_code`</span>)
<span class=hljs-keyword>const</span> openId = <span class=hljs-built_in>JSON</span>.parse(openIdRes).openId <span class=hljs-comment>// 在处理错误判断后，返回的数据是json字符串，需要转化</span></code></pre> <h3 id=获取unionid>获取unionId</h3> <p>unionId，属于微信端通用的账号唯一标识，举个例子就是同一个微信号，唯一对应一个unionId。而在每一个小程序上，用户openId都不一样。可以用于判断在小程序上的用户是否关注公众号等。</p> <p>在第一个获取<code>openId</code>的时候，会返回<code>openId</code>以及<code>session_key</code>，通过小程序前端传过来的<code>encryptedData</code>以及<code>iv</code>就可以拿到<code>unionId</code>。</p> <p>参数说明：</p> <ul> <li>APPID： 小程序的appId</li> <li>sessionKey：获取openId的时候，一并返回了sessionKey</li> <li>encryptedData：小程序在前端通过获取用户信息返回</li> <li>iv：小程序在前端通过获取用户信息返回</li> </ul> <pre><code class=language-javascript><span class=hljs-keyword>const</span> pc = <span class=hljs-keyword>new</span> WXBizDataCrypt(APPID, sessionKey)
<span class=hljs-keyword>const</span> data = pc.decryptData(encryptedData, iv)
<span class=hljs-keyword>const</span> unionId = data.unionId</code></pre> <h3 id=获取手机号码>获取手机号码</h3> <p>获取手机号码的步骤跟获取unionId一样。</p> <p>只需要注意的是，<code>encryptedData</code>、<code>iv</code>是在小程序端通过<code>getPhoneNumber</code>获取。</p> <h3 id=判断用户是否关注公众号>判断用户是否关注公众号</h3> <p>这里单独在小程序后台无法判断。需要在对于的公众号后台提供一个接口用于判断该unionId是否已经关注了公众号。</p> <h3 id=客服信息发送>客服信息发送</h3> <p>在小程序开发设置中配置消息推送。</p> <p>配置参考： </p> <table> <thead> <tr> <th>参数</th> <th>值</th> <th>备注</th> </tr> </thead> <tr> <td>URL(服务器地址)</td> <td>https://<em>.</em>.com/message/check</td> <td>微信那边与你服务器通信的接口</td> </tr> <tr> <td>Token(令牌)</td> <td>isToken</td> <td>自定义</td> </tr> <tr> <td>EncodingAESKey(消息加密密钥)</td> <td><strong>**</strong></td> <td>填写那可以自动生成</td> </tr> <tr> <td>消息加密方式</td> <td>兼容模式</td> <td>涉及信息安全</td> </tr> <tr> <td>数据格式</td> <td>JSON</td> <td>一般是这个吧</td> </tr> </table> <p>在<code>controller</code>层编写一个<code>get</code>接口，对应<code>/message/check</code>，用以给微信进行服务器验证。 完整验证函数接口可如下：</p> <pre><code class=language-javascript><span class=hljs-keyword>async</span> index() {
  <span class=hljs-keyword>const</span> { ctx } = <span class=hljs-keyword>this</span>
  <span class=hljs-comment>// 1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr</span>
  <span class=hljs-keyword>const</span> {
    signature,
    timestamp,
    nonce,
    echostr
  } = ctx.query

  <span class=hljs-comment>// 2.将token、timestamp、nonce三个参数进行字典序排序</span>
  <span class=hljs-keyword>let</span> array = [<span class=hljs-string>'线上配置的令牌'</span>, timestamp, nonce]
  array.sort() <span class=hljs-comment>// JavaScript sort函数就是字典序排序的</span>

  <span class=hljs-comment>// 3.将三个参数字符串拼接成一个字符串进行sha1加密</span>
  <span class=hljs-keyword>const</span> tempStr = array.join(<span class=hljs-string>''</span>)
  <span class=hljs-keyword>const</span> hashCode = crypto.createHash(<span class=hljs-string>'sha1'</span>) <span class=hljs-comment>//创建加密类型</span>
  <span class=hljs-keyword>const</span> resultCode = hashCode.update(tempStr, <span class=hljs-string>'utf8'</span>).digest(<span class=hljs-string>'hex'</span>)

  <span class=hljs-comment>// 4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</span>
  <span class=hljs-keyword>if</span> (resultCode === signature) {
    ctx.body = echostr
  } <span class=hljs-keyword>else</span> {
    <span class=hljs-comment>// 非微信服务器请求</span>
    ctx.body = format.formatResponse({
      resultCode,
      <span class=hljs-attr>req</span>: ctx.query
    }, <span class=hljs-number>0</span>, <span class=hljs-string>'验证失败1'</span>)
  }
}</code></pre> <p>自动回复操作： 在<code>controller</code>层编写一个<code>post</code>接口，对应<code>/message/check</code>，用于自动回复。 完整处理自动回复接口：</p> <pre><code class=language-javascript><span class=hljs-keyword>async</span> handle() {
  <span class=hljs-keyword>const</span> { ctx } = <span class=hljs-keyword>this</span>
  <span class=hljs-keyword>const</span> { FromUserName, MsgType, Content } = ctx.request.body <span class=hljs-comment>// 这是从微信转发过来的用户发送的信息参数</span>
  <span class=hljs-keyword>const</span> { openid } = ctx.query
  <span class=hljs-comment>// 获取accessToken</span>
  <span class=hljs-keyword>const</span> tokenRes = <span class=hljs-keyword>await</span> rp(<span class=hljs-string>`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=<span class=hljs-subst>${CONST.appId}</span>&secret=<span class=hljs-subst>${CONST.secret}</span>`</span>)
  <span class=hljs-keyword>if</span> (!(<span class=hljs-string>'errcode'</span> <span class=hljs-keyword>in</span> <span class=hljs-built_in>JSON</span>.parse(tokenRes))) {
    <span class=hljs-keyword>if</span> (MsgType === <span class=hljs-string>'text'</span>) {
      <span class=hljs-keyword>const</span> postData = {
        <span class=hljs-attr>touser</span>: openid,
        <span class=hljs-attr>msgtype</span>: <span class=hljs-string>"link"</span>,
        <span class=hljs-attr>link</span>: {
          <span class=hljs-attr>title</span>: <span class=hljs-string>'链接标题'</span>,
          <span class=hljs-attr>description</span>: <span class=hljs-string>'链接描述'</span>,
          <span class=hljs-attr>url</span>: <span class=hljs-string>'链接'</span>,
          <span class=hljs-attr>thumb_url</span>: <span class=hljs-string>'链接封面图'</span>
        }
      }
      <span class=hljs-keyword>const</span> sendRes = <span class=hljs-keyword>await</span> rp({
        <span class=hljs-attr>uri</span>: <span class=hljs-string>`https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=<span class=hljs-subst>${<span class=hljs-built_in>JSON</span>.parse(tokenRes).access_token}</span>`</span>,
        <span class=hljs-attr>method</span>: <span class=hljs-string>'post'</span>,
        <span class=hljs-attr>body</span>: postData,
        <span class=hljs-attr>json</span>: <span class=hljs-literal>true</span>
      })
    }
  }
  ctx.body = <span class=hljs-string>'success'</span>
}</code></pre> <p>!> 注意：需要在自动回复的最后返回<code>success</code>，否则会在聊天窗口看到提示：<code>该小程序提供的服务出现故障，请稍后再试</code></p> </div> <div class=my-8 id=vcomments></div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"2019\u002F06\u002Fmp-egg.md",path:"2019\u002F06\u002Fmp-egg",slug:"2019_06_mp-egg",html:"\u003Cp\u003E如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。\u003C\u002Fp\u003E\n\u003Cp\u003E如果未接触过node编写接口，首先还是需要基本过一下\u003Ca target='_blank'  href=\"https:\u002F\u002Feggjs.org\u002Fzh-cn\u002Fintro\u002F\"\u003Eegg官方文档\u003C\u002Fa\u003E，至少得把快速入门看完。\u003C\u002Fp\u003E\n\u003Cp\u003E不会从头开始把每一步都详细写下来，只针对微信对接的一些处理列出来。\u003C\u002Fp\u003E\n\u003Ch2 id=\"数据库\"\u003E数据库\u003C\u002Fh2\u003E\n\u003Cp\u003E使用mongo，示例通过\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Feggjs\u002Fegg-mongoose\"\u003Eegg-mongoose\u003C\u002Fa\u003E进行连接处理。\u003C\u002Fp\u003E\n\u003Cp\u003E安装插件后，在\u003Ccode\u003E\u002Fconfig\u002Fplugin.js\u003C\u002Fcode\u003E进行基本配置：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Emongoose: {\n  \u003Cspan class=\"hljs-attr\"\u003Eenable\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E,\n  \u003Cspan class=\"hljs-attr\"\u003Epackage\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'egg-mongoose'\u003C\u002Fspan\u003E\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在\u003Ccode\u003E\u002Fconfig\u002Fconfig.default.js\u003C\u002Fcode\u003E文件中配置mongodb的连接（保证本地测试环境数据库连接好）：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F connect mongo\u003C\u002Fspan\u003E\n  config.mongoose = {\n    \u003Cspan class=\"hljs-attr\"\u003Eclient\u003C\u002Fspan\u003E: {\n      \u003Cspan class=\"hljs-attr\"\u003Eurl\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'mongodb:\u002F\u002F127.0.0.1\u002Ffulishe'\u003C\u002Fspan\u003E,\n      \u003Cspan class=\"hljs-attr\"\u003Eoptions\u003C\u002Fspan\u003E: {},\n    }\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在\u003Ccode\u003E\u002Fapp\u002Fmodels\u003C\u002Fcode\u003E文件夹编写相关的model，在程序运行时会自动在mongo上创建对应的表。也可以优先创建好数据库和表设计等。\u003C\u002Fp\u003E\n\u003Ch2 id=\"编写接口\"\u003E编写接口\u003C\u002Fh2\u003E\n\u003Cp\u003E在\u003Ccode\u003Econtroller\u003C\u002Fcode\u003E写主要的业务逻辑，接受接口请求参数并返回。\n对于入参，需要进行验证的可以做验证处理，需要处理返回结果，即使请求出错也不要返回非200的状态码。\n可以将处理结果设置为一个函数，如：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F data: 返回给前端的数据，code: 状态，1为成功，0为失败，message：状态信息\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-attr\"\u003EformatResponse\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Edata, code, message\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E {\n    code,\n    data,\n    message\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E!&gt; 为避免出现出现问题而导致程序中断，最好在每一个容易出现问题的地方进行\u003Ccode\u003Etry catch\u003C\u002Fcode\u003E将异常抛出并返回到前端。\u003C\u002Fp\u003E\n\u003Cp\u003E在\u003Ccode\u003Eservice\u003C\u002Fcode\u003E编写数据库操作函数等，通过在\u003Ccode\u003Econtroller\u003C\u002Fcode\u003E进行调用，统一管理数据库数据进出。\n注意在数据新增的时候需要进行\u003Ccode\u003Esave\u003C\u002Fcode\u003E操作：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E addUser = \u003Cspan class=\"hljs-keyword\"\u003Eawait\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.ctx.model.Users(data)\naddUser.save() \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 不要遗漏\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E相关的增删改查操作，需要直接点的可以看仓库\u003Ccode\u003Eapp\u002Fservice\u003C\u002Fcode\u003E下的写法。\u003C\u002Fp\u003E\n\u003Ch2 id=\"小程序接口相关\"\u003E小程序接口相关\u003C\u002Fh2\u003E\n\u003Cp\u003E以下是eggjs对小程序包括获取openId、获取unionId、获取手机号码、判断用户是否关注公众号、客服信息发送进行编写说明。\u003Cbr\u003E如果某个对象不知道是什么，一般都是可以根据名字找到对于的js文件或者通过npm引入，不再表述引入什么了。\u003C\u002Fp\u003E\n\u003Ch3 id=\"获取openid\"\u003E获取openId\u003C\u002Fh3\u003E\n\u003Cp\u003E参数说明：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EAPPID： 小程序的appId\u003C\u002Fli\u003E\n\u003Cli\u003ESECRET： 小程序的secret，跟appId在同一个地方能找到\u003C\u002Fli\u003E\n\u003Cli\u003ECODE：小程序在前端通过wx.login()获取的jscode\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E openIdRes = \u003Cspan class=\"hljs-keyword\"\u003Eawait\u003C\u002Fspan\u003E rp(\u003Cspan class=\"hljs-string\"\u003E`https:\u002F\u002Fapi.weixin.qq.com\u002Fsns\u002Fjscode2session?appid=\u003Cspan class=\"hljs-subst\"\u003E${APPID}\u003C\u002Fspan\u003E&amp;secret=\u003Cspan class=\"hljs-subst\"\u003E${SECRET}\u003C\u002Fspan\u003E&amp;js_code=\u003Cspan class=\"hljs-subst\"\u003E${CODE}\u003C\u002Fspan\u003E&amp;grant_type=authorization_code`\u003C\u002Fspan\u003E)\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E openId = \u003Cspan class=\"hljs-built_in\"\u003EJSON\u003C\u002Fspan\u003E.parse(openIdRes).openId \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 在处理错误判断后，返回的数据是json字符串，需要转化\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"获取unionid\"\u003E获取unionId\u003C\u002Fh3\u003E\n\u003Cp\u003EunionId，属于微信端通用的账号唯一标识，举个例子就是同一个微信号，唯一对应一个unionId。而在每一个小程序上，用户openId都不一样。可以用于判断在小程序上的用户是否关注公众号等。\u003C\u002Fp\u003E\n\u003Cp\u003E在第一个获取\u003Ccode\u003EopenId\u003C\u002Fcode\u003E的时候，会返回\u003Ccode\u003EopenId\u003C\u002Fcode\u003E以及\u003Ccode\u003Esession_key\u003C\u002Fcode\u003E，通过小程序前端传过来的\u003Ccode\u003EencryptedData\u003C\u002Fcode\u003E以及\u003Ccode\u003Eiv\u003C\u002Fcode\u003E就可以拿到\u003Ccode\u003EunionId\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E参数说明：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EAPPID： 小程序的appId\u003C\u002Fli\u003E\n\u003Cli\u003EsessionKey：获取openId的时候，一并返回了sessionKey\u003C\u002Fli\u003E\n\u003Cli\u003EencryptedData：小程序在前端通过获取用户信息返回\u003C\u002Fli\u003E\n\u003Cli\u003Eiv：小程序在前端通过获取用户信息返回\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E pc = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E WXBizDataCrypt(APPID, sessionKey)\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E data = pc.decryptData(encryptedData, iv)\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E unionId = data.unionId\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"获取手机号码\"\u003E获取手机号码\u003C\u002Fh3\u003E\n\u003Cp\u003E获取手机号码的步骤跟获取unionId一样。\u003C\u002Fp\u003E\n\u003Cp\u003E只需要注意的是，\u003Ccode\u003EencryptedData\u003C\u002Fcode\u003E、\u003Ccode\u003Eiv\u003C\u002Fcode\u003E是在小程序端通过\u003Ccode\u003EgetPhoneNumber\u003C\u002Fcode\u003E获取。\u003C\u002Fp\u003E\n\u003Ch3 id=\"判断用户是否关注公众号\"\u003E判断用户是否关注公众号\u003C\u002Fh3\u003E\n\u003Cp\u003E这里单独在小程序后台无法判断。需要在对于的公众号后台提供一个接口用于判断该unionId是否已经关注了公众号。\u003C\u002Fp\u003E\n\u003Ch3 id=\"客服信息发送\"\u003E客服信息发送\u003C\u002Fh3\u003E\n\u003Cp\u003E在小程序开发设置中配置消息推送。\u003C\u002Fp\u003E\n\u003Cp\u003E配置参考： \u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003E参数\u003C\u002Fth\u003E\n\u003Cth\u003E值\u003C\u002Fth\u003E\n\u003Cth\u003E备注\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\n\u003Ctd\u003EURL(服务器地址)\u003C\u002Ftd\u003E\n\u003Ctd\u003Ehttps:\u002F\u002F\u003Cem\u003E.\u003C\u002Fem\u003E.com\u002Fmessage\u002Fcheck\u003C\u002Ftd\u003E\n\u003Ctd\u003E微信那边与你服务器通信的接口\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EToken(令牌)\u003C\u002Ftd\u003E\n\u003Ctd\u003EisToken\u003C\u002Ftd\u003E\n\u003Ctd\u003E自定义\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EEncodingAESKey(消息加密密钥)\u003C\u002Ftd\u003E\n\u003Ctd\u003E\u003Cstrong\u003E**\u003C\u002Fstrong\u003E\u003C\u002Ftd\u003E\n\u003Ctd\u003E填写那可以自动生成\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E消息加密方式\u003C\u002Ftd\u003E\n\u003Ctd\u003E兼容模式\u003C\u002Ftd\u003E\n\u003Ctd\u003E涉及信息安全\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E数据格式\u003C\u002Ftd\u003E\n\u003Ctd\u003EJSON\u003C\u002Ftd\u003E\n\u003Ctd\u003E一般是这个吧\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\n\u003Cp\u003E在\u003Ccode\u003Econtroller\u003C\u002Fcode\u003E层编写一个\u003Ccode\u003Eget\u003C\u002Fcode\u003E接口，对应\u003Ccode\u003E\u002Fmessage\u002Fcheck\u003C\u002Fcode\u003E，用以给微信进行服务器验证。\n完整验证函数接口可如下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Easync\u003C\u002Fspan\u003E index() {\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E { ctx } = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E {\n    signature,\n    timestamp,\n    nonce,\n    echostr\n  } = ctx.query\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 2.将token、timestamp、nonce三个参数进行字典序排序\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E array = [\u003Cspan class=\"hljs-string\"\u003E'线上配置的令牌'\u003C\u002Fspan\u003E, timestamp, nonce]\n  array.sort() \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F JavaScript sort函数就是字典序排序的\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 3.将三个参数字符串拼接成一个字符串进行sha1加密\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E tempStr = array.join(\u003Cspan class=\"hljs-string\"\u003E''\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E hashCode = crypto.createHash(\u003Cspan class=\"hljs-string\"\u003E'sha1'\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F创建加密类型\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E resultCode = hashCode.update(tempStr, \u003Cspan class=\"hljs-string\"\u003E'utf8'\u003C\u002Fspan\u003E).digest(\u003Cspan class=\"hljs-string\"\u003E'hex'\u003C\u002Fspan\u003E)\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (resultCode === signature) {\n    ctx.body = echostr\n  } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 非微信服务器请求\u003C\u002Fspan\u003E\n    ctx.body = format.formatResponse({\n      resultCode,\n      \u003Cspan class=\"hljs-attr\"\u003Ereq\u003C\u002Fspan\u003E: ctx.query\n    }, \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E'验证失败1'\u003C\u002Fspan\u003E)\n  }\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E自动回复操作：\n在\u003Ccode\u003Econtroller\u003C\u002Fcode\u003E层编写一个\u003Ccode\u003Epost\u003C\u002Fcode\u003E接口，对应\u003Ccode\u003E\u002Fmessage\u002Fcheck\u003C\u002Fcode\u003E，用于自动回复。\n完整处理自动回复接口：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Easync\u003C\u002Fspan\u003E handle() {\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E { ctx } = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E { FromUserName, MsgType, Content } = ctx.request.body \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这是从微信转发过来的用户发送的信息参数\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E { openid } = ctx.query\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 获取accessToken\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E tokenRes = \u003Cspan class=\"hljs-keyword\"\u003Eawait\u003C\u002Fspan\u003E rp(\u003Cspan class=\"hljs-string\"\u003E`https:\u002F\u002Fapi.weixin.qq.com\u002Fcgi-bin\u002Ftoken?grant_type=client_credential&amp;appid=\u003Cspan class=\"hljs-subst\"\u003E${CONST.appId}\u003C\u002Fspan\u003E&amp;secret=\u003Cspan class=\"hljs-subst\"\u003E${CONST.secret}\u003C\u002Fspan\u003E`\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!(\u003Cspan class=\"hljs-string\"\u003E'errcode'\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EJSON\u003C\u002Fspan\u003E.parse(tokenRes))) {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (MsgType === \u003Cspan class=\"hljs-string\"\u003E'text'\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E postData = {\n        \u003Cspan class=\"hljs-attr\"\u003Etouser\u003C\u002Fspan\u003E: openid,\n        \u003Cspan class=\"hljs-attr\"\u003Emsgtype\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E\"link\"\u003C\u002Fspan\u003E,\n        \u003Cspan class=\"hljs-attr\"\u003Elink\u003C\u002Fspan\u003E: {\n          \u003Cspan class=\"hljs-attr\"\u003Etitle\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'链接标题'\u003C\u002Fspan\u003E,\n          \u003Cspan class=\"hljs-attr\"\u003Edescription\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'链接描述'\u003C\u002Fspan\u003E,\n          \u003Cspan class=\"hljs-attr\"\u003Eurl\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'链接'\u003C\u002Fspan\u003E,\n          \u003Cspan class=\"hljs-attr\"\u003Ethumb_url\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'链接封面图'\u003C\u002Fspan\u003E\n        }\n      }\n      \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E sendRes = \u003Cspan class=\"hljs-keyword\"\u003Eawait\u003C\u002Fspan\u003E rp({\n        \u003Cspan class=\"hljs-attr\"\u003Euri\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E`https:\u002F\u002Fapi.weixin.qq.com\u002Fcgi-bin\u002Fmessage\u002Fcustom\u002Fsend?access_token=\u003Cspan class=\"hljs-subst\"\u003E${\u003Cspan class=\"hljs-built_in\"\u003EJSON\u003C\u002Fspan\u003E.parse(tokenRes).access_token}\u003C\u002Fspan\u003E`\u003C\u002Fspan\u003E,\n        \u003Cspan class=\"hljs-attr\"\u003Emethod\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'post'\u003C\u002Fspan\u003E,\n        \u003Cspan class=\"hljs-attr\"\u003Ebody\u003C\u002Fspan\u003E: postData,\n        \u003Cspan class=\"hljs-attr\"\u003Ejson\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E\n      })\n    }\n  }\n  ctx.body = \u003Cspan class=\"hljs-string\"\u003E'success'\u003C\u002Fspan\u003E\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E!&gt; 注意：需要在自动回复的最后返回\u003Ccode\u003Esuccess\u003C\u002Fcode\u003E，否则会在聊天窗口看到提示：\u003Ccode\u003E该小程序提供的服务出现故障，请稍后再试\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n",fmData:{attributes:{title:"小程序egg后台简要文档",description:"如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。",keywords:"mp,小程序,eggjs,微信开发后台",labels:["小程序"],date:"2019-06-06T00:00:00.000Z"},body:"如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。\n\n如果未接触过node编写接口，首先还是需要基本过一下[egg官方文档](https:\u002F\u002Feggjs.org\u002Fzh-cn\u002Fintro\u002F)，至少得把快速入门看完。\n\n不会从头开始把每一步都详细写下来，只针对微信对接的一些处理列出来。\n\n## 数据库\n\n使用mongo，示例通过[egg-mongoose](https:\u002F\u002Fgithub.com\u002Feggjs\u002Fegg-mongoose)进行连接处理。\n\n安装插件后，在`\u002Fconfig\u002Fplugin.js`进行基本配置：\n\n```javascript\nmongoose: {\n  enable: true,\n  package: 'egg-mongoose'\n}\n```\n\n在`\u002Fconfig\u002Fconfig.default.js`文件中配置mongodb的连接（保证本地测试环境数据库连接好）：\n\n```javascript\n\u002F\u002F connect mongo\n  config.mongoose = {\n    client: {\n      url: 'mongodb:\u002F\u002F127.0.0.1\u002Ffulishe',\n      options: {},\n    }\n  }\n```\n\n在`\u002Fapp\u002Fmodels`文件夹编写相关的model，在程序运行时会自动在mongo上创建对应的表。也可以优先创建好数据库和表设计等。\n\n## 编写接口\n\n在`controller`写主要的业务逻辑，接受接口请求参数并返回。\n对于入参，需要进行验证的可以做验证处理，需要处理返回结果，即使请求出错也不要返回非200的状态码。\n可以将处理结果设置为一个函数，如：\n\n```javascript\n\u002F\u002F data: 返回给前端的数据，code: 状态，1为成功，0为失败，message：状态信息\nformatResponse: function (data, code, message) {\n  return {\n    code,\n    data,\n    message\n  }\n}\n```\n\n!\u003E 为避免出现出现问题而导致程序中断，最好在每一个容易出现问题的地方进行`try catch`将异常抛出并返回到前端。\n\n在`service`编写数据库操作函数等，通过在`controller`进行调用，统一管理数据库数据进出。\n注意在数据新增的时候需要进行`save`操作：\n\n```javascript\nconst addUser = await this.ctx.model.Users(data)\naddUser.save() \u002F\u002F 不要遗漏\n```\n\n相关的增删改查操作，需要直接点的可以看仓库`app\u002Fservice`下的写法。\n\n## 小程序接口相关\n\n以下是eggjs对小程序包括获取openId、获取unionId、获取手机号码、判断用户是否关注公众号、客服信息发送进行编写说明。  \n如果某个对象不知道是什么，一般都是可以根据名字找到对于的js文件或者通过npm引入，不再表述引入什么了。\n\n### 获取openId\n\n参数说明：\n\n- APPID： 小程序的appId\n- SECRET： 小程序的secret，跟appId在同一个地方能找到\n- CODE：小程序在前端通过wx.login()获取的jscode\n\n```javascript\nconst openIdRes = await rp(`https:\u002F\u002Fapi.weixin.qq.com\u002Fsns\u002Fjscode2session?appid=${APPID}&secret=${SECRET}&js_code=${CODE}&grant_type=authorization_code`)\nconst openId = JSON.parse(openIdRes).openId \u002F\u002F 在处理错误判断后，返回的数据是json字符串，需要转化\n```\n\n### 获取unionId\n\nunionId，属于微信端通用的账号唯一标识，举个例子就是同一个微信号，唯一对应一个unionId。而在每一个小程序上，用户openId都不一样。可以用于判断在小程序上的用户是否关注公众号等。\n\n在第一个获取`openId`的时候，会返回`openId`以及`session_key`，通过小程序前端传过来的`encryptedData`以及`iv`就可以拿到`unionId`。\n\n参数说明：\n\n- APPID： 小程序的appId\n- sessionKey：获取openId的时候，一并返回了sessionKey\n- encryptedData：小程序在前端通过获取用户信息返回\n- iv：小程序在前端通过获取用户信息返回\n\n```javascript\nconst pc = new WXBizDataCrypt(APPID, sessionKey)\nconst data = pc.decryptData(encryptedData, iv)\nconst unionId = data.unionId\n```\n\n### 获取手机号码\n\n获取手机号码的步骤跟获取unionId一样。\n\n只需要注意的是，`encryptedData`、`iv`是在小程序端通过`getPhoneNumber`获取。\n\n### 判断用户是否关注公众号\n\n这里单独在小程序后台无法判断。需要在对于的公众号后台提供一个接口用于判断该unionId是否已经关注了公众号。\n\n### 客服信息发送\n\n在小程序开发设置中配置消息推送。\n\n配置参考： \n\n参数 | 值 |  备注  \n-|-|-\nURL(服务器地址) | https:\u002F\u002F*.*.com\u002Fmessage\u002Fcheck | 微信那边与你服务器通信的接口 |\nToken(令牌) | isToken | 自定义 |\nEncodingAESKey(消息加密密钥) | ****** | 填写那可以自动生成 |\n消息加密方式 | \t兼容模式 | 涉及信息安全 |\n数据格式 | \tJSON | 一般是这个吧 |\n\n在`controller`层编写一个`get`接口，对应`\u002Fmessage\u002Fcheck`，用以给微信进行服务器验证。\n完整验证函数接口可如下：\n\n```javascript\nasync index() {\n  const { ctx } = this\n  \u002F\u002F 1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr\n  const {\n    signature,\n    timestamp,\n    nonce,\n    echostr\n  } = ctx.query\n\n  \u002F\u002F 2.将token、timestamp、nonce三个参数进行字典序排序\n  let array = ['线上配置的令牌', timestamp, nonce]\n  array.sort() \u002F\u002F JavaScript sort函数就是字典序排序的\n\n  \u002F\u002F 3.将三个参数字符串拼接成一个字符串进行sha1加密\n  const tempStr = array.join('')\n  const hashCode = crypto.createHash('sha1') \u002F\u002F创建加密类型\n  const resultCode = hashCode.update(tempStr, 'utf8').digest('hex')\n\n  \u002F\u002F 4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信\n  if (resultCode === signature) {\n    ctx.body = echostr\n  } else {\n    \u002F\u002F 非微信服务器请求\n    ctx.body = format.formatResponse({\n      resultCode,\n      req: ctx.query\n    }, 0, '验证失败1')\n  }\n}\n```\n\n自动回复操作：\n在`controller`层编写一个`post`接口，对应`\u002Fmessage\u002Fcheck`，用于自动回复。\n完整处理自动回复接口：\n\n```javascript\nasync handle() {\n  const { ctx } = this\n  const { FromUserName, MsgType, Content } = ctx.request.body \u002F\u002F 这是从微信转发过来的用户发送的信息参数\n  const { openid } = ctx.query\n  \u002F\u002F 获取accessToken\n  const tokenRes = await rp(`https:\u002F\u002Fapi.weixin.qq.com\u002Fcgi-bin\u002Ftoken?grant_type=client_credential&appid=${CONST.appId}&secret=${CONST.secret}`)\n  if (!('errcode' in JSON.parse(tokenRes))) {\n    if (MsgType === 'text') {\n      const postData = {\n        touser: openid,\n        msgtype: \"link\",\n        link: {\n          title: '链接标题',\n          description: '链接描述',\n          url: '链接',\n          thumb_url: '链接封面图'\n        }\n      }\n      const sendRes = await rp({\n        uri: `https:\u002F\u002Fapi.weixin.qq.com\u002Fcgi-bin\u002Fmessage\u002Fcustom\u002Fsend?access_token=${JSON.parse(tokenRes).access_token}`,\n        method: 'post',\n        body: postData,\n        json: true\n      })\n    }\n  }\n  ctx.body = 'success'\n}\n```\n!\u003E 注意：需要在自动回复的最后返回`success`，否则会在聊天窗口看到提示：`该小程序提供的服务出现故障，请稍后再试`\n",bodyBegin:9,frontmatter:"title: 小程序egg后台简要文档\ndescription: 如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。\nkeywords: mp,小程序,eggjs,微信开发后台\nlabels: ['小程序']\ndate: 2019-06-06"}}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.34d3e2bd.js"}catch(e){main="/client/legacy/client.9a4bf57e.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1" async></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 