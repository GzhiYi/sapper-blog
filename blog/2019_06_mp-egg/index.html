<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <link href=client/client-e118e612.css rel=stylesheet> <title>小程序egg后台简要文档-GzhiYi's blog</title><meta content=如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。 name=description data-svelte=svelte-2vncnt><meta content=mp,小程序,eggjs,微信开发后台 name=keywords data-svelte=svelte-2vncnt> <link href=/client/client.1c84caa9.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-e118e612.css rel=preload as=style><link href=/client/[slug].9af4de7d.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/config.026ad977.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials></head> <body> <div id=sapper> <nav class=svelte-1dbd5up><ul class=svelte-1dbd5up><li class=svelte-1dbd5up><a href=. class=svelte-1dbd5up>home</a></li> <li class=svelte-1dbd5up><a href=about class=svelte-1dbd5up>about</a></li> <li class=svelte-1dbd5up><a href=blog class=svelte-1dbd5up aria-current=page rel=prefetch>blog</a></ul></nav> <main class=svelte-1uhnsl8> <div class=flex><div class=base><div class=title>小程序egg后台简要文档</div> <span>2019-06-06</span></div> <div class=content><p>如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。</p> <p>如果未接触过node编写接口，首先还是需要基本过一下<a href=https://eggjs.org/zh-cn/intro/ target=_blank>egg官方文档</a>，至少得把快速入门看完。</p> <p>不会从头开始把每一步都详细写下来，只针对微信对接的一些处理列出来。</p> <h2 id=数据库>数据库</h2> <p>使用mongo，示例通过<a href=https://github.com/eggjs/egg-mongoose target=_blank>egg-mongoose</a>进行连接处理。</p> <p>安装插件后，在<code>/config/plugin.js</code>进行基本配置：</p> <pre><code class=language-javascript><span class=hljs-attr>mongoose:</span> {
  <span class=hljs-attr>enable:</span> <span class=hljs-literal>true</span>,
  <span class=hljs-attr>package:</span> <span class=hljs-string>'egg-mongoose'</span>
}
</code></pre> <p>在<code>/config/config.default.js</code>文件中配置mongodb的连接（保证本地测试环境数据库连接好）：</p> <pre><code class=language-javascript>// connect mongo
  config.mongoose = {
    clien<span class=hljs-variable>t:</span> {
      ur<span class=hljs-variable>l:</span> <span class=hljs-string>'mongodb://127.0.0.1/fulishe'</span>,
      option<span class=hljs-variable>s:</span> {},
    }
  }
</code></pre> <p>在<code>/app/models</code>文件夹编写相关的model，在程序运行时会自动在mongo上创建对应的表。也可以优先创建好数据库和表设计等。</p> <h2 id=编写接口>编写接口</h2> <p>在<code>controller</code>写主要的业务逻辑，接受接口请求参数并返回。 对于入参，需要进行验证的可以做验证处理，需要处理返回结果，即使请求出错也不要返回非200的状态码。 可以将处理结果设置为一个函数，如：</p> <pre><code class=language-javascript><span class=hljs-comment>// data: 返回给前端的数据，code: 状态，1为成功，0为失败，message：状态信息</span>
<span class=hljs-symbol>formatResponse:</span> <span class=hljs-meta>function</span> (<span class=hljs-meta>data</span>, <span class=hljs-meta>code</span>, message) {
  return {
    <span class=hljs-meta>code</span>,
    <span class=hljs-meta>data</span>,
    message
  }
}
</code></pre> <p>!> 为避免出现出现问题而导致程序中断，最好在每一个容易出现问题的地方进行<code>try catch</code>将异常抛出并返回到前端。</p> <p>在<code>service</code>编写数据库操作函数等，通过在<code>controller</code>进行调用，统一管理数据库数据进出。 注意在数据新增的时候需要进行<code>save</code>操作：</p> <pre><code class=language-javascript><span class=hljs-keyword>const</span> addUser = await <span class=hljs-keyword>this</span>.ctx.model.Users(<span class=hljs-keyword>data</span>)
addUser.save() <span class=hljs-comment>// 不要遗漏</span>
</code></pre> <p>相关的增删改查操作，需要直接点的可以看仓库<code>app/service</code>下的写法。</p> <h2 id=小程序接口相关>小程序接口相关</h2> <p>以下是eggjs对小程序包括获取openId、获取unionId、获取手机号码、判断用户是否关注公众号、客服信息发送进行编写说明。<br>如果某个对象不知道是什么，一般都是可以根据名字找到对于的js文件或者通过npm引入，不再表述引入什么了。</p> <h3 id=获取openid>获取openId</h3> <p>参数说明：</p> <ul> <li>APPID： 小程序的appId</li> <li>SECRET： 小程序的secret，跟appId在同一个地方能找到</li> <li>CODE：小程序在前端通过wx.login()获取的jscode</li> </ul> <pre><code class=language-javascript>const openIdRes = await rp(`https:<span class=hljs-regexp>//</span>api.weixin.qq.com<span class=hljs-regexp>/sns/</span>jscode2session?appid=<span class=hljs-variable>${APPID}</span>&secret=<span class=hljs-variable>${SECRET}</span>&js_code=<span class=hljs-variable>${CODE}</span>&grant_type=authorization_code`)
const openId = JSON.parse(openIdRes).openId <span class=hljs-regexp>//</span> 在处理错误判断后，返回的数据是json字符串，需要转化
</code></pre> <h3 id=获取unionid>获取unionId</h3> <p>unionId，属于微信端通用的账号唯一标识，举个例子就是同一个微信号，唯一对应一个unionId。而在每一个小程序上，用户openId都不一样。可以用于判断在小程序上的用户是否关注公众号等。</p> <p>在第一个获取<code>openId</code>的时候，会返回<code>openId</code>以及<code>session_key</code>，通过小程序前端传过来的<code>encryptedData</code>以及<code>iv</code>就可以拿到<code>unionId</code>。</p> <p>参数说明：</p> <ul> <li>APPID： 小程序的appId</li> <li>sessionKey：获取openId的时候，一并返回了sessionKey</li> <li>encryptedData：小程序在前端通过获取用户信息返回</li> <li>iv：小程序在前端通过获取用户信息返回</li> </ul> <pre><code class=language-javascript>const pc = <span class=hljs-keyword>new</span> <span class=hljs-constructor>WXBizDataCrypt(APPID, <span class=hljs-params>sessionKey</span>)</span>
const data = pc.decrypt<span class=hljs-constructor>Data(<span class=hljs-params>encryptedData</span>, <span class=hljs-params>iv</span>)</span>
const unionId = data.unionId
</code></pre> <h3 id=获取手机号码>获取手机号码</h3> <p>获取手机号码的步骤跟获取unionId一样。</p> <p>只需要注意的是，<code>encryptedData</code>、<code>iv</code>是在小程序端通过<code>getPhoneNumber</code>获取。</p> <h3 id=判断用户是否关注公众号>判断用户是否关注公众号</h3> <p>这里单独在小程序后台无法判断。需要在对于的公众号后台提供一个接口用于判断该unionId是否已经关注了公众号。</p> <h3 id=客服信息发送>客服信息发送</h3> <p>在小程序开发设置中配置消息推送。</p> <p>配置参考： </p> <table> <thead> <tr> <th>参数</th> <th>值</th> <th>备注</th> </tr> </thead> <tr> <td>URL(服务器地址)</td> <td>https://<em>.</em>.com/message/check</td> <td>微信那边与你服务器通信的接口</td> </tr> <tr> <td>Token(令牌)</td> <td>isToken</td> <td>自定义</td> </tr> <tr> <td>EncodingAESKey(消息加密密钥)</td> <td>******</td> <td>填写那可以自动生成</td> </tr> <tr> <td>消息加密方式</td> <td>兼容模式</td> <td>涉及信息安全</td> </tr> <tr> <td>数据格式</td> <td>JSON</td> <td>一般是这个吧</td> </tr> </table> <p>在<code>controller</code>层编写一个<code>get</code>接口，对应<code>/message/check</code>，用以给微信进行服务器验证。 完整验证函数接口可如下：</p> <pre><code class=language-javascript><span class=hljs-function><span class=hljs-keyword>async</span> <span class=hljs-title>index</span>(<span class=hljs-params></span>)</span> {
  <span class=hljs-keyword>const</span> { ctx } = <span class=hljs-keyword>this</span>
  <span class=hljs-comment>// 1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr</span>
  <span class=hljs-keyword>const</span> {
    signature,
    timestamp,
    nonce,
    echostr
  } = ctx.query

  <span class=hljs-comment>// 2.将token、timestamp、nonce三个参数进行字典序排序</span>
  <span class=hljs-keyword>let</span> array = [<span class=hljs-string>'线上配置的令牌'</span>, timestamp, nonce]
  array.sort() <span class=hljs-comment>// JavaScript sort函数就是字典序排序的</span>

  <span class=hljs-comment>// 3.将三个参数字符串拼接成一个字符串进行sha1加密</span>
  <span class=hljs-keyword>const</span> tempStr = array.<span class=hljs-keyword>join</span>(<span class=hljs-string>''</span>)
  <span class=hljs-keyword>const</span> hashCode = crypto.createHash(<span class=hljs-string>'sha1'</span>) <span class=hljs-comment>//创建加密类型</span>
  <span class=hljs-keyword>const</span> resultCode = hashCode.update(tempStr, <span class=hljs-string>'utf8'</span>).digest(<span class=hljs-string>'hex'</span>)

  <span class=hljs-comment>// 4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</span>
  <span class=hljs-keyword>if</span> (resultCode === signature) {
    ctx.body = echostr
  } <span class=hljs-keyword>else</span> {
    <span class=hljs-comment>// 非微信服务器请求</span>
    ctx.body = format.formatResponse({
      resultCode,
      req: ctx.query
    }, <span class=hljs-number>0</span>, <span class=hljs-string>'验证失败1'</span>)
  }
}
</code></pre> <p>自动回复操作： 在<code>controller</code>层编写一个<code>post</code>接口，对应<code>/message/check</code>，用于自动回复。 完整处理自动回复接口：</p> <pre><code class=language-javascript><span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-title>handle</span>(<span class=hljs-params></span>)</span> {
  <span class=hljs-keyword>const</span> { ctx } = <span class=hljs-built_in>this</span>
  <span class=hljs-keyword>const</span> { FromUserName, MsgType, Content } = ctx.request.body <span class=hljs-comment>// 这是从微信转发过来的用户发送的信息参数</span>
  <span class=hljs-keyword>const</span> { openid } = ctx.query
  <span class=hljs-comment>// 获取accessToken</span>
  <span class=hljs-keyword>const</span> tokenRes = <span class=hljs-keyword>await</span> rp(<span class=hljs-string>`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=<span class=hljs-subst>${CONST.appId}</span>&secret=<span class=hljs-subst>${CONST.secret}</span>`</span>)
  <span class=hljs-keyword>if</span> (!(<span class=hljs-string>'errcode'</span> <span class=hljs-keyword>in</span> <span class=hljs-built_in>JSON</span>.parse(tokenRes))) {
    <span class=hljs-keyword>if</span> (MsgType === <span class=hljs-string>'text'</span>) {
      <span class=hljs-keyword>const</span> postData = {
        <span class=hljs-attr>touser</span>: openid,
        <span class=hljs-attr>msgtype</span>: <span class=hljs-string>"link"</span>,
        <span class=hljs-attr>link</span>: {
          <span class=hljs-attr>title</span>: <span class=hljs-string>'链接标题'</span>,
          <span class=hljs-attr>description</span>: <span class=hljs-string>'链接描述'</span>,
          <span class=hljs-attr>url</span>: <span class=hljs-string>'链接'</span>,
          <span class=hljs-attr>thumb_url</span>: <span class=hljs-string>'链接封面图'</span>
        }
      }
      <span class=hljs-keyword>const</span> sendRes = <span class=hljs-keyword>await</span> rp({
        <span class=hljs-attr>uri</span>: <span class=hljs-string>`https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=<span class=hljs-subst>${<span class=hljs-built_in>JSON</span>.parse(tokenRes).access_token}</span>`</span>,
        <span class=hljs-attr>method</span>: <span class=hljs-string>'post'</span>,
        <span class=hljs-attr>body</span>: postData,
        <span class=hljs-attr>json</span>: <span class=hljs-literal>true</span>
      })
    }
  }
  ctx.body = <span class=hljs-string>'success'</span>
}
</code></pre> <p>!> 注意：需要在自动回复的最后返回<code>success</code>，否则会在聊天窗口看到提示：<code>该小程序提供的服务出现故障，请稍后再试</code></p> </div> </div></main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"小程序egg后台简要文档",description:"如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。",keywords:"mp,小程序,eggjs,微信开发后台",labels:["小程序"],date:"2019-06-06",path:"2019\u002F06\u002Fmp-egg.md",slug:"2019_06_mp-egg",html:"\u003Cp\u003E如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。\u003C\u002Fp\u003E\n\u003Cp\u003E如果未接触过node编写接口，首先还是需要基本过一下\u003Ca target='_blank'  href=\"https:\u002F\u002Feggjs.org\u002Fzh-cn\u002Fintro\u002F\"\u003Eegg官方文档\u003C\u002Fa\u003E，至少得把快速入门看完。\u003C\u002Fp\u003E\n\u003Cp\u003E不会从头开始把每一步都详细写下来，只针对微信对接的一些处理列出来。\u003C\u002Fp\u003E\n\u003Ch2 id=\"数据库\"\u003E数据库\u003C\u002Fh2\u003E\n\u003Cp\u003E使用mongo，示例通过\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Feggjs\u002Fegg-mongoose\"\u003Eegg-mongoose\u003C\u002Fa\u003E进行连接处理。\u003C\u002Fp\u003E\n\u003Cp\u003E安装插件后，在\u003Ccode\u003E\u002Fconfig\u002Fplugin.js\u003C\u002Fcode\u003E进行基本配置：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-attr\"\u003Emongoose:\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-attr\"\u003Eenable:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E,\n  \u003Cspan class=\"hljs-attr\"\u003Epackage:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;egg-mongoose&#x27;\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在\u003Ccode\u003E\u002Fconfig\u002Fconfig.default.js\u003C\u002Fcode\u003E文件中配置mongodb的连接（保证本地测试环境数据库连接好）：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u002F\u002F connect mongo\n  config.mongoose = {\n    clien\u003Cspan class=\"hljs-variable\"\u003Et:\u003C\u002Fspan\u003E {\n      ur\u003Cspan class=\"hljs-variable\"\u003El:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;mongodb:\u002F\u002F127.0.0.1\u002Ffulishe&#x27;\u003C\u002Fspan\u003E,\n      option\u003Cspan class=\"hljs-variable\"\u003Es:\u003C\u002Fspan\u003E {},\n    }\n  }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在\u003Ccode\u003E\u002Fapp\u002Fmodels\u003C\u002Fcode\u003E文件夹编写相关的model，在程序运行时会自动在mongo上创建对应的表。也可以优先创建好数据库和表设计等。\u003C\u002Fp\u003E\n\u003Ch2 id=\"编写接口\"\u003E编写接口\u003C\u002Fh2\u003E\n\u003Cp\u003E在\u003Ccode\u003Econtroller\u003C\u002Fcode\u003E写主要的业务逻辑，接受接口请求参数并返回。\n对于入参，需要进行验证的可以做验证处理，需要处理返回结果，即使请求出错也不要返回非200的状态码。\n可以将处理结果设置为一个函数，如：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F data: 返回给前端的数据，code: 状态，1为成功，0为失败，message：状态信息\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-symbol\"\u003EformatResponse:\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-meta\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-meta\"\u003Edata\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-meta\"\u003Ecode\u003C\u002Fspan\u003E, message) {\n  return {\n    \u003Cspan class=\"hljs-meta\"\u003Ecode\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-meta\"\u003Edata\u003C\u002Fspan\u003E,\n    message\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E!&gt; 为避免出现出现问题而导致程序中断，最好在每一个容易出现问题的地方进行\u003Ccode\u003Etry catch\u003C\u002Fcode\u003E将异常抛出并返回到前端。\u003C\u002Fp\u003E\n\u003Cp\u003E在\u003Ccode\u003Eservice\u003C\u002Fcode\u003E编写数据库操作函数等，通过在\u003Ccode\u003Econtroller\u003C\u002Fcode\u003E进行调用，统一管理数据库数据进出。\n注意在数据新增的时候需要进行\u003Ccode\u003Esave\u003C\u002Fcode\u003E操作：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E addUser = await \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E.ctx.model.Users(\u003Cspan class=\"hljs-keyword\"\u003Edata\u003C\u002Fspan\u003E)\naddUser.save() \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 不要遗漏\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E相关的增删改查操作，需要直接点的可以看仓库\u003Ccode\u003Eapp\u002Fservice\u003C\u002Fcode\u003E下的写法。\u003C\u002Fp\u003E\n\u003Ch2 id=\"小程序接口相关\"\u003E小程序接口相关\u003C\u002Fh2\u003E\n\u003Cp\u003E以下是eggjs对小程序包括获取openId、获取unionId、获取手机号码、判断用户是否关注公众号、客服信息发送进行编写说明。\u003Cbr\u003E如果某个对象不知道是什么，一般都是可以根据名字找到对于的js文件或者通过npm引入，不再表述引入什么了。\u003C\u002Fp\u003E\n\u003Ch3 id=\"获取openid\"\u003E获取openId\u003C\u002Fh3\u003E\n\u003Cp\u003E参数说明：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EAPPID： 小程序的appId\u003C\u002Fli\u003E\n\u003Cli\u003ESECRET： 小程序的secret，跟appId在同一个地方能找到\u003C\u002Fli\u003E\n\u003Cli\u003ECODE：小程序在前端通过wx.login()获取的jscode\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Econst openIdRes = await rp(`https:\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003Eapi.weixin.qq.com\u003Cspan class=\"hljs-regexp\"\u003E\u002Fsns\u002F\u003C\u002Fspan\u003Ejscode2session?appid=\u003Cspan class=\"hljs-variable\"\u003E${APPID}\u003C\u002Fspan\u003E&amp;secret=\u003Cspan class=\"hljs-variable\"\u003E${SECRET}\u003C\u002Fspan\u003E&amp;js_code=\u003Cspan class=\"hljs-variable\"\u003E${CODE}\u003C\u002Fspan\u003E&amp;grant_type=authorization_code`)\nconst openId = JSON.parse(openIdRes).openId \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 在处理错误判断后，返回的数据是json字符串，需要转化\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"获取unionid\"\u003E获取unionId\u003C\u002Fh3\u003E\n\u003Cp\u003EunionId，属于微信端通用的账号唯一标识，举个例子就是同一个微信号，唯一对应一个unionId。而在每一个小程序上，用户openId都不一样。可以用于判断在小程序上的用户是否关注公众号等。\u003C\u002Fp\u003E\n\u003Cp\u003E在第一个获取\u003Ccode\u003EopenId\u003C\u002Fcode\u003E的时候，会返回\u003Ccode\u003EopenId\u003C\u002Fcode\u003E以及\u003Ccode\u003Esession_key\u003C\u002Fcode\u003E，通过小程序前端传过来的\u003Ccode\u003EencryptedData\u003C\u002Fcode\u003E以及\u003Ccode\u003Eiv\u003C\u002Fcode\u003E就可以拿到\u003Ccode\u003EunionId\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E参数说明：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EAPPID： 小程序的appId\u003C\u002Fli\u003E\n\u003Cli\u003EsessionKey：获取openId的时候，一并返回了sessionKey\u003C\u002Fli\u003E\n\u003Cli\u003EencryptedData：小程序在前端通过获取用户信息返回\u003C\u002Fli\u003E\n\u003Cli\u003Eiv：小程序在前端通过获取用户信息返回\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Econst pc = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-constructor\"\u003EWXBizDataCrypt(APPID, \u003Cspan class=\"hljs-params\"\u003EsessionKey\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\nconst data = pc.decrypt\u003Cspan class=\"hljs-constructor\"\u003EData(\u003Cspan class=\"hljs-params\"\u003EencryptedData\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Eiv\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\nconst unionId = data.unionId\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"获取手机号码\"\u003E获取手机号码\u003C\u002Fh3\u003E\n\u003Cp\u003E获取手机号码的步骤跟获取unionId一样。\u003C\u002Fp\u003E\n\u003Cp\u003E只需要注意的是，\u003Ccode\u003EencryptedData\u003C\u002Fcode\u003E、\u003Ccode\u003Eiv\u003C\u002Fcode\u003E是在小程序端通过\u003Ccode\u003EgetPhoneNumber\u003C\u002Fcode\u003E获取。\u003C\u002Fp\u003E\n\u003Ch3 id=\"判断用户是否关注公众号\"\u003E判断用户是否关注公众号\u003C\u002Fh3\u003E\n\u003Cp\u003E这里单独在小程序后台无法判断。需要在对于的公众号后台提供一个接口用于判断该unionId是否已经关注了公众号。\u003C\u002Fp\u003E\n\u003Ch3 id=\"客服信息发送\"\u003E客服信息发送\u003C\u002Fh3\u003E\n\u003Cp\u003E在小程序开发设置中配置消息推送。\u003C\u002Fp\u003E\n\u003Cp\u003E配置参考： \u003C\u002Fp\u003E\n\u003Ctable\u003E\n\u003Cthead\u003E\n\u003Ctr\u003E\n\u003Cth\u003E参数\u003C\u002Fth\u003E\n\u003Cth\u003E值\u003C\u002Fth\u003E\n\u003Cth\u003E备注\u003C\u002Fth\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Fthead\u003E\n\u003Ctbody\u003E\u003Ctr\u003E\n\u003Ctd\u003EURL(服务器地址)\u003C\u002Ftd\u003E\n\u003Ctd\u003Ehttps:\u002F\u002F\u003Cem\u003E.\u003C\u002Fem\u003E.com\u002Fmessage\u002Fcheck\u003C\u002Ftd\u003E\n\u003Ctd\u003E微信那边与你服务器通信的接口\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EToken(令牌)\u003C\u002Ftd\u003E\n\u003Ctd\u003EisToken\u003C\u002Ftd\u003E\n\u003Ctd\u003E自定义\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003EEncodingAESKey(消息加密密钥)\u003C\u002Ftd\u003E\n\u003Ctd\u003E******\u003C\u002Ftd\u003E\n\u003Ctd\u003E填写那可以自动生成\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E消息加密方式\u003C\u002Ftd\u003E\n\u003Ctd\u003E兼容模式\u003C\u002Ftd\u003E\n\u003Ctd\u003E涉及信息安全\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003Ctr\u003E\n\u003Ctd\u003E数据格式\u003C\u002Ftd\u003E\n\u003Ctd\u003EJSON\u003C\u002Ftd\u003E\n\u003Ctd\u003E一般是这个吧\u003C\u002Ftd\u003E\n\u003C\u002Ftr\u003E\n\u003C\u002Ftbody\u003E\u003C\u002Ftable\u003E\n\u003Cp\u003E在\u003Ccode\u003Econtroller\u003C\u002Fcode\u003E层编写一个\u003Ccode\u003Eget\u003C\u002Fcode\u003E接口，对应\u003Ccode\u003E\u002Fmessage\u002Fcheck\u003C\u002Fcode\u003E，用以给微信进行服务器验证。\n完整验证函数接口可如下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Easync\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eindex\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E { ctx } = \u003Cspan class=\"hljs-keyword\"\u003Ethis\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E {\n    signature,\n    timestamp,\n    nonce,\n    echostr\n  } = ctx.query\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 2.将token、timestamp、nonce三个参数进行字典序排序\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E array = [\u003Cspan class=\"hljs-string\"\u003E&#x27;线上配置的令牌&#x27;\u003C\u002Fspan\u003E, timestamp, nonce]\n  array.sort() \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F JavaScript sort函数就是字典序排序的\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 3.将三个参数字符串拼接成一个字符串进行sha1加密\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E tempStr = array.\u003Cspan class=\"hljs-keyword\"\u003Ejoin\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&#x27;&#x27;\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E hashCode = crypto.createHash(\u003Cspan class=\"hljs-string\"\u003E&#x27;sha1&#x27;\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F创建加密类型\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E resultCode = hashCode.update(tempStr, \u003Cspan class=\"hljs-string\"\u003E&#x27;utf8&#x27;\u003C\u002Fspan\u003E).digest(\u003Cspan class=\"hljs-string\"\u003E&#x27;hex&#x27;\u003C\u002Fspan\u003E)\n\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (resultCode === signature) {\n    ctx.body = echostr\n  } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 非微信服务器请求\u003C\u002Fspan\u003E\n    ctx.body = format.formatResponse({\n      resultCode,\n      req: ctx.query\n    }, \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E&#x27;验证失败1&#x27;\u003C\u002Fspan\u003E)\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E自动回复操作：\n在\u003Ccode\u003Econtroller\u003C\u002Fcode\u003E层编写一个\u003Ccode\u003Epost\u003C\u002Fcode\u003E接口，对应\u003Ccode\u003E\u002Fmessage\u002Fcheck\u003C\u002Fcode\u003E，用于自动回复。\n完整处理自动回复接口：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Easync\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-title\"\u003Ehandle\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E { ctx } = \u003Cspan class=\"hljs-built_in\"\u003Ethis\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E { FromUserName, MsgType, Content } = ctx.request.body \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这是从微信转发过来的用户发送的信息参数\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E { openid } = ctx.query\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 获取accessToken\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E tokenRes = \u003Cspan class=\"hljs-keyword\"\u003Eawait\u003C\u002Fspan\u003E rp(\u003Cspan class=\"hljs-string\"\u003E`https:\u002F\u002Fapi.weixin.qq.com\u002Fcgi-bin\u002Ftoken?grant_type=client_credential&amp;appid=\u003Cspan class=\"hljs-subst\"\u003E${CONST.appId}\u003C\u002Fspan\u003E&amp;secret=\u003Cspan class=\"hljs-subst\"\u003E${CONST.secret}\u003C\u002Fspan\u003E`\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (!(\u003Cspan class=\"hljs-string\"\u003E&#x27;errcode&#x27;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ein\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EJSON\u003C\u002Fspan\u003E.parse(tokenRes))) {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (MsgType === \u003Cspan class=\"hljs-string\"\u003E&#x27;text&#x27;\u003C\u002Fspan\u003E) {\n      \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E postData = {\n        \u003Cspan class=\"hljs-attr\"\u003Etouser\u003C\u002Fspan\u003E: openid,\n        \u003Cspan class=\"hljs-attr\"\u003Emsgtype\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;link&quot;\u003C\u002Fspan\u003E,\n        \u003Cspan class=\"hljs-attr\"\u003Elink\u003C\u002Fspan\u003E: {\n          \u003Cspan class=\"hljs-attr\"\u003Etitle\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;链接标题&#x27;\u003C\u002Fspan\u003E,\n          \u003Cspan class=\"hljs-attr\"\u003Edescription\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;链接描述&#x27;\u003C\u002Fspan\u003E,\n          \u003Cspan class=\"hljs-attr\"\u003Eurl\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;链接&#x27;\u003C\u002Fspan\u003E,\n          \u003Cspan class=\"hljs-attr\"\u003Ethumb_url\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;链接封面图&#x27;\u003C\u002Fspan\u003E\n        }\n      }\n      \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E sendRes = \u003Cspan class=\"hljs-keyword\"\u003Eawait\u003C\u002Fspan\u003E rp({\n        \u003Cspan class=\"hljs-attr\"\u003Euri\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E`https:\u002F\u002Fapi.weixin.qq.com\u002Fcgi-bin\u002Fmessage\u002Fcustom\u002Fsend?access_token=\u003Cspan class=\"hljs-subst\"\u003E${\u003Cspan class=\"hljs-built_in\"\u003EJSON\u003C\u002Fspan\u003E.parse(tokenRes).access_token}\u003C\u002Fspan\u003E`\u003C\u002Fspan\u003E,\n        \u003Cspan class=\"hljs-attr\"\u003Emethod\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;post&#x27;\u003C\u002Fspan\u003E,\n        \u003Cspan class=\"hljs-attr\"\u003Ebody\u003C\u002Fspan\u003E: postData,\n        \u003Cspan class=\"hljs-attr\"\u003Ejson\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-literal\"\u003Etrue\u003C\u002Fspan\u003E\n      })\n    }\n  }\n  ctx.body = \u003Cspan class=\"hljs-string\"\u003E&#x27;success&#x27;\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E!&gt; 注意：需要在自动回复的最后返回\u003Ccode\u003Esuccess\u003C\u002Fcode\u003E，否则会在聊天窗口看到提示：\u003Ccode\u003E该小程序提供的服务出现故障，请稍后再试\u003C\u002Fcode\u003E\u003C\u002Fp\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.1c84caa9.js"}catch(e){main="/client/legacy/client.80874f6f.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 