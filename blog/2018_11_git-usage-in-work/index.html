<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=1280" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <link href=client/client-8d9aba14.css rel=stylesheet><link href=client/[slug]-636f444e.css rel=stylesheet> <title>git在工作中的一些用处-GzhiYi's blog</title><meta content=git内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。 name=description data-svelte=svelte-2vncnt><meta content="git,工作中,用处,git工作流,分支,git rebase,git merge" name=keywords data-svelte=svelte-2vncnt> <link href=/client/client.796a17e3.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-8d9aba14.css rel=preload as=style><link href=/client/[slug].9001d1d3.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/config.026ad977.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/[slug]-636f444e.css rel=preload as=style></head> <body> <div id=sapper> <nav class=svelte-1dbd5up><ul class=svelte-1dbd5up> <li class=svelte-1dbd5up><a href=blog aria-current=page class=svelte-1dbd5up rel=prefetch>blog</a></ul></nav> <main class=svelte-1y51i2> <div class="svelte-1cnt1lz base"><div class=label>学习</div> <div class="svelte-1cnt1lz title">git在工作中的一些用处</div> <span class="svelte-1cnt1lz author">GzhiYi · 2018-11-28</span></div> <div class="svelte-1cnt1lz content"><p><img align=center alt=banner data-zoomable src=https://images.vrm.cn/2018/11/26/banner.png style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3></p> <p>本周四分享会主题：__git在工作中的一些用处__。 </p> <p>git内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。<strong>基本的概念不会多说</strong>，都能在入门教程那些学习到。接下来会说下git在工作中比较常用的功能，会发现，其实git能做的事情还是非常多的。</p> <h3 id=git在开发中常用的命令>git在开发中常用的命令</h3> <p><strong>编辑和代码提交</strong></p> <pre><code class=language-bash><span class=hljs-meta># 为git初始化一个代码库</span>
git init

<span class=hljs-meta># 将目录的所有文件提交到暂存区</span>
git add .

<span class=hljs-meta># 提交暂存区到代码仓库区，并添加提交信息</span>
git commit -m <span class=hljs-string>"commit message"</span>
</code></pre> <p><strong>分支处理</strong></p> <pre><code class=language-bash>
<span class=hljs-comment># 列出本地所有的分支</span>
git <span class=hljs-keyword>branch
</span>
<span class=hljs-comment># 列出远程仓库的所有分支</span>
git <span class=hljs-keyword>branch </span>-r

<span class=hljs-comment># 列出仓库的所有分支（包含远端和本地分支）</span>
git <span class=hljs-keyword>branch </span>-a

<span class=hljs-comment># 切换到指定分支，并更新工作区</span>
git checkout [<span class=hljs-keyword>branchName]
</span>
<span class=hljs-comment># 新建一个分支并切换到该分支</span>
git checkout -<span class=hljs-keyword>b </span>[<span class=hljs-keyword>branchName]
</span>
<span class=hljs-comment># 删除一个分支</span>
git <span class=hljs-keyword>branch </span>-d [<span class=hljs-keyword>branchName]
</span>
<span class=hljs-comment># 强制删除一个分支</span>
git <span class=hljs-keyword>branch </span>-D [<span class=hljs-keyword>branchName]</span>
</code></pre> <p><strong>查看状态信息</strong></p> <pre><code class=language-bash><span class=hljs-meta># 查看变更的文件，可多用这个命令查看当前文件改动状态</span>
git status

<span class=hljs-meta># 查看当前分支提交历史，可以得到加密的commit_id</span>
git log

<span class=hljs-meta># 查看暂存区和工作区的对比</span>
git diff
</code></pre> <p><strong>同步远程仓库</strong></p> <pre><code class=language-bash><span class=hljs-meta># 同步远程仓库的所有更新</span>
git fetch [remote]

<span class=hljs-meta># 显示所有远程仓库</span>
git remote -v

<span class=hljs-meta># 增加一个新的远程仓库，并定义一个远程仓库名，shortName常用origin，当然可自定义</span>
git remote add [shortName] url

<span class=hljs-meta># 拉取远端分支，并与本地分支合并</span>
git pull [remote] [branchName]

<span class=hljs-meta># 上传本地分支到远端</span>
git push [remote] [branchName]
</code></pre> <p><strong>撤销操作</strong></p> <pre><code class=language-bash><span class=hljs-meta># 恢复暂存区的指定文件到工作区</span>
git checkout [file]

<span class=hljs-meta># 恢复暂存区的所有文件到工作区</span>
git checkout .
</code></pre> <p><img align=center alt=image data-zoomable src=https://user-images.githubusercontent.com/21136420/49006081-37a00f80-f1a3-11e8-982e-c02cd71c1495.png style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3></p> <p>git工作中常用命令基本可以上图概括。</p> <hr> <p><strong>其它常用的命令</strong> 单独拿出来说是因为平常知道用的可能不会很多，但实际用起来会非常有用。</p> <ol> <li><code>git stash</code></li> </ol> <p>当你在工作的时候，累计了比较多的改动，但是突然间需要临时切换到其它分支工作，可是又不好把中途工作的内容提交，那怎么办？这时候git stash就有用了。</p> <pre><code class=language-bash><span class=hljs-meta># 查看文件变更状态</span>
git status

<span class=hljs-meta># 储藏变更，这时候会提示已储藏变更</span>
git stash

<span class=hljs-meta># 当在其它分支工作完回到原来分支的时候，可以查看储藏列表</span>
git stash list

<span class=hljs-meta># 恢复储藏，这时候文件变更就回来了，listNum为列表序号</span>
git stash apply stash@{listNum}
</code></pre> <ol start=2> <li><code>git rebase</code></li> </ol> <p>一般我们完成代码后，需要将分支的改动进行整合，会用到合并（merge）操作，但这不是唯一的方式，Rebase就是其中的代替方式。<br>先来说说merge。我们在需要合并的时候，会有如下的两种基本情况： </p> <p><img align=center alt=情况1 data-zoomable src=https://images.vrm.cn/2018/11/27/starting-situation-fast-forward.gif style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3> 其中一个分支没有新的改动，而另一个分支却有改动。这个时候进行整合的话，git仅仅只是添加所有改动的分支的新提交即可。</p> <p><img align=center alt=情况2 data-zoomable src=https://images.vrm.cn/2018/11/27/starting-situation-merge-commit.gif style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3> 第二种就是我们开发过程经常遇到的情况，两个分支都有不同的开发轨迹。为了完成合并，git会创建一个新的提交来涵括它们之间的差异，这就是整合提交。</p> <p>有人不喜欢这个合并的方式，希望项目有一个单一的开发轨迹，在流程上是一条直线，不希望在开发历史记录上看到被分成过多个分支。这时候就可以用到rebase操作了。</p> <p>我们还是看第一个例子：</p> <p><img align=center alt=情况1 data-zoomable src=https://images.vrm.cn/2018/11/27/starting-situation-fast-forward.gif style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3> 如果我们想合并分支B到A分支上，可以用到下面这个命令：</p> <pre><code class=language-bash><span class=hljs-attribute>git rebase branchB</span>
</code></pre> <p>git会进行这样的操作：<br>“撤销”所有分支A上与分支B开发分叉后的更改，这并不是真的checkout掉更改，后面还会用到。 <img align=center alt=rebase1 data-zoomable src=https://images.vrm.cn/2018/11/27/rebase-step-1.gif style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3></p> <p>然后它将整合分支B上的提交到A上，这要看，分支A和分支B就会像一条线一样。 <img align=center alt=rebase2 data-zoomable src=https://images.vrm.cn/2018/11/27/rebase-step-2.gif style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3></p> <p>最后，在分支A上的那些新的提交会被重新应用回来。 <img align=center alt=rebase3 data-zoomable src=https://images.vrm.cn/2018/11/27/rebase-step-3.gif style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3></p> <ol start=3> <li><code>git reset</code>和<code>git revert</code></li> </ol> <p>开发期间难免会有提交出错代码的情况，如何进行版本回退呢？git reset命令就派上用场了. </p> <ul> <li>git reset 为重置提交，可以将版本回退到某一个commit记录上。git reset 命令后面是需要加2种参数的：–-hard 和 –-soft。这条命令默认情况下是 -–soft。<br><strong>区别：</strong></li> </ul> <p>默认参数 -soft,所有commit的修改都会退回到git暂存区。 参数--hard，所有commit的修改直接丢弃，小心用。</p> <pre><code class=language-bash>git <span class=hljs-built_in>reset</span> --hard commit_id
git <span class=hljs-built_in>push</span> <span class=hljs-built_in>origin</span> [branchName] --force
</code></pre> <p>当然如果--hard错了，也还有救，<code>git reflog</code>命令记录你的所有git操作，能获取到原有的移除掉的commit_id。</p> <ul> <li>git revert 为还原提交，可以将某个commit还原然后创建一个新的还原commit。字面意思已经很好理解了。比如：</li> </ul> <pre><code class=language-bash><span class=hljs-comment># 某个commit的文件a增加两行文字</span>

<span class=hljs-attribute>git</span> revert commit_id

<span class=hljs-comment># 执行该命令后，还原了这个commit文件a的更改，新增一个revert的commit，更改为增加的两行文字被移除。</span>
</code></pre> <h3 id=git工作流>git工作流</h3> <p>这里只说下最广泛应用的git工作流，也就是git flow。<br>在开发的初期，我们定两个分支：</p> <ul> <li><strong>主分支master</strong></li> <li><strong>开发分支develop</strong></li> </ul> <p>规定，master分支为版本发布的分支，提供上线的版本。develop分支为日常开发分支，存放最新的开发版本。一般的develop分支会切出如下的三个短期分支：</p> <ol> <li>功能分支（feature）</li> <li>修bug分支（hotfix或者fix）</li> <li>预发布分支（release）</li> </ol> <p><strong>还有其它工作流？</strong></p> <p>当然有！下面就继续说一个挺不错的工作流： </p> <blockquote> <p>功能分支工作流 </p> </blockquote> <p>这个工作流的核心思路是所有的功能开发都应该独立一个分支，而主分支一样是master。这样的隔离开发不会扰乱主分支上的代码，也能保证主分支的代码准确无误。</p> <p>这种方式让pull request变得更加有效果。过多的就不解释，通过一个例子看看这个工作流到底是如何工作的。</p> <p><strong>小红开始开发一个新功能</strong><br>理所当然，从master切出一个独立功能分支：</p> <pre><code class=language-bash>git checkout -b <span class=hljs-built_in>feature</span>-<span class=hljs-built_in>new</span> master
</code></pre> <p>持续打码，中途完成部分:</p> <pre><code class=language-bash>git status
git <span class=hljs-built_in>add</span> [<span class=hljs-built_in>file</span>]
git commit -m <span class=hljs-string>'xxx'</span>
</code></pre> <p><strong>中午去吃个饭</strong><br>在吃午饭前，小红把自己的功能分支推到了远端仓库。好习惯，多学习。</p> <pre><code class=language-bash>git <span class=hljs-built_in>push</span> <span class=hljs-built_in>origin</span> <span class=hljs-built_in>feature</span>-<span class=hljs-built_in>new</span>
</code></pre> <p><strong>小红完成开发</strong> 在合并之前，小红保证远端仓库有自己功能分支的最新代码。</p> <pre><code class=language-bash>git <span class=hljs-built_in>push</span> <span class=hljs-built_in>origin</span> <span class=hljs-built_in>feature</span>-<span class=hljs-built_in>new</span>
</code></pre> <p>接下来，可以发起一个合并请求，在github或者gitlab都有快捷的合并请求操作。合并功能分支feature-new到master。发起后，团队都可以收到合并请求的通知。</p> <p>这时候团队可以code review，有问题就可以继续提示小红去修正。</p> <p>修正后小红可以持续推代码到功能分支，commit记录也会一并出现在pull request处。</p> <p><strong>小红发布功能</strong><br>经过紧张的讨论修改，终于完成功能开发，要发布功能：</p> <pre><code class=language-bash>git checkout master
git pull
git pull <span class=hljs-built_in>origin</span> <span class=hljs-built_in>feature</span>-<span class=hljs-built_in>new</span>
git <span class=hljs-built_in>push</span>
</code></pre> <p>完毕。</p> <h3 id=还能怎么发挥git作用？>还能怎么发挥git作用？</h3> <p><strong>webhooks</strong></p> <p>根据github的介绍，webhooks可以通过使用github的事件被触发时通过http post的形式调用服务器上的接口，服务器接受到推送事件之后就可以执行构建，更新项目代码，进而部署生产服务器等等。</p> <blockquote> <p>这一切能限制的只有你的想象力。</p> </blockquote> <p>一般而言，比如说我部署一个node程序到服务器上需要怎么操作？</p> <ol> <li><p>本地代码开发完毕，准备上线，上传本地代码到git远端仓库。</p> </li> <li><p>ssh连接远程服务器，登录管理员账号密码后进入命令行界面。</p> </li> <li><p>进入项目目录，拉取最新提交的代码。</p> </li> <li><p>执行部署操作。</p> </li> <li><p>需要代码更新，重复此操作。</p> </li> </ol> <p><strong>而我通过webhooks之后，这些操作得到很大的简化。</strong></p> <ol> <li>配置webhooks的push事件，因为我要在本地push代码后执行后续操作。</li> </ol> <p><img align=center alt=image data-zoomable src=https://user-images.githubusercontent.com/21136420/49086433-78755280-f28f-11e8-98ee-a1279e427c8e.png style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3></p> <ol start=2> <li>在服务器上编写一个自动部署脚本，这里举个简单的脚本<code>deploy.sh</code>。</li> </ol> <pre><code class=language-bash><span class=hljs-comment>#！/bin/bash</span>
<span class=hljs-built_in>echo</span> <span class=hljs-string>'enter project'</span>
<span class=hljs-built_in>cd</span> [your project dir]

<span class=hljs-built_in>echo</span> <span class=hljs-string>'pull code'</span>
git pull origin master

<span class=hljs-built_in>echo</span> <span class=hljs-string>'deploy'</span>
pm2 start deploy.js
pm2 logs deploy

<span class=hljs-built_in>echo</span> <span class=hljs-string>'deploy finished'</span>
</code></pre> <ol start=3> <li>用node写一个监听接口，不一定要node，只要能跑出个接口能监听到事件即可。需要提到：</li> </ol> <pre><code class=language-javascript><span class=hljs-keyword>const</span> createHandler = <span class=hljs-built_in>require</span>(<span class=hljs-string>'node-github-webhook'</span>)
<span class=hljs-keyword>const</span> config = {
  <span class=hljs-attr>path</span>: <span class=hljs-string>'/hook'</span>,
  <span class=hljs-attr>secret</span>: <span class=hljs-string>'your srcret'</span>
}
<span class=hljs-keyword>const</span> handler = createHandler(config)
...

handler.on(<span class=hljs-string>'push'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>event</span>) </span>{
  execFunc(<span class=hljs-string>'sh ./deploy.sh'</span>)
})
</code></pre> <p>这里的path和secret都需要在github webhooks那边对应配置上。</p> <ol start=4> <li>完成之后，一旦代码提交到master的话，就会触发事件，然后自动执行后续操作。</li> </ol> <h3 id=git工具推荐>git工具推荐</h3> <p>有几个个人认为不错的git工具或者项目可以提高git的使用。</p> <ol> <li><a href=https://github.com/github/gitignore target=_blank>gitignore</a>。在项目根目录新建一个<code>.gitignore</code>文件，将不需要提交到git上的文件路径添加到这个文件。在这个项目中可以快速找到自己所属项目的通用gitignore文件</li> </ol> <p><img align=center alt=gitignore data-zoomable src=https://images.vrm.cn/2018/11/27/微信截图_20181127222540.png style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3></p> <ol start=2> <li>[<code>VS Code</code>] gitignore。可以右键将文件夹或者文件添加到.gitignore文件中。</li> </ol> <p><img align=center alt=gitignore data-zoomable src=https://images.vrm.cn/2018/11/27/微信截图_20181127222733.png style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3></p> <ol start=3> <li>[<code>VS Code</code>] GitLens。可以让每一行代码都显示历史记录等。</li> </ol> <p><img align=center alt=Gitlens data-zoomable src=https://images.vrm.cn/2018/11/27/微信截图_20181127223043.png style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3></p> <ol start=4> <li>[<code>Chrome</code>] octotree。浏览github上的代码更加轻松便捷。</li> </ol> <p><img align=center alt=octotree data-zoomable src=https://images.vrm.cn/2018/11/27/微信截图_20181127223252.png style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3></p> <ol start=5> <li>Sourcetree。git图形界面工具，讲了那么多命令应该可以不用图形界面了吧😀。 <img align=center alt=sourcetree data-zoomable src=https://images.vrm.cn/2018/11/28/微信截图_20181128215137.png style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3></li> </ol> <h3 id=最后>最后</h3> <p>分享内容大概如此了，欢迎补充，也希望内容有些帮助。😄</p> <blockquote> <p>参考 <a href=https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/rebase target=_blank>Rebase 代替合并 </a> <a href=http://www.ruanyifeng.com/blog/2015/12/git-workflow.html target=_blank>git 工作流-阮老师的</a> <a href=https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md target=_blank>git 工作流</a></p> </blockquote> </div> <div class="svelte-1cnt1lz contact"><div>如果你对这页内容有疑问，欢迎联系我！</div> <a href="mailto:zhiyi.gong@outlook.com?subject=【重要】git在工作中的一些用处&body=gzhiyi.top/blog/2018_11_git-usage-in-work" target=_blank>邮箱 </a> <br> <a href=https://github.com/gzhiyi target=_blank>github </a> </div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"git在工作中的一些用处",description:"git内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。",keywords:"git,工作中,用处,git工作流,分支,git rebase,git merge",labels:["学习"],date:"2018-11-28",path:"2018\u002F11\u002Fgit-usage-in-work.md",slug:"2018_11_git-usage-in-work",html:"\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F26\u002Fbanner.png\" alt=\"banner\" \u003E\u003C\u002Fp\u003E\n\u003Cp\u003E本周四分享会主题：__git在工作中的一些用处__。  \u003C\u002Fp\u003E\n\u003Cp\u003Egit内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。\u003Cstrong\u003E基本的概念不会多说\u003C\u002Fstrong\u003E，都能在入门教程那些学习到。接下来会说下git在工作中比较常用的功能，会发现，其实git能做的事情还是非常多的。\u003C\u002Fp\u003E\n\u003Ch3 id=\"git在开发中常用的命令\"\u003Egit在开发中常用的命令\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cstrong\u003E编辑和代码提交\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-meta\"\u003E# 为git初始化一个代码库\u003C\u002Fspan\u003E\ngit init\n\n\u003Cspan class=\"hljs-meta\"\u003E# 将目录的所有文件提交到暂存区\u003C\u002Fspan\u003E\ngit add .\n\n\u003Cspan class=\"hljs-meta\"\u003E# 提交暂存区到代码仓库区，并添加提交信息\u003C\u002Fspan\u003E\ngit commit -m \u003Cspan class=\"hljs-string\"\u003E&quot;commit message&quot;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E分支处理\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\n\u003Cspan class=\"hljs-comment\"\u003E# 列出本地所有的分支\u003C\u002Fspan\u003E\ngit \u003Cspan class=\"hljs-keyword\"\u003Ebranch\n\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E# 列出远程仓库的所有分支\u003C\u002Fspan\u003E\ngit \u003Cspan class=\"hljs-keyword\"\u003Ebranch \u003C\u002Fspan\u003E-r\n\n\u003Cspan class=\"hljs-comment\"\u003E# 列出仓库的所有分支（包含远端和本地分支）\u003C\u002Fspan\u003E\ngit \u003Cspan class=\"hljs-keyword\"\u003Ebranch \u003C\u002Fspan\u003E-a\n\n\u003Cspan class=\"hljs-comment\"\u003E# 切换到指定分支，并更新工作区\u003C\u002Fspan\u003E\ngit checkout [\u003Cspan class=\"hljs-keyword\"\u003EbranchName]\n\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E# 新建一个分支并切换到该分支\u003C\u002Fspan\u003E\ngit checkout -\u003Cspan class=\"hljs-keyword\"\u003Eb \u003C\u002Fspan\u003E[\u003Cspan class=\"hljs-keyword\"\u003EbranchName]\n\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E# 删除一个分支\u003C\u002Fspan\u003E\ngit \u003Cspan class=\"hljs-keyword\"\u003Ebranch \u003C\u002Fspan\u003E-d [\u003Cspan class=\"hljs-keyword\"\u003EbranchName]\n\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E# 强制删除一个分支\u003C\u002Fspan\u003E\ngit \u003Cspan class=\"hljs-keyword\"\u003Ebranch \u003C\u002Fspan\u003E-D [\u003Cspan class=\"hljs-keyword\"\u003EbranchName]\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E查看状态信息\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-meta\"\u003E# 查看变更的文件，可多用这个命令查看当前文件改动状态\u003C\u002Fspan\u003E\ngit status\n\n\u003Cspan class=\"hljs-meta\"\u003E# 查看当前分支提交历史，可以得到加密的commit_id\u003C\u002Fspan\u003E\ngit log\n\n\u003Cspan class=\"hljs-meta\"\u003E# 查看暂存区和工作区的对比\u003C\u002Fspan\u003E\ngit diff\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E同步远程仓库\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-meta\"\u003E# 同步远程仓库的所有更新\u003C\u002Fspan\u003E\ngit fetch [remote]\n\n\u003Cspan class=\"hljs-meta\"\u003E# 显示所有远程仓库\u003C\u002Fspan\u003E\ngit remote -v\n\n\u003Cspan class=\"hljs-meta\"\u003E# 增加一个新的远程仓库，并定义一个远程仓库名，shortName常用origin，当然可自定义\u003C\u002Fspan\u003E\ngit remote add [shortName] url\n\n\u003Cspan class=\"hljs-meta\"\u003E# 拉取远端分支，并与本地分支合并\u003C\u002Fspan\u003E\ngit pull [remote] [branchName]\n\n\u003Cspan class=\"hljs-meta\"\u003E# 上传本地分支到远端\u003C\u002Fspan\u003E\ngit push [remote] [branchName]\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E撤销操作\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-meta\"\u003E# 恢复暂存区的指定文件到工作区\u003C\u002Fspan\u003E\ngit checkout [file]\n\n\u003Cspan class=\"hljs-meta\"\u003E# 恢复暂存区的所有文件到工作区\u003C\u002Fspan\u003E\ngit checkout .\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F49006081-37a00f80-f1a3-11e8-982e-c02cd71c1495.png\" alt=\"image\" \u003E\u003C\u002Fp\u003E\n\u003Cp\u003Egit工作中常用命令基本可以上图概括。\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E其它常用的命令\u003C\u002Fstrong\u003E\n单独拿出来说是因为平常知道用的可能不会很多，但实际用起来会非常有用。\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ccode\u003Egit stash\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E当你在工作的时候，累计了比较多的改动，但是突然间需要临时切换到其它分支工作，可是又不好把中途工作的内容提交，那怎么办？这时候git stash就有用了。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-meta\"\u003E# 查看文件变更状态\u003C\u002Fspan\u003E\ngit status\n\n\u003Cspan class=\"hljs-meta\"\u003E# 储藏变更，这时候会提示已储藏变更\u003C\u002Fspan\u003E\ngit stash\n\n\u003Cspan class=\"hljs-meta\"\u003E# 当在其它分支工作完回到原来分支的时候，可以查看储藏列表\u003C\u002Fspan\u003E\ngit stash list\n\n\u003Cspan class=\"hljs-meta\"\u003E# 恢复储藏，这时候文件变更就回来了，listNum为列表序号\u003C\u002Fspan\u003E\ngit stash apply stash@{listNum}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E\u003Ccode\u003Egit rebase\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E一般我们完成代码后，需要将分支的改动进行整合，会用到合并（merge）操作，但这不是唯一的方式，Rebase就是其中的代替方式。\u003Cbr\u003E先来说说merge。我们在需要合并的时候，会有如下的两种基本情况： \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Fstarting-situation-fast-forward.gif\" alt=\"情况1\" \u003E\n其中一个分支没有新的改动，而另一个分支却有改动。这个时候进行整合的话，git仅仅只是添加所有改动的分支的新提交即可。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Fstarting-situation-merge-commit.gif\" alt=\"情况2\" \u003E\n第二种就是我们开发过程经常遇到的情况，两个分支都有不同的开发轨迹。为了完成合并，git会创建一个新的提交来涵括它们之间的差异，这就是整合提交。\u003C\u002Fp\u003E\n\u003Cp\u003E有人不喜欢这个合并的方式，希望项目有一个单一的开发轨迹，在流程上是一条直线，不希望在开发历史记录上看到被分成过多个分支。这时候就可以用到rebase操作了。\u003C\u002Fp\u003E\n\u003Cp\u003E我们还是看第一个例子：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Fstarting-situation-fast-forward.gif\" alt=\"情况1\" \u003E\n如果我们想合并分支B到A分支上，可以用到下面这个命令：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-attribute\"\u003Egit rebase branchB\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003Egit会进行这样的操作：\u003Cbr\u003E“撤销”所有分支A上与分支B开发分叉后的更改，这并不是真的checkout掉更改，后面还会用到。\n\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Frebase-step-1.gif\" alt=\"rebase1\" \u003E\u003C\u002Fp\u003E\n\u003Cp\u003E然后它将整合分支B上的提交到A上，这要看，分支A和分支B就会像一条线一样。\n\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Frebase-step-2.gif\" alt=\"rebase2\" \u003E\u003C\u002Fp\u003E\n\u003Cp\u003E最后，在分支A上的那些新的提交会被重新应用回来。\n\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Frebase-step-3.gif\" alt=\"rebase3\" \u003E\u003C\u002Fp\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003E\u003Ccode\u003Egit reset\u003C\u002Fcode\u003E和\u003Ccode\u003Egit revert\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E开发期间难免会有提交出错代码的情况，如何进行版本回退呢？git reset命令就派上用场了.  \u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Egit reset 为重置提交，可以将版本回退到某一个commit记录上。git reset 命令后面是需要加2种参数的：–-hard 和 –-soft。这条命令默认情况下是 -–soft。\u003Cbr\u003E\u003Cstrong\u003E区别：\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E默认参数 -soft,所有commit的修改都会退回到git暂存区。\n参数--hard，所有commit的修改直接丢弃，小心用。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit \u003Cspan class=\"hljs-built_in\"\u003Ereset\u003C\u002Fspan\u003E --hard commit_id\ngit \u003Cspan class=\"hljs-built_in\"\u003Epush\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eorigin\u003C\u002Fspan\u003E [branchName] --force\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E当然如果--hard错了，也还有救，\u003Ccode\u003Egit reflog\u003C\u002Fcode\u003E命令记录你的所有git操作，能获取到原有的移除掉的commit_id。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Egit revert 为还原提交，可以将某个commit还原然后创建一个新的还原commit。字面意思已经很好理解了。比如：\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-comment\"\u003E# 某个commit的文件a增加两行文字\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-attribute\"\u003Egit\u003C\u002Fspan\u003E revert commit_id\n\n\u003Cspan class=\"hljs-comment\"\u003E# 执行该命令后，还原了这个commit文件a的更改，新增一个revert的commit，更改为增加的两行文字被移除。\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"git工作流\"\u003Egit工作流\u003C\u002Fh3\u003E\n\u003Cp\u003E这里只说下最广泛应用的git工作流，也就是git flow。\u003Cbr\u003E在开发的初期，我们定两个分支：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E主分支master\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E开发分支develop\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E规定，master分支为版本发布的分支，提供上线的版本。develop分支为日常开发分支，存放最新的开发版本。一般的develop分支会切出如下的三个短期分支：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E功能分支（feature）\u003C\u002Fli\u003E\n\u003Cli\u003E修bug分支（hotfix或者fix）\u003C\u002Fli\u003E\n\u003Cli\u003E预发布分支（release）\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cstrong\u003E还有其它工作流？\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E当然有！下面就继续说一个挺不错的工作流：  \u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E功能分支工作流  \u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E这个工作流的核心思路是所有的功能开发都应该独立一个分支，而主分支一样是master。这样的隔离开发不会扰乱主分支上的代码，也能保证主分支的代码准确无误。\u003C\u002Fp\u003E\n\u003Cp\u003E这种方式让pull request变得更加有效果。过多的就不解释，通过一个例子看看这个工作流到底是如何工作的。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E小红开始开发一个新功能\u003C\u002Fstrong\u003E\u003Cbr\u003E理所当然，从master切出一个独立功能分支：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit checkout -b \u003Cspan class=\"hljs-built_in\"\u003Efeature\u003C\u002Fspan\u003E-\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E master\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E持续打码，中途完成部分:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit status\ngit \u003Cspan class=\"hljs-built_in\"\u003Eadd\u003C\u002Fspan\u003E [\u003Cspan class=\"hljs-built_in\"\u003Efile\u003C\u002Fspan\u003E]\ngit commit -m \u003Cspan class=\"hljs-string\"\u003E&#x27;xxx&#x27;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E中午去吃个饭\u003C\u002Fstrong\u003E\u003Cbr\u003E在吃午饭前，小红把自己的功能分支推到了远端仓库。好习惯，多学习。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit \u003Cspan class=\"hljs-built_in\"\u003Epush\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eorigin\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Efeature\u003C\u002Fspan\u003E-\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E小红完成开发\u003C\u002Fstrong\u003E\n在合并之前，小红保证远端仓库有自己功能分支的最新代码。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit \u003Cspan class=\"hljs-built_in\"\u003Epush\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Eorigin\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Efeature\u003C\u002Fspan\u003E-\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E接下来，可以发起一个合并请求，在github或者gitlab都有快捷的合并请求操作。合并功能分支feature-new到master。发起后，团队都可以收到合并请求的通知。\u003C\u002Fp\u003E\n\u003Cp\u003E这时候团队可以code review，有问题就可以继续提示小红去修正。\u003C\u002Fp\u003E\n\u003Cp\u003E修正后小红可以持续推代码到功能分支，commit记录也会一并出现在pull request处。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E小红发布功能\u003C\u002Fstrong\u003E\u003Cbr\u003E经过紧张的讨论修改，终于完成功能开发，要发布功能：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit checkout master\ngit pull\ngit pull \u003Cspan class=\"hljs-built_in\"\u003Eorigin\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Efeature\u003C\u002Fspan\u003E-\u003Cspan class=\"hljs-built_in\"\u003Enew\u003C\u002Fspan\u003E\ngit \u003Cspan class=\"hljs-built_in\"\u003Epush\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E完毕。\u003C\u002Fp\u003E\n\u003Ch3 id=\"还能怎么发挥git作用？\"\u003E还能怎么发挥git作用？\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cstrong\u003Ewebhooks\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E根据github的介绍，webhooks可以通过使用github的事件被触发时通过http post的形式调用服务器上的接口，服务器接受到推送事件之后就可以执行构建，更新项目代码，进而部署生产服务器等等。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E这一切能限制的只有你的想象力。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E一般而言，比如说我部署一个node程序到服务器上需要怎么操作？\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E本地代码开发完毕，准备上线，上传本地代码到git远端仓库。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Essh连接远程服务器，登录管理员账号密码后进入命令行界面。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E进入项目目录，拉取最新提交的代码。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E执行部署操作。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E需要代码更新，重复此操作。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cstrong\u003E而我通过webhooks之后，这些操作得到很大的简化。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E配置webhooks的push事件，因为我要在本地push代码后执行后续操作。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F49086433-78755280-f28f-11e8-98ee-a1279e427c8e.png\" alt=\"image\" \u003E\u003C\u002Fp\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E在服务器上编写一个自动部署脚本，这里举个简单的脚本\u003Ccode\u003Edeploy.sh\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-comment\"\u003E#！\u002Fbin\u002Fbash\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-built_in\"\u003Eecho\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;enter project&#x27;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-built_in\"\u003Ecd\u003C\u002Fspan\u003E [your project dir]\n\n\u003Cspan class=\"hljs-built_in\"\u003Eecho\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;pull code&#x27;\u003C\u002Fspan\u003E\ngit pull origin master\n\n\u003Cspan class=\"hljs-built_in\"\u003Eecho\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;deploy&#x27;\u003C\u002Fspan\u003E\npm2 start deploy.js\npm2 logs deploy\n\n\u003Cspan class=\"hljs-built_in\"\u003Eecho\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;deploy finished&#x27;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003E用node写一个监听接口，不一定要node，只要能跑出个接口能监听到事件即可。需要提到：\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E createHandler = \u003Cspan class=\"hljs-built_in\"\u003Erequire\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E&#x27;node-github-webhook&#x27;\u003C\u002Fspan\u003E)\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E config = {\n  \u003Cspan class=\"hljs-attr\"\u003Epath\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;\u002Fhook&#x27;\u003C\u002Fspan\u003E,\n  \u003Cspan class=\"hljs-attr\"\u003Esecret\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;your srcret&#x27;\u003C\u002Fspan\u003E\n}\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E handler = createHandler(config)\n...\n\nhandler.on(\u003Cspan class=\"hljs-string\"\u003E&#x27;push&#x27;\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Eevent\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  execFunc(\u003Cspan class=\"hljs-string\"\u003E&#x27;sh .\u002Fdeploy.sh&#x27;\u003C\u002Fspan\u003E)\n})\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里的path和secret都需要在github webhooks那边对应配置上。\u003C\u002Fp\u003E\n\u003Col start=\"4\"\u003E\n\u003Cli\u003E完成之后，一旦代码提交到master的话，就会触发事件，然后自动执行后续操作。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"git工具推荐\"\u003Egit工具推荐\u003C\u002Fh3\u003E\n\u003Cp\u003E有几个个人认为不错的git工具或者项目可以提高git的使用。\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fgithub\u002Fgitignore\"\u003Egitignore\u003C\u002Fa\u003E。在项目根目录新建一个\u003Ccode\u003E.gitignore\u003C\u002Fcode\u003E文件，将不需要提交到git上的文件路径添加到这个文件。在这个项目中可以快速找到自己所属项目的通用gitignore文件\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127222540.png\" alt=\"gitignore\" \u003E\u003C\u002Fp\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E[\u003Ccode\u003EVS Code\u003C\u002Fcode\u003E] gitignore。可以右键将文件夹或者文件添加到.gitignore文件中。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127222733.png\" alt=\"gitignore\" \u003E\u003C\u002Fp\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003E[\u003Ccode\u003EVS Code\u003C\u002Fcode\u003E] GitLens。可以让每一行代码都显示历史记录等。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127223043.png\" alt=\"Gitlens\" \u003E\u003C\u002Fp\u003E\n\u003Col start=\"4\"\u003E\n\u003Cli\u003E[\u003Ccode\u003EChrome\u003C\u002Fcode\u003E] octotree。浏览github上的代码更加轻松便捷。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127223252.png\" alt=\"octotree\" \u003E\u003C\u002Fp\u003E\n\u003Col start=\"5\"\u003E\n\u003Cli\u003ESourcetree。git图形界面工具，讲了那么多命令应该可以不用图形界面了吧😀。\n\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F28\u002F微信截图_20181128215137.png\" alt=\"sourcetree\" \u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"最后\"\u003E最后\u003C\u002Fh3\u003E\n\u003Cp\u003E分享内容大概如此了，欢迎补充，也希望内容有些帮助。😄\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E参考\n\u003Ca target='_blank'  href=\"https:\u002F\u002Fwww.git-tower.com\u002Flearn\u002Fgit\u002Febook\u002Fcn\u002Fcommand-line\u002Fadvanced-topics\u002Frebase\"\u003ERebase 代替合并 \u003C\u002Fa\u003E\n\u003Ca target='_blank'  href=\"http:\u002F\u002Fwww.ruanyifeng.com\u002Fblog\u002F2015\u002F12\u002Fgit-workflow.html\"\u003Egit 工作流-阮老师的\u003C\u002Fa\u003E\n\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fxirong\u002Fmy-git\u002Fblob\u002Fmaster\u002Fgit-workflow-tutorial.md\"\u003Egit 工作流\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.796a17e3.js"}catch(e){main="/client/legacy/client.c6fed283.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 