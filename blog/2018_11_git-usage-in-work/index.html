<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=main.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <script src=//unpkg.com/valine/dist/Valine.min.js></script> <script src=https://unpkg.com/ajax-hook@2.0.3/dist/ajaxhook.min.js></script> <link href=client/main.1029972362.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>git在工作中的一些用处-GzhiYi's Blog</title><meta content=git内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。 name=description><meta content="git,工作中,用处,git工作流,分支,git rebase,git merge" name=keywords><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-1wr5yce><ul class=svelte-1wr5yce> <li class=svelte-1wr5yce><a href=/ aria-current=blog class=svelte-1wr5yce rel=prefetch>blog</a></ul></nav> <main class=svelte-iwmse4> <div class="svelte-mzxg2z content"><h1>git在工作中的一些用处</h1> <p class="svelte-mzxg2z desc">11/28/2018 <span class="svelte-mzxg2z label">学习</span></p> <p><img align=center alt=banner data-zoomable src=https://images.vrm.cn/2018/11/26/banner.png style=width:100%></p> <p>本周四分享会主题：<strong>git在工作中的一些用处</strong>。 </p> <p>git内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。<strong>基本的概念不会多说</strong>，都能在入门教程那些学习到。接下来会说下git在工作中比较常用的功能，会发现，其实git能做的事情还是非常多的。</p> <h3 id=git在开发中常用的命令>git在开发中常用的命令</h3> <p><strong>编辑和代码提交</strong></p> <pre><code class=language-bash><span class=hljs-comment># 为git初始化一个代码库</span>
git init

<span class=hljs-comment># 将目录的所有文件提交到暂存区</span>
git add .

<span class=hljs-comment># 提交暂存区到代码仓库区，并添加提交信息</span>
git commit -m <span class=hljs-string>"commit message"</span></code></pre> <p><strong>分支处理</strong></p> <pre><code class=language-bash>
<span class=hljs-comment># 列出本地所有的分支</span>
git branch

<span class=hljs-comment># 列出远程仓库的所有分支</span>
git branch -r

<span class=hljs-comment># 列出仓库的所有分支（包含远端和本地分支）</span>
git branch -a

<span class=hljs-comment># 切换到指定分支，并更新工作区</span>
git checkout [branchName]

<span class=hljs-comment># 新建一个分支并切换到该分支</span>
git checkout -b [branchName]

<span class=hljs-comment># 删除一个分支</span>
git branch -d [branchName]

<span class=hljs-comment># 强制删除一个分支</span>
git branch -D [branchName]</code></pre> <p><strong>查看状态信息</strong></p> <pre><code class=language-bash><span class=hljs-comment># 查看变更的文件，可多用这个命令查看当前文件改动状态</span>
git status

<span class=hljs-comment># 查看当前分支提交历史，可以得到加密的commit_id</span>
git <span class=hljs-built_in>log</span>

<span class=hljs-comment># 查看暂存区和工作区的对比</span>
git diff</code></pre> <p><strong>同步远程仓库</strong></p> <pre><code class=language-bash><span class=hljs-comment># 同步远程仓库的所有更新</span>
git fetch [remote]

<span class=hljs-comment># 显示所有远程仓库</span>
git remote -v

<span class=hljs-comment># 增加一个新的远程仓库，并定义一个远程仓库名，shortName常用origin，当然可自定义</span>
git remote add [shortName] url

<span class=hljs-comment># 拉取远端分支，并与本地分支合并</span>
git pull [remote] [branchName]

<span class=hljs-comment># 上传本地分支到远端</span>
git push [remote] [branchName]</code></pre> <p><strong>撤销操作</strong></p> <pre><code class=language-bash><span class=hljs-comment># 恢复暂存区的指定文件到工作区</span>
git checkout [file]

<span class=hljs-comment># 恢复暂存区的所有文件到工作区</span>
git checkout .
</code></pre> <p><img align=center alt=image data-zoomable src=https://user-images.githubusercontent.com/21136420/49006081-37a00f80-f1a3-11e8-982e-c02cd71c1495.png style=width:100%></p> <p>git工作中常用命令基本可以上图概括。</p> <hr> <p><strong>其它常用的命令</strong> 单独拿出来说是因为平常知道用的可能不会很多，但实际用起来会非常有用。</p> <ol> <li><code>git stash</code></li> </ol> <p>当你在工作的时候，累计了比较多的改动，但是突然间需要临时切换到其它分支工作，可是又不好把中途工作的内容提交，那怎么办？这时候git stash就有用了。</p> <pre><code class=language-bash><span class=hljs-comment># 查看文件变更状态</span>
git status

<span class=hljs-comment># 储藏变更，这时候会提示已储藏变更</span>
git stash

<span class=hljs-comment># 当在其它分支工作完回到原来分支的时候，可以查看储藏列表</span>
git stash list

<span class=hljs-comment># 恢复储藏，这时候文件变更就回来了，listNum为列表序号</span>
git stash apply stash@{listNum}</code></pre> <ol start=2> <li><code>git rebase</code></li> </ol> <p>一般我们完成代码后，需要将分支的改动进行整合，会用到合并（merge）操作，但这不是唯一的方式，Rebase就是其中的代替方式。<br>先来说说merge。我们在需要合并的时候，会有如下的两种基本情况： </p> <p><img align=center alt=情况1 data-zoomable src=https://images.vrm.cn/2018/11/27/starting-situation-fast-forward.gif style=width:100%> 其中一个分支没有新的改动，而另一个分支却有改动。这个时候进行整合的话，git仅仅只是添加所有改动的分支的新提交即可。</p> <p><img align=center alt=情况2 data-zoomable src=https://images.vrm.cn/2018/11/27/starting-situation-merge-commit.gif style=width:100%> 第二种就是我们开发过程经常遇到的情况，两个分支都有不同的开发轨迹。为了完成合并，git会创建一个新的提交来涵括它们之间的差异，这就是整合提交。</p> <p>有人不喜欢这个合并的方式，希望项目有一个单一的开发轨迹，在流程上是一条直线，不希望在开发历史记录上看到被分成过多个分支。这时候就可以用到rebase操作了。</p> <p>我们还是看第一个例子：</p> <p><img align=center alt=情况1 data-zoomable src=https://images.vrm.cn/2018/11/27/starting-situation-fast-forward.gif style=width:100%> 如果我们想合并分支B到A分支上，可以用到下面这个命令：</p> <pre><code class=language-bash>git rebase branchB</code></pre> <p>git会进行这样的操作：<br>“撤销”所有分支A上与分支B开发分叉后的更改，这并不是真的checkout掉更改，后面还会用到。 <img align=center alt=rebase1 data-zoomable src=https://images.vrm.cn/2018/11/27/rebase-step-1.gif style=width:100%></p> <p>然后它将整合分支B上的提交到A上，这要看，分支A和分支B就会像一条线一样。 <img align=center alt=rebase2 data-zoomable src=https://images.vrm.cn/2018/11/27/rebase-step-2.gif style=width:100%></p> <p>最后，在分支A上的那些新的提交会被重新应用回来。 <img align=center alt=rebase3 data-zoomable src=https://images.vrm.cn/2018/11/27/rebase-step-3.gif style=width:100%></p> <ol start=3> <li><code>git reset</code>和<code>git revert</code></li> </ol> <p>开发期间难免会有提交出错代码的情况，如何进行版本回退呢？git reset命令就派上用场了. </p> <ul> <li>git reset 为重置提交，可以将版本回退到某一个commit记录上。git reset 命令后面是需要加2种参数的：–-hard 和 –-soft。这条命令默认情况下是 -–soft。<br><strong>区别：</strong></li> </ul> <p>默认参数 -soft,所有commit的修改都会退回到git暂存区。 参数--hard，所有commit的修改直接丢弃，小心用。</p> <pre><code class=language-bash>git reset --hard commit_id
git push origin [branchName] --force</code></pre> <p>当然如果--hard错了，也还有救，<code>git reflog</code>命令记录你的所有git操作，能获取到原有的移除掉的commit_id。</p> <ul> <li>git revert 为还原提交，可以将某个commit还原然后创建一个新的还原commit。字面意思已经很好理解了。比如：</li> </ul> <pre><code class=language-bash><span class=hljs-comment># 某个commit的文件a增加两行文字</span>

git revert commit_id

<span class=hljs-comment># 执行该命令后，还原了这个commit文件a的更改，新增一个revert的commit，更改为增加的两行文字被移除。</span></code></pre> <h3 id=git工作流>git工作流</h3> <p>这里只说下最广泛应用的git工作流，也就是git flow。<br>在开发的初期，我们定两个分支：</p> <ul> <li><strong>主分支master</strong></li> <li><strong>开发分支develop</strong></li> </ul> <p>规定，master分支为版本发布的分支，提供上线的版本。develop分支为日常开发分支，存放最新的开发版本。一般的develop分支会切出如下的三个短期分支：</p> <ol> <li>功能分支（feature）</li> <li>修bug分支（hotfix或者fix）</li> <li>预发布分支（release）</li> </ol> <p><strong>还有其它工作流？</strong></p> <p>当然有！下面就继续说一个挺不错的工作流： </p> <blockquote> <p>功能分支工作流 </p> </blockquote> <p>这个工作流的核心思路是所有的功能开发都应该独立一个分支，而主分支一样是master。这样的隔离开发不会扰乱主分支上的代码，也能保证主分支的代码准确无误。</p> <p>这种方式让pull request变得更加有效果。过多的就不解释，通过一个例子看看这个工作流到底是如何工作的。</p> <p><strong>小红开始开发一个新功能</strong><br>理所当然，从master切出一个独立功能分支：</p> <pre><code class=language-bash>git checkout -b feature-new master</code></pre> <p>持续打码，中途完成部分:</p> <pre><code class=language-bash>git status
git add [file]
git commit -m <span class=hljs-string>'xxx'</span></code></pre> <p><strong>中午去吃个饭</strong><br>在吃午饭前，小红把自己的功能分支推到了远端仓库。好习惯，多学习。</p> <pre><code class=language-bash>git push origin feature-new</code></pre> <p><strong>小红完成开发</strong> 在合并之前，小红保证远端仓库有自己功能分支的最新代码。</p> <pre><code class=language-bash>git push origin feature-new</code></pre> <p>接下来，可以发起一个合并请求，在github或者gitlab都有快捷的合并请求操作。合并功能分支feature-new到master。发起后，团队都可以收到合并请求的通知。</p> <p>这时候团队可以code review，有问题就可以继续提示小红去修正。</p> <p>修正后小红可以持续推代码到功能分支，commit记录也会一并出现在pull request处。</p> <p><strong>小红发布功能</strong><br>经过紧张的讨论修改，终于完成功能开发，要发布功能：</p> <pre><code class=language-bash>git checkout master
git pull
git pull origin feature-new
git push</code></pre> <p>完毕。</p> <h3 id=还能怎么发挥git作用？>还能怎么发挥git作用？</h3> <p><strong>webhooks</strong></p> <p>根据github的介绍，webhooks可以通过使用github的事件被触发时通过http post的形式调用服务器上的接口，服务器接受到推送事件之后就可以执行构建，更新项目代码，进而部署生产服务器等等。</p> <blockquote> <p>这一切能限制的只有你的想象力。</p> </blockquote> <p>一般而言，比如说我部署一个node程序到服务器上需要怎么操作？</p> <ol> <li><p>本地代码开发完毕，准备上线，上传本地代码到git远端仓库。</p> </li> <li><p>ssh连接远程服务器，登录管理员账号密码后进入命令行界面。</p> </li> <li><p>进入项目目录，拉取最新提交的代码。</p> </li> <li><p>执行部署操作。</p> </li> <li><p>需要代码更新，重复此操作。</p> </li> </ol> <p><strong>而我通过webhooks之后，这些操作得到很大的简化。</strong></p> <ol> <li>配置webhooks的push事件，因为我要在本地push代码后执行后续操作。</li> </ol> <p><img align=center alt=image data-zoomable src=https://user-images.githubusercontent.com/21136420/49086433-78755280-f28f-11e8-98ee-a1279e427c8e.png style=width:100%></p> <ol start=2> <li>在服务器上编写一个自动部署脚本，这里举个简单的脚本<code>deploy.sh</code>。</li> </ol> <pre><code class=language-bash><span class=hljs-comment>#！/bin/bash</span>
<span class=hljs-built_in>echo</span> <span class=hljs-string>'enter project'</span>
<span class=hljs-built_in>cd</span> [your project dir]

<span class=hljs-built_in>echo</span> <span class=hljs-string>'pull code'</span>
git pull origin master

<span class=hljs-built_in>echo</span> <span class=hljs-string>'deploy'</span>
pm2 start deploy.js
pm2 logs deploy

<span class=hljs-built_in>echo</span> <span class=hljs-string>'deploy finished'</span></code></pre> <ol start=3> <li>用node写一个监听接口，不一定要node，只要能跑出个接口能监听到事件即可。需要提到：</li> </ol> <pre><code class=language-javascript><span class=hljs-keyword>const</span> createHandler = <span class=hljs-built_in>require</span>(<span class=hljs-string>'node-github-webhook'</span>)
<span class=hljs-keyword>const</span> config = {
  <span class=hljs-attr>path</span>: <span class=hljs-string>'/hook'</span>,
  <span class=hljs-attr>secret</span>: <span class=hljs-string>'your srcret'</span>
}
<span class=hljs-keyword>const</span> handler = createHandler(config)
...

handler.on(<span class=hljs-string>'push'</span>, <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>event</span>) </span>{
  execFunc(<span class=hljs-string>'sh ./deploy.sh'</span>)
})
</code></pre> <p>这里的path和secret都需要在github webhooks那边对应配置上。</p> <ol start=4> <li>完成之后，一旦代码提交到master的话，就会触发事件，然后自动执行后续操作。</li> </ol> <h3 id=git工具推荐>git工具推荐</h3> <p>有几个个人认为不错的git工具或者项目可以提高git的使用。</p> <ol> <li><a href=https://github.com/github/gitignore target=_blank>gitignore</a>。在项目根目录新建一个<code>.gitignore</code>文件，将不需要提交到git上的文件路径添加到这个文件。在这个项目中可以快速找到自己所属项目的通用gitignore文件</li> </ol> <p><img align=center alt=gitignore data-zoomable src=https://images.vrm.cn/2018/11/27/微信截图_20181127222540.png style=width:100%></p> <ol start=2> <li>[<code>VS Code</code>] gitignore。可以右键将文件夹或者文件添加到.gitignore文件中。</li> </ol> <p><img align=center alt=gitignore data-zoomable src=https://images.vrm.cn/2018/11/27/微信截图_20181127222733.png style=width:100%></p> <ol start=3> <li>[<code>VS Code</code>] GitLens。可以让每一行代码都显示历史记录等。</li> </ol> <p><img align=center alt=Gitlens data-zoomable src=https://images.vrm.cn/2018/11/27/微信截图_20181127223043.png style=width:100%></p> <ol start=4> <li>[<code>Chrome</code>] octotree。浏览github上的代码更加轻松便捷。</li> </ol> <p><img align=center alt=octotree data-zoomable src=https://images.vrm.cn/2018/11/27/微信截图_20181127223252.png style=width:100%></p> <ol start=5> <li>Sourcetree。git图形界面工具，讲了那么多命令应该可以不用图形界面了吧😀。 <img align=center alt=sourcetree data-zoomable src=https://images.vrm.cn/2018/11/28/微信截图_20181128215137.png style=width:100%></li> </ol> <h3 id=最后>最后</h3> <p>分享内容大概如此了，欢迎补充，也希望内容有些帮助。😄</p> <blockquote> <p>参考 <a href=https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/rebase target=_blank>Rebase 代替合并 </a> <a href=http://www.ruanyifeng.com/blog/2015/12/git-workflow.html target=_blank>git 工作流-阮老师的</a> <a href=https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md target=_blank>git 工作流</a></p> </blockquote> </div> <div class=my-8 id=vcomments></div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"2018\u002F11\u002Fgit-usage-in-work.md",path:"2018\u002F11\u002Fgit-usage-in-work",slug:"2018_11_git-usage-in-work",html:"\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F26\u002Fbanner.png\" alt=\"banner\" \u003E\u003C\u002Fp\u003E\n\u003Cp\u003E本周四分享会主题：\u003Cstrong\u003Egit在工作中的一些用处\u003C\u002Fstrong\u003E。  \u003C\u002Fp\u003E\n\u003Cp\u003Egit内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。\u003Cstrong\u003E基本的概念不会多说\u003C\u002Fstrong\u003E，都能在入门教程那些学习到。接下来会说下git在工作中比较常用的功能，会发现，其实git能做的事情还是非常多的。\u003C\u002Fp\u003E\n\u003Ch3 id=\"git在开发中常用的命令\"\u003Egit在开发中常用的命令\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cstrong\u003E编辑和代码提交\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-comment\"\u003E# 为git初始化一个代码库\u003C\u002Fspan\u003E\ngit init\n\n\u003Cspan class=\"hljs-comment\"\u003E# 将目录的所有文件提交到暂存区\u003C\u002Fspan\u003E\ngit add .\n\n\u003Cspan class=\"hljs-comment\"\u003E# 提交暂存区到代码仓库区，并添加提交信息\u003C\u002Fspan\u003E\ngit commit -m \u003Cspan class=\"hljs-string\"\u003E\"commit message\"\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E分支处理\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\n\u003Cspan class=\"hljs-comment\"\u003E# 列出本地所有的分支\u003C\u002Fspan\u003E\ngit branch\n\n\u003Cspan class=\"hljs-comment\"\u003E# 列出远程仓库的所有分支\u003C\u002Fspan\u003E\ngit branch -r\n\n\u003Cspan class=\"hljs-comment\"\u003E# 列出仓库的所有分支（包含远端和本地分支）\u003C\u002Fspan\u003E\ngit branch -a\n\n\u003Cspan class=\"hljs-comment\"\u003E# 切换到指定分支，并更新工作区\u003C\u002Fspan\u003E\ngit checkout [branchName]\n\n\u003Cspan class=\"hljs-comment\"\u003E# 新建一个分支并切换到该分支\u003C\u002Fspan\u003E\ngit checkout -b [branchName]\n\n\u003Cspan class=\"hljs-comment\"\u003E# 删除一个分支\u003C\u002Fspan\u003E\ngit branch -d [branchName]\n\n\u003Cspan class=\"hljs-comment\"\u003E# 强制删除一个分支\u003C\u002Fspan\u003E\ngit branch -D [branchName]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E查看状态信息\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-comment\"\u003E# 查看变更的文件，可多用这个命令查看当前文件改动状态\u003C\u002Fspan\u003E\ngit status\n\n\u003Cspan class=\"hljs-comment\"\u003E# 查看当前分支提交历史，可以得到加密的commit_id\u003C\u002Fspan\u003E\ngit \u003Cspan class=\"hljs-built_in\"\u003Elog\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-comment\"\u003E# 查看暂存区和工作区的对比\u003C\u002Fspan\u003E\ngit diff\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E同步远程仓库\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-comment\"\u003E# 同步远程仓库的所有更新\u003C\u002Fspan\u003E\ngit fetch [remote]\n\n\u003Cspan class=\"hljs-comment\"\u003E# 显示所有远程仓库\u003C\u002Fspan\u003E\ngit remote -v\n\n\u003Cspan class=\"hljs-comment\"\u003E# 增加一个新的远程仓库，并定义一个远程仓库名，shortName常用origin，当然可自定义\u003C\u002Fspan\u003E\ngit remote add [shortName] url\n\n\u003Cspan class=\"hljs-comment\"\u003E# 拉取远端分支，并与本地分支合并\u003C\u002Fspan\u003E\ngit pull [remote] [branchName]\n\n\u003Cspan class=\"hljs-comment\"\u003E# 上传本地分支到远端\u003C\u002Fspan\u003E\ngit push [remote] [branchName]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E撤销操作\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-comment\"\u003E# 恢复暂存区的指定文件到工作区\u003C\u002Fspan\u003E\ngit checkout [file]\n\n\u003Cspan class=\"hljs-comment\"\u003E# 恢复暂存区的所有文件到工作区\u003C\u002Fspan\u003E\ngit checkout .\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F49006081-37a00f80-f1a3-11e8-982e-c02cd71c1495.png\" alt=\"image\" \u003E\u003C\u002Fp\u003E\n\u003Cp\u003Egit工作中常用命令基本可以上图概括。\u003C\u002Fp\u003E\n\u003Chr\u003E\n\u003Cp\u003E\u003Cstrong\u003E其它常用的命令\u003C\u002Fstrong\u003E\n单独拿出来说是因为平常知道用的可能不会很多，但实际用起来会非常有用。\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ccode\u003Egit stash\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E当你在工作的时候，累计了比较多的改动，但是突然间需要临时切换到其它分支工作，可是又不好把中途工作的内容提交，那怎么办？这时候git stash就有用了。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-comment\"\u003E# 查看文件变更状态\u003C\u002Fspan\u003E\ngit status\n\n\u003Cspan class=\"hljs-comment\"\u003E# 储藏变更，这时候会提示已储藏变更\u003C\u002Fspan\u003E\ngit stash\n\n\u003Cspan class=\"hljs-comment\"\u003E# 当在其它分支工作完回到原来分支的时候，可以查看储藏列表\u003C\u002Fspan\u003E\ngit stash list\n\n\u003Cspan class=\"hljs-comment\"\u003E# 恢复储藏，这时候文件变更就回来了，listNum为列表序号\u003C\u002Fspan\u003E\ngit stash apply stash@{listNum}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E\u003Ccode\u003Egit rebase\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E一般我们完成代码后，需要将分支的改动进行整合，会用到合并（merge）操作，但这不是唯一的方式，Rebase就是其中的代替方式。\u003Cbr\u003E先来说说merge。我们在需要合并的时候，会有如下的两种基本情况： \u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Fstarting-situation-fast-forward.gif\" alt=\"情况1\" \u003E\n其中一个分支没有新的改动，而另一个分支却有改动。这个时候进行整合的话，git仅仅只是添加所有改动的分支的新提交即可。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Fstarting-situation-merge-commit.gif\" alt=\"情况2\" \u003E\n第二种就是我们开发过程经常遇到的情况，两个分支都有不同的开发轨迹。为了完成合并，git会创建一个新的提交来涵括它们之间的差异，这就是整合提交。\u003C\u002Fp\u003E\n\u003Cp\u003E有人不喜欢这个合并的方式，希望项目有一个单一的开发轨迹，在流程上是一条直线，不希望在开发历史记录上看到被分成过多个分支。这时候就可以用到rebase操作了。\u003C\u002Fp\u003E\n\u003Cp\u003E我们还是看第一个例子：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Fstarting-situation-fast-forward.gif\" alt=\"情况1\" \u003E\n如果我们想合并分支B到A分支上，可以用到下面这个命令：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit rebase branchB\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003Egit会进行这样的操作：\u003Cbr\u003E“撤销”所有分支A上与分支B开发分叉后的更改，这并不是真的checkout掉更改，后面还会用到。\n\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Frebase-step-1.gif\" alt=\"rebase1\" \u003E\u003C\u002Fp\u003E\n\u003Cp\u003E然后它将整合分支B上的提交到A上，这要看，分支A和分支B就会像一条线一样。\n\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Frebase-step-2.gif\" alt=\"rebase2\" \u003E\u003C\u002Fp\u003E\n\u003Cp\u003E最后，在分支A上的那些新的提交会被重新应用回来。\n\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Frebase-step-3.gif\" alt=\"rebase3\" \u003E\u003C\u002Fp\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003E\u003Ccode\u003Egit reset\u003C\u002Fcode\u003E和\u003Ccode\u003Egit revert\u003C\u002Fcode\u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E开发期间难免会有提交出错代码的情况，如何进行版本回退呢？git reset命令就派上用场了.  \u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Egit reset 为重置提交，可以将版本回退到某一个commit记录上。git reset 命令后面是需要加2种参数的：–-hard 和 –-soft。这条命令默认情况下是 -–soft。\u003Cbr\u003E\u003Cstrong\u003E区别：\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E默认参数 -soft,所有commit的修改都会退回到git暂存区。\n参数--hard，所有commit的修改直接丢弃，小心用。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit reset --hard commit_id\ngit push origin [branchName] --force\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E当然如果--hard错了，也还有救，\u003Ccode\u003Egit reflog\u003C\u002Fcode\u003E命令记录你的所有git操作，能获取到原有的移除掉的commit_id。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Egit revert 为还原提交，可以将某个commit还原然后创建一个新的还原commit。字面意思已经很好理解了。比如：\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-comment\"\u003E# 某个commit的文件a增加两行文字\u003C\u002Fspan\u003E\n\ngit revert commit_id\n\n\u003Cspan class=\"hljs-comment\"\u003E# 执行该命令后，还原了这个commit文件a的更改，新增一个revert的commit，更改为增加的两行文字被移除。\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"git工作流\"\u003Egit工作流\u003C\u002Fh3\u003E\n\u003Cp\u003E这里只说下最广泛应用的git工作流，也就是git flow。\u003Cbr\u003E在开发的初期，我们定两个分支：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cstrong\u003E主分支master\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cstrong\u003E开发分支develop\u003C\u002Fstrong\u003E\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E规定，master分支为版本发布的分支，提供上线的版本。develop分支为日常开发分支，存放最新的开发版本。一般的develop分支会切出如下的三个短期分支：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E功能分支（feature）\u003C\u002Fli\u003E\n\u003Cli\u003E修bug分支（hotfix或者fix）\u003C\u002Fli\u003E\n\u003Cli\u003E预发布分支（release）\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cstrong\u003E还有其它工作流？\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E当然有！下面就继续说一个挺不错的工作流：  \u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E功能分支工作流  \u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E这个工作流的核心思路是所有的功能开发都应该独立一个分支，而主分支一样是master。这样的隔离开发不会扰乱主分支上的代码，也能保证主分支的代码准确无误。\u003C\u002Fp\u003E\n\u003Cp\u003E这种方式让pull request变得更加有效果。过多的就不解释，通过一个例子看看这个工作流到底是如何工作的。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E小红开始开发一个新功能\u003C\u002Fstrong\u003E\u003Cbr\u003E理所当然，从master切出一个独立功能分支：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit checkout -b feature-new master\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E持续打码，中途完成部分:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit status\ngit add [file]\ngit commit -m \u003Cspan class=\"hljs-string\"\u003E'xxx'\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E中午去吃个饭\u003C\u002Fstrong\u003E\u003Cbr\u003E在吃午饭前，小红把自己的功能分支推到了远端仓库。好习惯，多学习。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit push origin feature-new\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E小红完成开发\u003C\u002Fstrong\u003E\n在合并之前，小红保证远端仓库有自己功能分支的最新代码。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit push origin feature-new\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E接下来，可以发起一个合并请求，在github或者gitlab都有快捷的合并请求操作。合并功能分支feature-new到master。发起后，团队都可以收到合并请求的通知。\u003C\u002Fp\u003E\n\u003Cp\u003E这时候团队可以code review，有问题就可以继续提示小红去修正。\u003C\u002Fp\u003E\n\u003Cp\u003E修正后小红可以持续推代码到功能分支，commit记录也会一并出现在pull request处。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E小红发布功能\u003C\u002Fstrong\u003E\u003Cbr\u003E经过紧张的讨论修改，终于完成功能开发，要发布功能：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit checkout master\ngit pull\ngit pull origin feature-new\ngit push\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E完毕。\u003C\u002Fp\u003E\n\u003Ch3 id=\"还能怎么发挥git作用？\"\u003E还能怎么发挥git作用？\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cstrong\u003Ewebhooks\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E根据github的介绍，webhooks可以通过使用github的事件被触发时通过http post的形式调用服务器上的接口，服务器接受到推送事件之后就可以执行构建，更新项目代码，进而部署生产服务器等等。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E这一切能限制的只有你的想象力。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E一般而言，比如说我部署一个node程序到服务器上需要怎么操作？\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E本地代码开发完毕，准备上线，上传本地代码到git远端仓库。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Essh连接远程服务器，登录管理员账号密码后进入命令行界面。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E进入项目目录，拉取最新提交的代码。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E执行部署操作。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E需要代码更新，重复此操作。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cstrong\u003E而我通过webhooks之后，这些操作得到很大的简化。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E配置webhooks的push事件，因为我要在本地push代码后执行后续操作。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F49086433-78755280-f28f-11e8-98ee-a1279e427c8e.png\" alt=\"image\" \u003E\u003C\u002Fp\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E在服务器上编写一个自动部署脚本，这里举个简单的脚本\u003Ccode\u003Edeploy.sh\u003C\u002Fcode\u003E。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"hljs-comment\"\u003E#！\u002Fbin\u002Fbash\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-built_in\"\u003Eecho\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E'enter project'\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-built_in\"\u003Ecd\u003C\u002Fspan\u003E [your project dir]\n\n\u003Cspan class=\"hljs-built_in\"\u003Eecho\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E'pull code'\u003C\u002Fspan\u003E\ngit pull origin master\n\n\u003Cspan class=\"hljs-built_in\"\u003Eecho\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E'deploy'\u003C\u002Fspan\u003E\npm2 start deploy.js\npm2 logs deploy\n\n\u003Cspan class=\"hljs-built_in\"\u003Eecho\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E'deploy finished'\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003E用node写一个监听接口，不一定要node，只要能跑出个接口能监听到事件即可。需要提到：\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E createHandler = \u003Cspan class=\"hljs-built_in\"\u003Erequire\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E'node-github-webhook'\u003C\u002Fspan\u003E)\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E config = {\n  \u003Cspan class=\"hljs-attr\"\u003Epath\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'\u002Fhook'\u003C\u002Fspan\u003E,\n  \u003Cspan class=\"hljs-attr\"\u003Esecret\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'your srcret'\u003C\u002Fspan\u003E\n}\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E handler = createHandler(config)\n...\n\nhandler.on(\u003Cspan class=\"hljs-string\"\u003E'push'\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Eevent\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  execFunc(\u003Cspan class=\"hljs-string\"\u003E'sh .\u002Fdeploy.sh'\u003C\u002Fspan\u003E)\n})\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这里的path和secret都需要在github webhooks那边对应配置上。\u003C\u002Fp\u003E\n\u003Col start=\"4\"\u003E\n\u003Cli\u003E完成之后，一旦代码提交到master的话，就会触发事件，然后自动执行后续操作。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"git工具推荐\"\u003Egit工具推荐\u003C\u002Fh3\u003E\n\u003Cp\u003E有几个个人认为不错的git工具或者项目可以提高git的使用。\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fgithub\u002Fgitignore\"\u003Egitignore\u003C\u002Fa\u003E。在项目根目录新建一个\u003Ccode\u003E.gitignore\u003C\u002Fcode\u003E文件，将不需要提交到git上的文件路径添加到这个文件。在这个项目中可以快速找到自己所属项目的通用gitignore文件\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127222540.png\" alt=\"gitignore\" \u003E\u003C\u002Fp\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E[\u003Ccode\u003EVS Code\u003C\u002Fcode\u003E] gitignore。可以右键将文件夹或者文件添加到.gitignore文件中。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127222733.png\" alt=\"gitignore\" \u003E\u003C\u002Fp\u003E\n\u003Col start=\"3\"\u003E\n\u003Cli\u003E[\u003Ccode\u003EVS Code\u003C\u002Fcode\u003E] GitLens。可以让每一行代码都显示历史记录等。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127223043.png\" alt=\"Gitlens\" \u003E\u003C\u002Fp\u003E\n\u003Col start=\"4\"\u003E\n\u003Cli\u003E[\u003Ccode\u003EChrome\u003C\u002Fcode\u003E] octotree。浏览github上的代码更加轻松便捷。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127223252.png\" alt=\"octotree\" \u003E\u003C\u002Fp\u003E\n\u003Col start=\"5\"\u003E\n\u003Cli\u003ESourcetree。git图形界面工具，讲了那么多命令应该可以不用图形界面了吧😀。\n\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F28\u002F微信截图_20181128215137.png\" alt=\"sourcetree\" \u003E\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"最后\"\u003E最后\u003C\u002Fh3\u003E\n\u003Cp\u003E分享内容大概如此了，欢迎补充，也希望内容有些帮助。😄\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E参考\n\u003Ca target='_blank'  href=\"https:\u002F\u002Fwww.git-tower.com\u002Flearn\u002Fgit\u002Febook\u002Fcn\u002Fcommand-line\u002Fadvanced-topics\u002Frebase\"\u003ERebase 代替合并 \u003C\u002Fa\u003E\n\u003Ca target='_blank'  href=\"http:\u002F\u002Fwww.ruanyifeng.com\u002Fblog\u002F2015\u002F12\u002Fgit-workflow.html\"\u003Egit 工作流-阮老师的\u003C\u002Fa\u003E\n\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fxirong\u002Fmy-git\u002Fblob\u002Fmaster\u002Fgit-workflow-tutorial.md\"\u003Egit 工作流\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n",fmData:{attributes:{title:"git在工作中的一些用处",description:"git内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。",keywords:"git,工作中,用处,git工作流,分支,git rebase,git merge",labels:["学习"],date:"2018-11-28T00:00:00.000Z"},body:"![banner](https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F26\u002Fbanner.png)\n\n本周四分享会主题：__git在工作中的一些用处__。  \n\ngit内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。**基本的概念不会多说**，都能在入门教程那些学习到。接下来会说下git在工作中比较常用的功能，会发现，其实git能做的事情还是非常多的。\n\n### git在开发中常用的命令\n__编辑和代码提交__\n\n```bash\n# 为git初始化一个代码库\ngit init\n\n# 将目录的所有文件提交到暂存区\ngit add .\n\n# 提交暂存区到代码仓库区，并添加提交信息\ngit commit -m \"commit message\"\n```\n\n__分支处理__\n\n```bash\n\n# 列出本地所有的分支\ngit branch\n\n# 列出远程仓库的所有分支\ngit branch -r\n\n# 列出仓库的所有分支（包含远端和本地分支）\ngit branch -a\n\n# 切换到指定分支，并更新工作区\ngit checkout [branchName]\n\n# 新建一个分支并切换到该分支\ngit checkout -b [branchName]\n\n# 删除一个分支\ngit branch -d [branchName]\n\n# 强制删除一个分支\ngit branch -D [branchName]\n```\n\n__查看状态信息__\n\n```bash\n# 查看变更的文件，可多用这个命令查看当前文件改动状态\ngit status\n\n# 查看当前分支提交历史，可以得到加密的commit_id\ngit log\n\n# 查看暂存区和工作区的对比\ngit diff\n```\n\n__同步远程仓库__\n\n```bash\n# 同步远程仓库的所有更新\ngit fetch [remote]\n\n# 显示所有远程仓库\ngit remote -v\n\n# 增加一个新的远程仓库，并定义一个远程仓库名，shortName常用origin，当然可自定义\ngit remote add [shortName] url\n\n# 拉取远端分支，并与本地分支合并\ngit pull [remote] [branchName]\n\n# 上传本地分支到远端\ngit push [remote] [branchName]\n```\n\n__撤销操作__\n\n```bash\n# 恢复暂存区的指定文件到工作区\ngit checkout [file]\n\n# 恢复暂存区的所有文件到工作区\ngit checkout .\n\n```\n\n![image](https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F49006081-37a00f80-f1a3-11e8-982e-c02cd71c1495.png)\n\ngit工作中常用命令基本可以上图概括。\n________\n\n__其它常用的命令__\n单独拿出来说是因为平常知道用的可能不会很多，但实际用起来会非常有用。\n\n1. `git stash`\n\n当你在工作的时候，累计了比较多的改动，但是突然间需要临时切换到其它分支工作，可是又不好把中途工作的内容提交，那怎么办？这时候git stash就有用了。\n\n```bash\n# 查看文件变更状态\ngit status\n\n# 储藏变更，这时候会提示已储藏变更\ngit stash\n\n# 当在其它分支工作完回到原来分支的时候，可以查看储藏列表\ngit stash list\n\n# 恢复储藏，这时候文件变更就回来了，listNum为列表序号\ngit stash apply stash@{listNum}\n```\n\n2. `git rebase`\n\n一般我们完成代码后，需要将分支的改动进行整合，会用到合并（merge）操作，但这不是唯一的方式，Rebase就是其中的代替方式。  \n先来说说merge。我们在需要合并的时候，会有如下的两种基本情况： \n\n![情况1](https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Fstarting-situation-fast-forward.gif)\n其中一个分支没有新的改动，而另一个分支却有改动。这个时候进行整合的话，git仅仅只是添加所有改动的分支的新提交即可。\n\n![情况2](https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Fstarting-situation-merge-commit.gif)\n第二种就是我们开发过程经常遇到的情况，两个分支都有不同的开发轨迹。为了完成合并，git会创建一个新的提交来涵括它们之间的差异，这就是整合提交。\n\n有人不喜欢这个合并的方式，希望项目有一个单一的开发轨迹，在流程上是一条直线，不希望在开发历史记录上看到被分成过多个分支。这时候就可以用到rebase操作了。\n\n我们还是看第一个例子：\n\n![情况1](https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Fstarting-situation-fast-forward.gif)\n如果我们想合并分支B到A分支上，可以用到下面这个命令：\n\n```bash\ngit rebase branchB\n```\n\ngit会进行这样的操作：  \n“撤销”所有分支A上与分支B开发分叉后的更改，这并不是真的checkout掉更改，后面还会用到。\n![rebase1](https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Frebase-step-1.gif)\n\n然后它将整合分支B上的提交到A上，这要看，分支A和分支B就会像一条线一样。\n![rebase2](https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Frebase-step-2.gif)\n\n最后，在分支A上的那些新的提交会被重新应用回来。\n![rebase3](https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002Frebase-step-3.gif)\n\n3. `git reset`和`git revert`\n\n开发期间难免会有提交出错代码的情况，如何进行版本回退呢？git reset命令就派上用场了.  \n- git reset 为重置提交，可以将版本回退到某一个commit记录上。git reset 命令后面是需要加2种参数的：–-hard 和 –-soft。这条命令默认情况下是 -–soft。  \n__区别：__\n\n默认参数 -soft,所有commit的修改都会退回到git暂存区。\n参数--hard，所有commit的修改直接丢弃，小心用。\n\n```bash\ngit reset --hard commit_id\ngit push origin [branchName] --force\n```\n当然如果--hard错了，也还有救，`git reflog`命令记录你的所有git操作，能获取到原有的移除掉的commit_id。\n\n- git revert 为还原提交，可以将某个commit还原然后创建一个新的还原commit。字面意思已经很好理解了。比如：\n\n```bash\n# 某个commit的文件a增加两行文字\n\ngit revert commit_id\n\n# 执行该命令后，还原了这个commit文件a的更改，新增一个revert的commit，更改为增加的两行文字被移除。\n```\n\n### git工作流\n\n这里只说下最广泛应用的git工作流，也就是git flow。  \n在开发的初期，我们定两个分支：\n\n- __主分支master__\n- __开发分支develop__\n\n规定，master分支为版本发布的分支，提供上线的版本。develop分支为日常开发分支，存放最新的开发版本。一般的develop分支会切出如下的三个短期分支：\n\n1. 功能分支（feature）\n2. 修bug分支（hotfix或者fix）\n3. 预发布分支（release）\n\n**还有其它工作流？**\n\n当然有！下面就继续说一个挺不错的工作流：  \n\n\u003E 功能分支工作流  \n\n这个工作流的核心思路是所有的功能开发都应该独立一个分支，而主分支一样是master。这样的隔离开发不会扰乱主分支上的代码，也能保证主分支的代码准确无误。\n\n这种方式让pull request变得更加有效果。过多的就不解释，通过一个例子看看这个工作流到底是如何工作的。\n\n__小红开始开发一个新功能__  \n理所当然，从master切出一个独立功能分支：\n\n```bash\ngit checkout -b feature-new master\n```\n\n持续打码，中途完成部分:\n\n```bash\ngit status\ngit add [file]\ngit commit -m 'xxx'\n```\n\n__中午去吃个饭__  \n在吃午饭前，小红把自己的功能分支推到了远端仓库。好习惯，多学习。\n\n```bash\ngit push origin feature-new\n```\n\n__小红完成开发__\n在合并之前，小红保证远端仓库有自己功能分支的最新代码。\n\n```bash\ngit push origin feature-new\n```\n\n接下来，可以发起一个合并请求，在github或者gitlab都有快捷的合并请求操作。合并功能分支feature-new到master。发起后，团队都可以收到合并请求的通知。\n\n这时候团队可以code review，有问题就可以继续提示小红去修正。\n\n修正后小红可以持续推代码到功能分支，commit记录也会一并出现在pull request处。\n\n__小红发布功能__  \n经过紧张的讨论修改，终于完成功能开发，要发布功能：\n\n```bash\ngit checkout master\ngit pull\ngit pull origin feature-new\ngit push\n```\n完毕。\n\n### 还能怎么发挥git作用？\n\n__webhooks__\n\n根据github的介绍，webhooks可以通过使用github的事件被触发时通过http post的形式调用服务器上的接口，服务器接受到推送事件之后就可以执行构建，更新项目代码，进而部署生产服务器等等。\n\n\u003E 这一切能限制的只有你的想象力。\n\n一般而言，比如说我部署一个node程序到服务器上需要怎么操作？\n\n1. 本地代码开发完毕，准备上线，上传本地代码到git远端仓库。\n\n2. ssh连接远程服务器，登录管理员账号密码后进入命令行界面。\n\n3. 进入项目目录，拉取最新提交的代码。\n\n4. 执行部署操作。\n\n5. 需要代码更新，重复此操作。\n\n__而我通过webhooks之后，这些操作得到很大的简化。__\n\n1. 配置webhooks的push事件，因为我要在本地push代码后执行后续操作。\n\n![image](https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F49086433-78755280-f28f-11e8-98ee-a1279e427c8e.png)\n\n2. 在服务器上编写一个自动部署脚本，这里举个简单的脚本`deploy.sh`。\n\n```bash\n#！\u002Fbin\u002Fbash\necho 'enter project'\ncd [your project dir]\n\necho 'pull code'\ngit pull origin master\n\necho 'deploy'\npm2 start deploy.js\npm2 logs deploy\n\necho 'deploy finished'\n```\n\n3. 用node写一个监听接口，不一定要node，只要能跑出个接口能监听到事件即可。需要提到：\n\n```javascript\nconst createHandler = require('node-github-webhook')\nconst config = {\n  path: '\u002Fhook',\n  secret: 'your srcret'\n}\nconst handler = createHandler(config)\n...\n\nhandler.on('push', function (event) {\n  execFunc('sh .\u002Fdeploy.sh')\n})\n\n```\n这里的path和secret都需要在github webhooks那边对应配置上。\n\n4. 完成之后，一旦代码提交到master的话，就会触发事件，然后自动执行后续操作。\n\n### git工具推荐\n\n有几个个人认为不错的git工具或者项目可以提高git的使用。\n\n1. [gitignore](https:\u002F\u002Fgithub.com\u002Fgithub\u002Fgitignore)。在项目根目录新建一个`.gitignore`文件，将不需要提交到git上的文件路径添加到这个文件。在这个项目中可以快速找到自己所属项目的通用gitignore文件\n\n![gitignore](https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127222540.png)\n\n2. [`VS Code`] gitignore。可以右键将文件夹或者文件添加到.gitignore文件中。\n\n![gitignore](https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127222733.png)\n\n3. [`VS Code`] GitLens。可以让每一行代码都显示历史记录等。\n\n![Gitlens](https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127223043.png)\n\n4. [`Chrome`] octotree。浏览github上的代码更加轻松便捷。\n\n![octotree](https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F27\u002F微信截图_20181127223252.png)\n\n5. Sourcetree。git图形界面工具，讲了那么多命令应该可以不用图形界面了吧😀。\n![sourcetree](https:\u002F\u002Fimages.vrm.cn\u002F2018\u002F11\u002F28\u002F微信截图_20181128215137.png)\n\n### 最后\n分享内容大概如此了，欢迎补充，也希望内容有些帮助。😄\n\n\u003E 参考\n\u003E [Rebase 代替合并 ](https:\u002F\u002Fwww.git-tower.com\u002Flearn\u002Fgit\u002Febook\u002Fcn\u002Fcommand-line\u002Fadvanced-topics\u002Frebase)\n\u003E [git 工作流-阮老师的](http:\u002F\u002Fwww.ruanyifeng.com\u002Fblog\u002F2015\u002F12\u002Fgit-workflow.html)\n\u003E [git 工作流](https:\u002F\u002Fgithub.com\u002Fxirong\u002Fmy-git\u002Fblob\u002Fmaster\u002Fgit-workflow-tutorial.md)",bodyBegin:9,frontmatter:"title: git在工作中的一些用处\ndescription: git内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。\nkeywords: git,工作中,用处,git工作流,分支,git rebase,git merge\nlabels: ['学习']\ndate: 2018-11-28"}}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.34d3e2bd.js"}catch(e){main="/client/legacy/client.9a4bf57e.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1" async></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 