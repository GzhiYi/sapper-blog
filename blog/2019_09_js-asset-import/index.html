<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=main.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <script src=//unpkg.com/valine/dist/Valine.min.js></script> <script src=https://unpkg.com/ajax-hook@2.0.3/dist/ajaxhook.min.js></script> <link href=client/main.1029972362.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>JS引入资源的一点总结-GzhiYi's Blog</title><meta content=很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。 name=description><meta content=javascript,script,阻塞渲染,defer,async,动态引入 name=keywords><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-1wr5yce><ul class=svelte-1wr5yce> <li class=svelte-1wr5yce><a aria-current=blog class=svelte-1wr5yce href=/ rel=prefetch>blog</a></ul></nav> <main class=svelte-iwmse4> <div class="svelte-mzxg2z content"><h1>JS引入资源的一点总结</h1> <p class="svelte-mzxg2z desc">9/28/2019 <span class="svelte-mzxg2z label">前端</span></p> <h2 id=js引入的时候放在哪比较好呢？>JS引入的时候放在哪比较好呢？</h2> <p>很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。</p> <h2 id=浏览器渲染>浏览器渲染</h2> <p>在知道放在哪最好之前，需要知道下浏览器渲染的过程。有以下的步骤：</p> <ul> <li>处理文档中的标签并构建DOM（Document Object Model）树。</li> <li>处理文档中的css并构建CSSOM（CSS Object Model）树。</li> <li>合并DOM和CSSOM为一个渲染树。</li> <li>处理渲染树没一个节点的布局。</li> <li>最后将没一个节点渲染（绘制）到浏览器上。</li> </ul> <h3 id=阻塞渲染：css和javascript>阻塞渲染：CSS和JavaScript</h3> <p>浏览器资源阻塞是一个常见的问题。要知道，资源在大多数浏览器上都是并行加载的，这种情况下，当Html文档被javascript阻塞时，Html文档会终止构建，但仍会<code>识别阻塞脚本后面的资源，进行预加载</code>。有以下要点需要注意：</p> <ul> <li>css加载不会阻塞dom树解析，但会阻塞dom树渲染。</li> <li>浏览器dom构建会在遇到script标签的时候暂停，直到script内的脚本执行完毕。</li> <li>CSSOM在构建的时候，JavaScript的执行会暂停，直到CSSOM准备就绪。</li> </ul> <p>以上正好说明了，我该把js脚本放在哪😄。我们就得出这样的原则以加快文档构建渲染：</p> <ol> <li>CSS优先渲染。将css放在JavaScript资源之上，也就是普遍的放在 &lt; head > 标签内。</li> <li>为减少script脚本对dom构建的影响，应该把script尽可能的放到最后（文档底部）。</li> </ol> <h2 id=defer和async>defer和async</h2> <p>script标签的这两个属性，均是为解决上面问题的。defer和async的使用有所不同。 <code>defer</code>：DOM元素的加载和脚本的 ** 加载 ** 异步执行。但是脚本的执行需要在所有dom元素解析完成之后，在<code>DOMContentLoaded</code>事件触发之前执行。 <code>async</code>：DOM元素的加载和脚本的加载 ** 以及执行 ** 异步执行。</p> <p><img align=center alt=284aec5bb7f16b3ef4e7482110c5ddbb_articlex data-zoomable src=https://user-images.githubusercontent.com/21136420/65817605-0ae1dc00-e23c-11e9-890b-e70207d371b6.jpeg style=width:100%></p> <ul> <li>无async和defer的时候，dom渲染被脚本<del>加载以及执行</del>所中断。</li> <li>defer的时候，dom渲染未被阻塞，但脚本执行将会到最后。这个特性可以对需求有所利用。</li> <li>async的时候，dom渲染和脚本加载和执行异步。</li> </ul> <h2 id=有时候要用到动态引入？>有时候要用到动态引入？</h2> <p> 统计脚本，广告脚本这类第三方嵌入脚本会在文档底部引入脚本文件。但都是以js生成script标签的形式进行动态引入。 先来看下百度统计脚本是怎么引入的：</p> <pre><code class=language-javascript>(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{
  <span class=hljs-keyword>var</span> hm = <span class=hljs-built_in>document</span>.createElement(<span class=hljs-string>"script"</span>);
  hm.src = <span class=hljs-string>"https://hm.baidu.com/hm.js?10dbf7bc9ad86276329db7b"</span>;
  <span class=hljs-keyword>var</span> s = <span class=hljs-built_in>document</span>.getElementsByTagName(<span class=hljs-string>"script"</span>)[<span class=hljs-number>0</span>];
  s.parentNode.insertBefore(hm, s);
})();</code></pre> <p>这就是动态创建script标签进行引入的方式。那么为什么要这样引入而不是直接:</p> <pre><code class=language-html><span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>src</span>=<span class=hljs-string>"source_url"</span> <span class=hljs-attr>async</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></code></pre> <p> ** 其实，这既不是自执行函数的问题，也不是阻塞渲染的问题。是为了防止用户把脚本放置在文档不规范的地方导致文档被阻塞，并不是所有的脚本嵌入用户都知道这个脚本应该嵌入在哪的。而这样动态引入就可以避免这样的问题。**</p> </div> <div class=my-8 id=vcomments></div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"2019\u002F09\u002Fjs-asset-import.md",path:"2019\u002F09\u002Fjs-asset-import",slug:"2019_09_js-asset-import",html:"\u003Ch2 id=\"js引入的时候放在哪比较好呢？\"\u003EJS引入的时候放在哪比较好呢？\u003C\u002Fh2\u003E\n\u003Cp\u003E很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。\u003C\u002Fp\u003E\n\u003Ch2 id=\"浏览器渲染\"\u003E浏览器渲染\u003C\u002Fh2\u003E\n\u003Cp\u003E在知道放在哪最好之前，需要知道下浏览器渲染的过程。有以下的步骤：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E处理文档中的标签并构建DOM（Document Object Model）树。\u003C\u002Fli\u003E\n\u003Cli\u003E处理文档中的css并构建CSSOM（CSS Object Model）树。\u003C\u002Fli\u003E\n\u003Cli\u003E合并DOM和CSSOM为一个渲染树。\u003C\u002Fli\u003E\n\u003Cli\u003E处理渲染树没一个节点的布局。\u003C\u002Fli\u003E\n\u003Cli\u003E最后将没一个节点渲染（绘制）到浏览器上。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 id=\"阻塞渲染：css和javascript\"\u003E阻塞渲染：CSS和JavaScript\u003C\u002Fh3\u003E\n\u003Cp\u003E浏览器资源阻塞是一个常见的问题。要知道，资源在大多数浏览器上都是并行加载的，这种情况下，当Html文档被javascript阻塞时，Html文档会终止构建，但仍会\u003Ccode\u003E识别阻塞脚本后面的资源，进行预加载\u003C\u002Fcode\u003E。有以下要点需要注意：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Ecss加载不会阻塞dom树解析，但会阻塞dom树渲染。\u003C\u002Fli\u003E\n\u003Cli\u003E浏览器dom构建会在遇到script标签的时候暂停，直到script内的脚本执行完毕。\u003C\u002Fli\u003E\n\u003Cli\u003ECSSOM在构建的时候，JavaScript的执行会暂停，直到CSSOM准备就绪。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E以上正好说明了，我该把js脚本放在哪😄。我们就得出这样的原则以加快文档构建渲染：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003ECSS优先渲染。将css放在JavaScript资源之上，也就是普遍的放在 &lt; head &gt; 标签内。\u003C\u002Fli\u003E\n\u003Cli\u003E为减少script脚本对dom构建的影响，应该把script尽可能的放到最后（文档底部）。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"defer和async\"\u003Edefer和async\u003C\u002Fh2\u003E\n\u003Cp\u003Escript标签的这两个属性，均是为解决上面问题的。defer和async的使用有所不同。\n\u003Ccode\u003Edefer\u003C\u002Fcode\u003E：DOM元素的加载和脚本的 ** 加载 ** 异步执行。但是脚本的执行需要在所有dom元素解析完成之后，在\u003Ccode\u003EDOMContentLoaded\u003C\u002Fcode\u003E事件触发之前执行。\n\u003Ccode\u003Easync\u003C\u002Fcode\u003E：DOM元素的加载和脚本的加载 ** 以及执行 ** 异步执行。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F65817605-0ae1dc00-e23c-11e9-890b-e70207d371b6.jpeg\" alt=\"284aec5bb7f16b3ef4e7482110c5ddbb_articlex\" \u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E无async和defer的时候，dom渲染被脚本\u003Cdel\u003E加载以及执行\u003C\u002Fdel\u003E所中断。\u003C\u002Fli\u003E\n\u003Cli\u003Edefer的时候，dom渲染未被阻塞，但脚本执行将会到最后。这个特性可以对需求有所利用。\u003C\u002Fli\u003E\n\u003Cli\u003Easync的时候，dom渲染和脚本加载和执行异步。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2 id=\"有时候要用到动态引入？\"\u003E有时候要用到动态引入？\u003C\u002Fh2\u003E\n\u003Cp\u003E  统计脚本，广告脚本这类第三方嵌入脚本会在文档底部引入脚本文件。但都是以js生成script标签的形式进行动态引入。\n  先来看下百度统计脚本是怎么引入的：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  \u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E hm = \u003Cspan class=\"hljs-built_in\"\u003Edocument\u003C\u002Fspan\u003E.createElement(\u003Cspan class=\"hljs-string\"\u003E\"script\"\u003C\u002Fspan\u003E);\n  hm.src = \u003Cspan class=\"hljs-string\"\u003E\"https:\u002F\u002Fhm.baidu.com\u002Fhm.js?10dbf7bc9ad86276329db7b\"\u003C\u002Fspan\u003E;\n  \u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E s = \u003Cspan class=\"hljs-built_in\"\u003Edocument\u003C\u002Fspan\u003E.getElementsByTagName(\u003Cspan class=\"hljs-string\"\u003E\"script\"\u003C\u002Fspan\u003E)[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E];\n  s.parentNode.insertBefore(hm, s);\n})();\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E这就是动态创建script标签进行引入的方式。那么为什么要这样引入而不是直接:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Esrc\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E\"source_url\"\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Easync\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E  ** 其实，这既不是自执行函数的问题，也不是阻塞渲染的问题。是为了防止用户把脚本放置在文档不规范的地方导致文档被阻塞，并不是所有的脚本嵌入用户都知道这个脚本应该嵌入在哪的。而这样动态引入就可以避免这样的问题。**\u003C\u002Fp\u003E\n",fmData:{attributes:{title:"JS引入资源的一点总结",description:"很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。",keywords:"javascript,script,阻塞渲染,defer,async,动态引入",labels:["前端"],date:"2019-09-28T00:00:00.000Z"},body:"## JS引入的时候放在哪比较好呢？\n\n很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。\n\n## 浏览器渲染\n\n在知道放在哪最好之前，需要知道下浏览器渲染的过程。有以下的步骤：\n\n- 处理文档中的标签并构建DOM（Document Object Model）树。\n- 处理文档中的css并构建CSSOM（CSS Object Model）树。\n- 合并DOM和CSSOM为一个渲染树。\n- 处理渲染树没一个节点的布局。\n- 最后将没一个节点渲染（绘制）到浏览器上。\n\n### 阻塞渲染：CSS和JavaScript\n\n浏览器资源阻塞是一个常见的问题。要知道，资源在大多数浏览器上都是并行加载的，这种情况下，当Html文档被javascript阻塞时，Html文档会终止构建，但仍会`识别阻塞脚本后面的资源，进行预加载`。有以下要点需要注意：\n\n- css加载不会阻塞dom树解析，但会阻塞dom树渲染。\n- 浏览器dom构建会在遇到script标签的时候暂停，直到script内的脚本执行完毕。\n- CSSOM在构建的时候，JavaScript的执行会暂停，直到CSSOM准备就绪。\n\n以上正好说明了，我该把js脚本放在哪😄。我们就得出这样的原则以加快文档构建渲染：\n\n1. CSS优先渲染。将css放在JavaScript资源之上，也就是普遍的放在 \u003C head \u003E 标签内。\n2. 为减少script脚本对dom构建的影响，应该把script尽可能的放到最后（文档底部）。\n\n## defer和async\n\nscript标签的这两个属性，均是为解决上面问题的。defer和async的使用有所不同。\n`defer`：DOM元素的加载和脚本的 ** 加载 ** 异步执行。但是脚本的执行需要在所有dom元素解析完成之后，在`DOMContentLoaded`事件触发之前执行。\n`async`：DOM元素的加载和脚本的加载 ** 以及执行 ** 异步执行。\n\n![284aec5bb7f16b3ef4e7482110c5ddbb_articlex](https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F65817605-0ae1dc00-e23c-11e9-890b-e70207d371b6.jpeg)\n\n  - 无async和defer的时候，dom渲染被脚本~~加载以及执行~~所中断。\n  - defer的时候，dom渲染未被阻塞，但脚本执行将会到最后。这个特性可以对需求有所利用。\n  - async的时候，dom渲染和脚本加载和执行异步。\n\n## 有时候要用到动态引入？\n\n  统计脚本，广告脚本这类第三方嵌入脚本会在文档底部引入脚本文件。但都是以js生成script标签的形式进行动态引入。\n  先来看下百度统计脚本是怎么引入的：\n  ```javascript\n(function() {\n    var hm = document.createElement(\"script\");\n    hm.src = \"https:\u002F\u002Fhm.baidu.com\u002Fhm.js?10dbf7bc9ad86276329db7b\";\n    var s = document.getElementsByTagName(\"script\")[0];\n    s.parentNode.insertBefore(hm, s);\n  })();\n```\n这就是动态创建script标签进行引入的方式。那么为什么要这样引入而不是直接:\n  ```html\n\u003Cscript src=\"source_url\" async\u003E\u003C\u002Fscript\u003E\n```\n  ** 其实，这既不是自执行函数的问题，也不是阻塞渲染的问题。是为了防止用户把脚本放置在文档不规范的地方导致文档被阻塞，并不是所有的脚本嵌入用户都知道这个脚本应该嵌入在哪的。而这样动态引入就可以避免这样的问题。**\n",bodyBegin:9,frontmatter:"title: JS引入资源的一点总结\ndescription: 很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。\nkeywords: javascript,script,阻塞渲染,defer,async,动态引入\nlabels: ['前端']\ndate: 2019-09-28"}}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.34d3e2bd.js"}catch(e){main="/client/legacy/client.9a4bf57e.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1" async></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 