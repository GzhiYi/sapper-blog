<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=main.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <script async src=//unpkg.com/valine/dist/Valine.min.js></script> <script async src=https://unpkg.com/ajax-hook@2.0.3/dist/ajaxhook.min.js></script> <link href=client/main.3202803961.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>博客评论更改为valine并增加评论推送-GzhiYi's blog</title><meta content=评论模块由gitalk转为valine，通过techulus的push进行评论推送 name=description><meta content="sapper,blog,techulus push,valine,comments" name=keywords><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-1wr5yce><ul class=svelte-1wr5yce> <li class=svelte-1wr5yce><a href=/ aria-current=blog class=svelte-1wr5yce rel=prefetch>blog</a></ul></nav> <main class=svelte-iwmse4> <div class="svelte-1hcu46h content"><h1>博客评论更改为valine并增加评论推送</h1> <p class="svelte-1hcu46h desc">6/29/2020 <span class="svelte-1hcu46h label">前端</span></p> <p>通过一点时间的使用，发现gitalk可以解决静态博客评论问题，是挺方便的，但综合考虑下，存在以下两个缺点：</p> <ol> <li>需要github账号登录。</li> <li>访问非常慢。</li> </ol> <p>有意间，发现一个评论插件很适合静态博客植入：<a href=https://valine.js.org/ >Valine</a>。</p> <p>新样式</p> <p><img align=center alt=style data-zoomable src=https://i.loli.net/2020/06/29/RiSBpcyAQD1kXCN.jpg style=width:100%></p> <p>新评论模块默认很清新，和我当前的样式较为符合，只做了一点点的样式覆盖。</p> <pre><code class=language-css><span class=hljs-comment>/* valine 样式覆盖 */</span>
<span class=hljs-selector-class>.v</span><span class=hljs-selector-attr>[data-class=v]</span> <span class=hljs-selector-class>.vwrap</span> {
    <span class=hljs-attribute>border</span>: <span class=hljs-number>1px</span> solid <span class=hljs-built_in>rgba</span>(<span class=hljs-number>255</span>, <span class=hljs-number>62</span>, <span class=hljs-number>0</span>, <span class=hljs-number>0.1</span>) <span class=hljs-meta>!important</span>;
}
<span class=hljs-selector-class>.v</span><span class=hljs-selector-attr>[data-class=v]</span> <span class=hljs-selector-class>.vwrap</span> <span class=hljs-selector-class>.vheader</span> <span class=hljs-selector-class>.vinput</span> {
    <span class=hljs-attribute>border-bottom</span>: none <span class=hljs-meta>!important</span>;
}
<span class=hljs-selector-class>.v</span><span class=hljs-selector-attr>[data-class=v]</span> <span class=hljs-selector-class>.txt-right</span> {
    <span class=hljs-attribute>display</span>: none <span class=hljs-meta>!important</span>;
}</code></pre> <h2 id=推送>推送</h2> <p>在valine的文档中，有提到可以用一个扩展的valine-admin以实现评论通知功能。我在leancloud尝试了发现比较麻烦。外加之前使用GitHub Actions用到了一个推送服务实现了在action成功之后推送部署成功的通知到手机上。那是不是可以通过下面的思路去实现评论推送呢？</p> <blockquote> <p><a href=https://push.techulus.com/ >PUSH注册</a>注册后使用免费的plan，可以每月100条推送限额。要推送到手机，只需要调用提供的接口还有下载一个手机APP就好了。</p> </blockquote> <p>要知道，做到推送到手机，只需要POST下面的接口：</p> <pre><code class=language-bash>https://push.techulus.com/api/v1/notify/{YOU API KEY}?title=Push by Techulus&body=This is your first push notification</code></pre> <ol> <li>在评论接口POST请求之后，在lean端通过类似拦截/触发的方法调用推送接口。</li> <li>在网页端拦截POST请求，在评论发出之后，在调用推送接口。</li> </ol> <p>在查看对应文档之后，第一种方式我找不到可行的入口。我想确定数据库入库的逻辑在哪处理的也找不到，所以采用第二种方法。</p> <h2 id=拦截评论请求>拦截评论请求</h2> <ol> <li>博客引入ajax-hook全局拦截请求</li> </ol> <pre><code class=language-html><span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>src</span>=<span class=hljs-string>"https://unpkg.com/ajax-hook@2.0.3/dist/ajaxhook.min.js"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></code></pre> <ol start=2> <li><p>在ajax-hook实例上，处理onRequest钩子。</p> <pre><code class=language-javascript>ah.proxy({
         <span class=hljs-comment>//请求发起前进入</span>
         <span class=hljs-attr>onRequest</span>: <span class=hljs-function>(<span class=hljs-params>config, handler</span>) =></span> {
             <span class=hljs-keyword>if</span> (config.url.includes(<span class=hljs-string>'classes/Comment'</span>) && config.method === <span class=hljs-string>'POST'</span>) {
                 <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'请求发起前'</span>, config.body)
                 fetch(
                     <span class=hljs-string>`https://push.techulus.com/api/v1/notify/<span class=hljs-subst>${YOU API KEY}</span>?title=<span class=hljs-subst>${location.pathname || <span class=hljs-string>'文章'</span>}</span>有新回复&body=<span class=hljs-subst>${config.body.substr(<span class=hljs-number>12</span>, <span class=hljs-number>30</span>)}</span>`</span>,
                     {
                         <span class=hljs-attr>method</span>: <span class=hljs-string>'POST'</span>,
                         <span class=hljs-attr>mode</span>: <span class=hljs-string>'cors'</span>,
                         <span class=hljs-attr>headers</span>: <span class=hljs-keyword>new</span> Headers({
                             <span class=hljs-string>'Content-Type'</span>: <span class=hljs-string>'application/json'</span>
                         })
                     }
                 )
             }
             handler.next(config);
         },
         <span class=hljs-comment>//请求发生错误时进入，比如超时；注意，不包括http状态码错误，如404仍然会认为请求成功</span>
         <span class=hljs-attr>onError</span>: <span class=hljs-function>(<span class=hljs-params>err, handler</span>) =></span> {
                 handler.next(err)
         },
         <span class=hljs-comment>//请求成功后进入</span>
         <span class=hljs-attr>onResponse</span>: <span class=hljs-function>(<span class=hljs-params>response, handler</span>) =></span> {
                 handler.next(response)
         }
     })</code></pre> <p>更多关于ajax-hook的文档，参阅：<a href=https://github.com/wendux/Ajax-hook>ajax-hook</a> </p> </li> </ol> <h2 id=缺点提示>缺点提示</h2> <p>第一种方式可以很好的保护推送的API KEY，因为有限额，暴露后可以随意调用。第二种比较简单易行。不过，反正push服务免费的话，也不会有损失。如果push服务付费就不要用第二种方法了。</p> <p>完成以上操作就可以收到评论推送啦，还是很方便的。如果有更好的免费push服务提供的，可以评论留言，我会很快看到的。</p> </div> <div class=my-8 id=vcomments></div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"2020-06\u002Fvaline-and-notifications.md",path:"2020-06\u002Fvaline-and-notifications",slug:"2020-06_valine-and-notifications",html:"\u003Cp\u003E通过一点时间的使用，发现gitalk可以解决静态博客评论问题，是挺方便的，但综合考虑下，存在以下两个缺点：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E需要github账号登录。\u003C\u002Fli\u003E\n\u003Cli\u003E访问非常慢。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E有意间，发现一个评论插件很适合静态博客植入：\u003Ca href=\"https:\u002F\u002Fvaline.js.org\u002F\"\u003EValine\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E新样式\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F29\u002FRiSBpcyAQD1kXCN.jpg\" alt=\"style\" \u003E\u003C\u002Fp\u003E\n\u003Cp\u003E新评论模块默认很清新，和我当前的样式较为符合，只做了一点点的样式覆盖。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-css\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F* valine 样式覆盖 *\u002F\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-selector-class\"\u003E.v\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-selector-attr\"\u003E[data-class=v]\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-class\"\u003E.vwrap\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-attribute\"\u003Eborder\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E1px\u003C\u002Fspan\u003E solid \u003Cspan class=\"hljs-built_in\"\u003Ergba\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-number\"\u003E255\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E62\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E0.1\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-meta\"\u003E!important\u003C\u002Fspan\u003E;\n}\n\u003Cspan class=\"hljs-selector-class\"\u003E.v\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-selector-attr\"\u003E[data-class=v]\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-class\"\u003E.vwrap\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-class\"\u003E.vheader\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-class\"\u003E.vinput\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-attribute\"\u003Eborder-bottom\u003C\u002Fspan\u003E: none \u003Cspan class=\"hljs-meta\"\u003E!important\u003C\u002Fspan\u003E;\n}\n\u003Cspan class=\"hljs-selector-class\"\u003E.v\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-selector-attr\"\u003E[data-class=v]\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-class\"\u003E.txt-right\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-attribute\"\u003Edisplay\u003C\u002Fspan\u003E: none \u003Cspan class=\"hljs-meta\"\u003E!important\u003C\u002Fspan\u003E;\n}\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"推送\"\u003E推送\u003C\u002Fh2\u003E\n\u003Cp\u003E在valine的文档中，有提到可以用一个扩展的valine-admin以实现评论通知功能。我在leancloud尝试了发现比较麻烦。外加之前使用GitHub Actions用到了一个推送服务实现了在action成功之后推送部署成功的通知到手机上。那是不是可以通过下面的思路去实现评论推送呢？\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fpush.techulus.com\u002F\"\u003EPUSH注册\u003C\u002Fa\u003E注册后使用免费的plan，可以每月100条推送限额。要推送到手机，只需要调用提供的接口还有下载一个手机APP就好了。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E要知道，做到推送到手机，只需要POST下面的接口：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Ehttps:\u002F\u002Fpush.techulus.com\u002Fapi\u002Fv1\u002Fnotify\u002F{YOU API KEY}?title=Push by Techulus&amp;body=This is your first push notification\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col\u003E\n\u003Cli\u003E在评论接口POST请求之后，在lean端通过类似拦截\u002F触发的方法调用推送接口。\u003C\u002Fli\u003E\n\u003Cli\u003E在网页端拦截POST请求，在评论发出之后，在调用推送接口。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E在查看对应文档之后，第一种方式我找不到可行的入口。我想确定数据库入库的逻辑在哪处理的也找不到，所以采用第二种方法。\u003C\u002Fp\u003E\n\u003Ch2 id=\"拦截评论请求\"\u003E拦截评论请求\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003E博客引入ajax-hook全局拦截请求\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Esrc\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E\"https:\u002F\u002Funpkg.com\u002Fajax-hook@2.0.3\u002Fdist\u002Fajaxhook.min.js\"\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E\u003Cp\u003E在ajax-hook实例上，处理onRequest钩子。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Eah.proxy({\n         \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F请求发起前进入\u003C\u002Fspan\u003E\n         \u003Cspan class=\"hljs-attr\"\u003EonRequest\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003Econfig, handler\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n             \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (config.url.includes(\u003Cspan class=\"hljs-string\"\u003E'classes\u002FComment'\u003C\u002Fspan\u003E) &amp;&amp; config.method === \u003Cspan class=\"hljs-string\"\u003E'POST'\u003C\u002Fspan\u003E) {\n                 \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\u003Cspan class=\"hljs-string\"\u003E'请求发起前'\u003C\u002Fspan\u003E, config.body)\n                 fetch(\n                     \u003Cspan class=\"hljs-string\"\u003E`https:\u002F\u002Fpush.techulus.com\u002Fapi\u002Fv1\u002Fnotify\u002F\u003Cspan class=\"hljs-subst\"\u003E${YOU API KEY}\u003C\u002Fspan\u003E?title=\u003Cspan class=\"hljs-subst\"\u003E${location.pathname || \u003Cspan class=\"hljs-string\"\u003E'文章'\u003C\u002Fspan\u003E}\u003C\u002Fspan\u003E有新回复&amp;body=\u003Cspan class=\"hljs-subst\"\u003E${config.body.substr(\u003Cspan class=\"hljs-number\"\u003E12\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E30\u003C\u002Fspan\u003E)}\u003C\u002Fspan\u003E`\u003C\u002Fspan\u003E,\n                     {\n                         \u003Cspan class=\"hljs-attr\"\u003Emethod\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'POST'\u003C\u002Fspan\u003E,\n                         \u003Cspan class=\"hljs-attr\"\u003Emode\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'cors'\u003C\u002Fspan\u003E,\n                         \u003Cspan class=\"hljs-attr\"\u003Eheaders\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Headers({\n                             \u003Cspan class=\"hljs-string\"\u003E'Content-Type'\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'application\u002Fjson'\u003C\u002Fspan\u003E\n                         })\n                     }\n                 )\n             }\n             handler.next(config);\n         },\n         \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F请求发生错误时进入，比如超时；注意，不包括http状态码错误，如404仍然会认为请求成功\u003C\u002Fspan\u003E\n         \u003Cspan class=\"hljs-attr\"\u003EonError\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003Eerr, handler\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n                 handler.next(err)\n         },\n         \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F请求成功后进入\u003C\u002Fspan\u003E\n         \u003Cspan class=\"hljs-attr\"\u003EonResponse\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003Eresponse, handler\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n                 handler.next(response)\n         }\n     })\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E更多关于ajax-hook的文档，参阅：\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fwendux\u002FAjax-hook\"\u003Eajax-hook\u003C\u002Fa\u003E    \u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"缺点提示\"\u003E缺点提示\u003C\u002Fh2\u003E\n\u003Cp\u003E第一种方式可以很好的保护推送的API KEY，因为有限额，暴露后可以随意调用。第二种比较简单易行。不过，反正push服务免费的话，也不会有损失。如果push服务付费就不要用第二种方法了。\u003C\u002Fp\u003E\n\u003Cp\u003E完成以上操作就可以收到评论推送啦，还是很方便的。如果有更好的免费push服务提供的，可以评论留言，我会很快看到的。\u003C\u002Fp\u003E\n",fmData:{attributes:{title:"博客评论更改为valine并增加评论推送",description:"评论模块由gitalk转为valine，通过techulus的push进行评论推送",keywords:"sapper,blog,techulus push,valine,comments",labels:["前端"],date:"2020-06-29T00:00:00.000Z"},body:"通过一点时间的使用，发现gitalk可以解决静态博客评论问题，是挺方便的，但综合考虑下，存在以下两个缺点：\n\n1. 需要github账号登录。\n2. 访问非常慢。\n\n有意间，发现一个评论插件很适合静态博客植入：[Valine](https:\u002F\u002Fvaline.js.org\u002F)。\n\n新样式\n\n![style](https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F29\u002FRiSBpcyAQD1kXCN.jpg)\n\n新评论模块默认很清新，和我当前的样式较为符合，只做了一点点的样式覆盖。\n\n```css\n\u002F* valine 样式覆盖 *\u002F\n.v[data-class=v] .vwrap {\n\tborder: 1px solid rgba(255, 62, 0, 0.1) !important;\n}\n.v[data-class=v] .vwrap .vheader .vinput {\n\tborder-bottom: none !important;\n}\n.v[data-class=v] .txt-right {\n\tdisplay: none !important;\n}\n```\n\n## 推送\n\n在valine的文档中，有提到可以用一个扩展的valine-admin以实现评论通知功能。我在leancloud尝试了发现比较麻烦。外加之前使用GitHub Actions用到了一个推送服务实现了在action成功之后推送部署成功的通知到手机上。那是不是可以通过下面的思路去实现评论推送呢？\n\n\u003E [PUSH注册](https:\u002F\u002Fpush.techulus.com\u002F)注册后使用免费的plan，可以每月100条推送限额。要推送到手机，只需要调用提供的接口还有下载一个手机APP就好了。\n\n要知道，做到推送到手机，只需要POST下面的接口：\n\n```bash\nhttps:\u002F\u002Fpush.techulus.com\u002Fapi\u002Fv1\u002Fnotify\u002F{YOU API KEY}?title=Push by Techulus&body=This is your first push notification\n```\n\n\n\n1. 在评论接口POST请求之后，在lean端通过类似拦截\u002F触发的方法调用推送接口。\n2. 在网页端拦截POST请求，在评论发出之后，在调用推送接口。\n\n在查看对应文档之后，第一种方式我找不到可行的入口。我想确定数据库入库的逻辑在哪处理的也找不到，所以采用第二种方法。\n\n## 拦截评论请求\n\n1. 博客引入ajax-hook全局拦截请求\n\n```html\n\u003Cscript src=\"https:\u002F\u002Funpkg.com\u002Fajax-hook@2.0.3\u002Fdist\u002Fajaxhook.min.js\"\u003E\u003C\u002Fscript\u003E\n```\n\n2. 在ajax-hook实例上，处理onRequest钩子。\n\n   ```javascript\n   ah.proxy({\n\t\t\t\u002F\u002F请求发起前进入\n\t\t\tonRequest: (config, handler) =\u003E {\n\t\t\t\tif (config.url.includes('classes\u002FComment') && config.method === 'POST') {\n\t\t\t\t\tconsole.log('请求发起前', config.body)\n\t\t\t\t\tfetch(\n\t\t\t\t\t\t`https:\u002F\u002Fpush.techulus.com\u002Fapi\u002Fv1\u002Fnotify\u002F${YOU API KEY}?title=${location.pathname || '文章'}有新回复&body=${config.body.substr(12, 30)}`,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tmode: 'cors',\n\t\t\t\t\t\t\theaders: new Headers({\n\t\t\t\t\t\t\t\t'Content-Type': 'application\u002Fjson'\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\thandler.next(config);\n\t\t\t},\n\t\t\t\u002F\u002F请求发生错误时进入，比如超时；注意，不包括http状态码错误，如404仍然会认为请求成功\n\t\t\tonError: (err, handler) =\u003E {\n\t\t\t\t\thandler.next(err)\n\t\t\t},\n\t\t\t\u002F\u002F请求成功后进入\n\t\t\tonResponse: (response, handler) =\u003E {\n\t\t\t\t\thandler.next(response)\n\t\t\t}\n\t\t})\n   ```\n\n   更多关于ajax-hook的文档，参阅：[ajax-hook](https:\u002F\u002Fgithub.com\u002Fwendux\u002FAjax-hook)\t\n\n## 缺点提示\n\n第一种方式可以很好的保护推送的API KEY，因为有限额，暴露后可以随意调用。第二种比较简单易行。不过，反正push服务免费的话，也不会有损失。如果push服务付费就不要用第二种方法了。\n\n完成以上操作就可以收到评论推送啦，还是很方便的。如果有更好的免费push服务提供的，可以评论留言，我会很快看到的。",bodyBegin:9,frontmatter:"title: 博客评论更改为valine并增加评论推送\ndescription: 评论模块由gitalk转为valine，通过techulus的push进行评论推送\nkeywords: sapper,blog,techulus push,valine,comments\nlabels: ['前端']\ndate: 2020-06-29"}}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.19b6d283.js"}catch(e){main="/client/legacy/client.4e6474e3.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 