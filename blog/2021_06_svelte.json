{"title":"svelte语法点小记","description":"svelte和vue、react不同，在构建页面的时候语法需要和其余框架区别开，记录官方文档有助于理解使用。","keywords":"svelte, vue, react, 文档","labels":["前端","svelte"],"date":"2021-06-24","path":"2021/06/svelte.md","slug":"2021_06_svelte","html":"<p>计划重写原本由sapper编写的博客，需要移除sapper，只用svelte和一般的构建即可。在此之前，需要花点时间学习（回顾）一下svelte的一下语法点，会和vue进行对比，暂不深入理解内部原理，单纯建立在官方文档的基础上。</p>\n<p>记录并不是所有细节都要兼顾。遇到和vue理念比较大，或者说这个语法并没有让我那么容易记住的知识点，我都会记录下来，并在后续闲暇的时间下进行回顾复习，有点类似于做一下错题本。</p>\n<ol>\n<li><p>变量和代码块都只需要放在一个花括号里面就好了。在vue里面是<code>{{}}</code>包裹，有点不同。不要有带入vue语法的惯性思维。</p>\n</li>\n<li><p>和vue类似，一个<code>.svelte</code>文件就是一个组件，包含了script、html、还有css。可以在另一个svelte组件中引入svelte组件。</p>\n</li>\n<li><p>{@html 字符串}，包裹的字符串会被转化为不信任来源的html代码，注意防止xss攻击。</p>\n</li>\n<li><p>当组件中的变量更新的时候，svelte会自动更新对应的dom。类似于vue中的计算属性，svelte是这么处理的：</p>\n<pre><code class=\"language-javascript\">const <span class=\"hljs-attr\">varable</span> = <span class=\"hljs-number\">0</span>\n$: <span class=\"hljs-attr\">varableName</span> = varable + <span class=\"hljs-number\">1</span>\n</code></pre>\n<p>其中<code>$:</code>就是可以标识变量为“计算属性”，其中varable变化的话，对应的varableName也会跟着变化。</p>\n<p><code>$:</code>不仅仅是标识变量为计算属性，还可以是一串代码块，在该代码块中的变量一旦发生变化，就会执行这个代码块，而如果没有变量变化，这一个代码块就不会执行。所以把这个符号理解为响应式定义符更好，官网提到的名词就叫响应式声明。</p>\n</li>\n<li><p>对于一般变量，直接赋值就可以产生响应式的效果，但如果是对象类型就不可以，比如数组的push等操作，就不会更新dom。svelte的解决方式有</p>\n<ol>\n<li><p>在数组操作之后，将结果数组赋值给原数组。</p>\n<pre><code class=\"language-js\">let num = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addNum</span></span>(<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">Num</span>) {\n  num.push(<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">Num</span>)\n}\n<span class=\"hljs-comment\">// 直接在html上调用这个addNum函数，是不会对num进行更新的，需要改为</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addNum</span></span>(<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">Num</span>) {\n  num.push(<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">Num</span>)\n  num = num\n}\n<span class=\"hljs-comment\">// 抑或者</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addNum</span></span>(<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">Num</span>) {\n  num = [...num, <span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">Num</span>]\n}\n</code></pre>\n</li>\n<li><p>对于对象属性的更新，可以直接赋值。</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> obj = {\n <span class=\"hljs-built_in\"> name</span>: <span class=\"hljs-string\">&#x27;cat&#x27;</span>\n}\n// 可以直接更新obj上<span class=\"hljs-built_in\">的name</span>属性\n<span class=\"hljs-keyword\">function</span> changeName(newName) {\n  obj<span class=\"hljs-built_in\">.name</span> = newName\n}\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<p>6.组件参数传递。和vue不一样，vue在一个组件中对传入参数是直接在props上进行声明的。而svelte是直接在组件内export参数。</p>\n<pre><code class=\"language-vue\">// 组件displayName.svelte\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&quot;name参数的默认值&quot;</span> <span class=\"hljs-comment\">// 这里就直接表示组件a具有一个name的参数，外部可以传递进来</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n// 组件b.svelte\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> DisplayName <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./displayName.svelte&#x27;</span>\n    <span class=\"hljs-keyword\">let</span> myName = <span class=\"hljs-string\">&#x27;cat&#x27;</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">DisplayName</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">{myName}</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">DisplayName</span>&gt;</span>\n\n</code></pre>\n<ol start=\"7\">\n<li><p>if块。初次感受肯定是没有vue方便快捷，但写多几遍之后，发现还是可以接受这样的一个语法糖。注意#号不能遗漏掉。</p>\n<pre><code class=\"language-vue\">{<span class=\"hljs-comment\">#if isTrue}</span>\n    <span class=\"hljs-regexp\">//</span> 执行为isTrue的html\n{:<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> 条件} <span class=\"hljs-regexp\">//</span> 这个是额外可能出现的条件\n{:<span class=\"hljs-keyword\">else</span>}\n    <span class=\"hljs-regexp\">//</span> 执行isTrue为false的html\n{/<span class=\"hljs-keyword\">if</span>}\n</code></pre>\n</li>\n<li><p>循环块。类比vue中的v-for。其中（）内的数值表示为id，可以有效更新dom。</p>\n<pre><code class=\"language-vue\"><span class=\"xml\">let arr = [\n    </span><span class=\"hljs-template-variable\">{\n        id: 1,\n        name: &#x27;cat&#x27;\n    }</span><span class=\"xml\">,\n    </span><span class=\"hljs-template-variable\">{\n        id: 2,\n        name: &#x27;dog&#x27;\n    }</span><span class=\"xml\">\n]\n</span><span class=\"hljs-template-tag\">{#<span class=\"hljs-name\">each</span> arr as item, index(item.id)}</span><span class=\"xml\">\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"hljs-template-variable\">{index}</span><span class=\"xml\">: </span><span class=\"hljs-template-variable\">{item.name}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</span><span class=\"hljs-template-tag\">{/<span class=\"hljs-name\">each</span>}</span><span class=\"xml\">\n// 用上解构，会更加简洁明了\n</span><span class=\"hljs-template-tag\">{#<span class=\"hljs-name\">each</span> arr as {id, name}</span><span class=\"xml\">, index(id)}\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"hljs-template-variable\">{index}</span><span class=\"xml\">: </span><span class=\"hljs-template-variable\">{id}</span><span class=\"xml\"> </span><span class=\"hljs-template-variable\">{name}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n</code></pre>\n</li>\n<li><p>await块。没想到真的有这个东西，可以直接拿来判断一个promise在多个状态下的表现，这可以说不用写那一堆loading了，大致的代码如下：</p>\n<pre><code class=\"language-vue\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">let</span> promise = getDataFromUrl()\n  <span class=\"hljs-keyword\">async</span> getDataFromUrl() </span></span><span class=\"hljs-template-variable\">{}</span><span class=\"xml\">\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n// 直接拿promise就像是一个promise一样在html中await\n</span><span class=\"hljs-template-tag\">{#<span class=\"hljs-name\">await</span> promise}</span><span class=\"xml\">\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>正在请求中...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</span><span class=\"hljs-template-variable\">{:then res}</span><span class=\"xml\">\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>返回的内容</span><span class=\"hljs-template-variable\">{res}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</span><span class=\"hljs-template-variable\">{:catch error}</span><span class=\"xml\">\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>请求出现异常<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</span><span class=\"hljs-template-tag\">{/<span class=\"hljs-name\">await</span>}</span><span class=\"xml\">\n\n// 抑或者，你不需要展示loading以及catch错误的话，可以直接then出来\n</span><span class=\"hljs-template-tag\">{#<span class=\"hljs-name\">await</span> promise then res}</span><span class=\"xml\">\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>返回的内容</span><span class=\"hljs-template-variable\">{res}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</span><span class=\"hljs-template-tag\">{/<span class=\"hljs-name\">await</span>}</span>\n</code></pre>\n</li>\n<li><p>事件处理。通过on定义符进行事件绑定。</p>\n<pre><code class=\"language-vue\">&lt;<span class=\"hljs-keyword\">button</span> <span class=\"hljs-keyword\">on</span>:click={事件名}&gt;点击&lt;/<span class=\"hljs-keyword\">button</span>&gt;\n<span class=\"hljs-comment\">// on后面接上原生的事件就好了，比如click、mousemove等</span>\n<span class=\"hljs-comment\">// 事件名可以替换为代码块，如</span>\n&lt;<span class=\"hljs-keyword\">button</span> <span class=\"hljs-keyword\">on</span>:click={e =&gt; {<span class=\"hljs-comment\">// 对变量进行操作}&gt;点击&lt;/button&gt;</span>\n</code></pre>\n<p>有些框架由于性能的原因建议不要用行内的方式写事件，尤其是在循环里面。但svelte并没有这个问题，你可以直接用而不用担心那些琐碎，svelte总会做到最好。</p>\n<p>事件修饰符，可以对事件进行几个有用的修饰。以previewDefault举例：</p>\n<pre><code class=\"language-vue\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">on:click</span>|<span class=\"hljs-attr\">preventDefault</span>=<span class=\"hljs-string\">{事件名}</span>&gt;</span>点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</code></pre>\n<ol>\n<li>preventDefault 阻止默认事件。</li>\n<li>stopPropagation 阻止事件冒泡。</li>\n<li>passive 优化对touch、wheel事件的滚动表现。</li>\n<li>capture 在 <em>capture</em> 阶段而不是<em>bubbling</em> 阶段触发事件处理程序。</li>\n<li>once 事件只运行一次就删除绑定。</li>\n<li>self 仅当 event.target 是其本身时才执行。</li>\n</ol>\n<p>以上修饰符可以串联使用。</p>\n</li>\n<li><p>组件通信。老生常谈，业务中遇到的太多了。</p>\n<pre><code class=\"language-vue\"><span class=\"hljs-comment\">// 父组件 parent.svelte</span>\n&lt;script&gt;\n    <span class=\"hljs-keyword\">import</span> child <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./child.svelte&#x27;</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sayHello</span>(<span class=\"hljs-params\">name</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Hi, <span class=\"hljs-subst\">${name}</span>`</span>)\n  }\n&lt;/script&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">child</span> <span class=\"hljs-attr\">on:say</span>=<span class=\"hljs-string\">{sayHello}</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">child</span>&gt;</span></span>\n\n<span class=\"hljs-comment\">// 子组件 child.svelte</span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-comment\">// 子组件要调用父组件的事件，需要用到事件派发器</span>\n  <span class=\"hljs-keyword\">import</span> { createEventDispatcher } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;svelte&#x27;</span>\n  <span class=\"hljs-keyword\">const</span> dispatch = createEventDispatcher()\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sayHello</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// 这里的话有些类似vue中的$emit</span>\n    dispatch(<span class=\"hljs-string\">&#x27;say&#x27;</span>, {\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;我&#x27;</span>\n    })\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">on:click</span>=<span class=\"hljs-string\">{sayHello}</span>&gt;</span>点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"hljs-comment\">// 如果是dom事件，那么子组件只要不具名，就可以直接调用父组件的事件</span>\n<span class=\"hljs-comment\">// 父组件事件定义</span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">on:click</span>=<span class=\"hljs-string\">{eventName}</span>&gt;</span>点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"hljs-comment\">// 如果子组件想直接调用dom事件eventName，则</span>\n<span class=\"hljs-comment\">// 子组件</span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">on:click</span>&gt;</span>点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n</code></pre>\n<p>如果组件嵌套，需要多次转发事件的话，可以把中间的组件都加一个on:eventName，那么事件名为eventName的事件就会一直转发到目标组件上。</p>\n<p><em>2021-06-01 23:20</em></p>\n</li>\n</ol>\n<p>12.双向绑定。和vue原理对比TODO。在svelte中的双向绑定，只需要通过bind修饰就可以。</p>\n<pre><code class=\"language-vue\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&#x27;cat&#x27;</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">bind:value</span>=<span class=\"hljs-string\">{name}</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">input</span>&gt;</span>\n</code></pre>\n<p>表单元素都可以通过bind进行双向绑定，比如checkbox等。</p>\n<p>对数组对象，可以直接对值进行循环绑定，这个和vue类似。</p>\n<p>每个块级标签都可以对<code>clientWidth</code>、<code>clientHeight</code>、<code>offsetWidth</code>、<code>offsetHeight</code>进行绑定。但绑定值只是可读，直接赋值不会进行更新。可以用在读取块元素的尺寸后用于展示等业务上。</p>\n<ol start=\"13\">\n<li><p>组件绑定。这个有点意思，我觉得像是vue中的.sync修饰。可以做到在父组件中直接读取子组件export的值。</p>\n</li>\n<li><p>生命周期。类比vue的生命周期，svelte的生命周期钩子还是很容易理解的。</p>\n</li>\n</ol>\n<p>在svelte中，每一个组件都有其完整的生命周期，周期的函数需要从svelte中引入。</p>\n<ul>\n<li><p><code>onMount</code>。使用最多的应该是<code>onMount</code>钩子，它在组件渲染到dom后执行。可以在这个周期内进行数据的请求操作，这是svelte所推荐的，如果把请求操作放到script内则不好，因为如果需要服务端渲染的话，生命周期函数是没法在服务端渲染过程中执行的。</p>\n</li>\n<li><p><code>onDestroy</code>。组件销毁的时候调用，可以对计时器进行清除等操作。文档中有一个有意思的封装，可以把计数器的操作和组件销毁时销毁计时器一起封装。</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 比如封装到util.js中</span>\nimoprt { onDestroy } from &#x27;svelte&#x27;\nexport <span class=\"hljs-keyword\">function</span> on<span class=\"hljs-constructor\">Interval(<span class=\"hljs-params\">callback</span>, <span class=\"hljs-params\">time</span>)</span> {\n  const interval = set<span class=\"hljs-constructor\">Interval(<span class=\"hljs-params\">callback</span>, <span class=\"hljs-params\">time</span>)</span>\n  on<span class=\"hljs-constructor\">Destroy(()</span> =&gt; {\n    clear<span class=\"hljs-constructor\">Interval(<span class=\"hljs-params\">interval</span>)</span>\n  })\n}\n</code></pre>\n<p>那么在组件中就可以直接引入onInterval并调用，那就不需要关切组件销毁的时候有没有把计时器进行销毁。</p>\n<pre><code class=\"language-vue\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> </span></span><span class=\"hljs-template-variable\">{ onInterval }</span><span class=\"xml\"><span class=\"javascript\"> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./util.js&#x27;</span>\n  onInterval(<span class=\"hljs-function\">() =&gt;</span> </span></span><span class=\"hljs-template-variable\">{}</span><span class=\"xml\">, 1000)\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n</li>\n<li><p><code>beforeUpdate</code>、<code>afterUpdate</code>。该钩子在DOM渲染完成前执行。场景例如：渲染标签的滚动位置。</p>\n</li>\n<li><p><code>tick</code>。可以随时调用，是一个带有resolve方法的promise，解释是每当组件pendding状态变化就会立即提现到DOM中，类似于vue的<code>$nextTick()</code>?</p>\n</li>\n</ul>\n<ol start=\"15\">\n<li><p>store。svelte自带了壮态管理，由引入自svelte/store的writable定义：</p>\n<p><strong>可写store</strong></p>\n<pre><code class=\"language-javascript\">imoprt { writable } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;svelte/store&#x27;</span>\n\nexport <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">count</span> = writable(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 默认值为0，这里注意可以使用const进行定义，即便count是一个数值</span>\n</code></pre>\n<p>在组件中，count具备update、set方法，分别表示更新和重置值。</p>\n<p>在store创建后，开启的事件订阅，需要在不使用的时候销毁。我们可以在组件的onDestroy周期中取消订阅，避免内存溢出。</p>\n<pre><code class=\"language-vue\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> </span></span><span class=\"hljs-template-variable\">{ onDestroy }</span><span class=\"xml\"><span class=\"javascript\"> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;svelte&#x27;</span>\n  <span class=\"hljs-keyword\">import</span> </span></span><span class=\"hljs-template-variable\">{ count }</span><span class=\"xml\"><span class=\"javascript\"> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./store.js&#x27;</span>\n  \n  <span class=\"hljs-keyword\">let</span> countValue\n  <span class=\"hljs-keyword\">const</span> unsubscribe = count.subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span> </span></span><span class=\"hljs-template-variable\">{ // 手动订阅\n    count_value = value\n  }</span><span class=\"xml\"><span class=\"javascript\">)\n  onDestroy(unsubscribe) <span class=\"hljs-comment\">// 在组件销毁的时候取消订阅</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<p>那如果每一个状态都需要这么订阅和销毁的话，就太冗余了，svelte提供一个$符。可以对状态自动进行订阅和取消订阅。yyds。</p>\n<pre><code class=\"language-vue\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scirpt</span>&gt;</span>\n    imoprt </span><span class=\"hljs-template-variable\">{ count }</span><span class=\"xml\"> from &#x27;./store.js&#x27;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scirpt</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span> </span><span class=\"hljs-template-variable\">{$count}</span><span class=\"xml\"> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n</code></pre>\n<p><strong>只读store</strong></p>\n<p>只需在定义的时候，由writable改为readable就可以定义一个只读的store。</p>\n<p><strong>防止暴露set、update方法的自定义store</strong></p>\n<pre><code class=\"language-javascript\">import { writable } from <span class=\"hljs-string\">&#x27;svelte/store&#x27;</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createCount</span>(<span class=\"hljs-params\"></span>) </span>{\n  const { subscribe, set, update } = writable(<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-keyword\">return</span> {\n    subscribe,\n    <span class=\"hljs-attr\">increment</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> update(<span class=\"hljs-function\"><span class=\"hljs-params\">n</span> =&gt;</span> n + <span class=\"hljs-number\">1</span>),\n    <span class=\"hljs-attr\">decrement</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> update(<span class=\"hljs-function\"><span class=\"hljs-params\">n</span> =&gt;</span> n - <span class=\"hljs-number\">1</span>),\n    <span class=\"hljs-attr\">reset</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> set(<span class=\"hljs-number\">0</span>)\n  }\n}\n</code></pre>\n</li>\n<li><p>class指令。在svelte中动态设置class或者说其余的dom属性，会和vue有一些不一样。</p>\n<pre><code class=\"language-vue\">&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;{isTrue ? &#x27;true-class&#x27; : &#x27;false-class&#x27;}&quot;</span>&gt;\n  name\n&lt;/<span class=\"hljs-keyword\">div</span>&gt;\n&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-keyword\">class</span>:selected=<span class=\"hljs-string\">&quot;{isTrue}&quot;</span>&gt; <span class=\"hljs-comment\">// 之后留意如何设置camel-case的class名</span>\n  name\n&lt;/<span class=\"hljs-keyword\">div</span>&gt;\n</code></pre>\n</li>\n<li><p>组件插槽，和vue的思想一样，这里看文档注意多个插槽怎么具名。</p>\n<pre><code class=\"language-vue\">// 例如slot.svelte\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;slot-a&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n\n// 调用的组件\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Slot</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">&quot;slot-a&quot;</span>&gt;</span>\n    这里是一个具名插槽\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Slot</span>&gt;</span>\n</code></pre>\n</li>\n</ol>\n<p>18.context API。通过context api，可以跨越组件进行通信。具备setContext和getContext两个api。如果在一个组件中调用了setContext(key, context)，那么，在所有该子组件中都可以调用该context。</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 父组件中</span>\nset<span class=\"hljs-constructor\">Context(<span class=\"hljs-params\">key</span>, <span class=\"hljs-params\">context</span>)</span>\n<span class=\"hljs-comment\">// 任意的子组件中</span>\nconst context = get<span class=\"hljs-constructor\">Context(<span class=\"hljs-params\">key</span>)</span>\n</code></pre>\n<ol start=\"19\">\n<li><p>特殊标签。svelte具备一些特殊的标签。</p>\n<ul>\n<li><p>svelte:self。允许组件递归的去包含自己本身。</p>\n</li>\n<li><p>svelte:component。动态组件，与vue类似的用法，通过传入this的组件名，动态挂在组件。</p>\n<pre><code class=\"language-vue\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svelte:component</span> <span class=\"hljs-attr\">this</span>=<span class=\"hljs-string\">{compnentName}</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svelte:component</span>&gt;</span>\n</code></pre>\n</li>\n<li><p>svelte:window。把它当作是一个window对象，可以在该标签上进行事件的监听等操作。</p>\n</li>\n<li><p>svelte:body。和window的标签一样，可以在document.body上添加事件监听。</p>\n</li>\n<li><p>svelte:head。允许你在页面的<head>标签内插入内容。</p>\n<pre><code class=\"language-html\"><span class=\"hljs-section\">&lt;svelte:head&gt;</span>\n  <span class=\"hljs-section\">&lt;link&gt;</span><span class=\"hljs-section\">&lt;/link&gt;</span>\n<span class=\"hljs-section\">&lt;/svelte:head&gt;</span>\n</code></pre>\n<p>需要注意的是，在服务端渲染下，这个标签的内容将会单独返回到html中。</p>\n</li>\n</ul>\n</li>\n</ol>\n"}