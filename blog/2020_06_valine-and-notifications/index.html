<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <link href=client/client-e118e612.css rel=stylesheet> <title>博客评论更改为valine并增加评论推送-GzhiYi's blog</title><meta content=评论模块由gitalk转为valine，通过techulus的push进行评论推送 name=description data-svelte=svelte-2vncnt><meta content="sapper,blog,techulus push,valine,comments" name=keywords data-svelte=svelte-2vncnt> <link href=/client/client.505ae8a1.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-e118e612.css rel=preload as=style><link href=/client/[slug].f89c7f6c.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/config.026ad977.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials></head> <body> <div id=sapper> <nav class=svelte-1dbd5up><ul class=svelte-1dbd5up><li class=svelte-1dbd5up><a href=. class=svelte-1dbd5up>home</a></li> <li class=svelte-1dbd5up><a href=about class=svelte-1dbd5up>about</a></li> <li class=svelte-1dbd5up><a href=blog class=svelte-1dbd5up aria-current=page rel=prefetch>blog</a></ul></nav> <main class=svelte-1uhnsl8> <div class=flex><div class=base><div class=title>博客评论更改为valine并增加评论推送</div> <span>2020-06-29</span></div> <div class=content><p>通过一点时间的使用，发现gitalk可以解决静态博客评论问题，是挺方便的，但综合考虑下，存在以下两个缺点：</p> <ol> <li>需要github账号登录。</li> <li>访问非常慢。</li> </ol> <p>有意间，发现一个评论插件很适合静态博客植入：<a href=https://valine.js.org/ target=_blank>Valine</a>。</p> <p>新样式</p> <p><img align=center alt=style data-zoomable src=https://i.loli.net/2020/06/29/RiSBpcyAQD1kXCN.jpg style=width:100%></p> <p>新评论模块默认很清新，和我当前的样式较为符合，只做了一点点的样式覆盖。</p> <pre><code class=language-css><span class=hljs-comment>/* valine 样式覆盖 */</span>
<span class=hljs-selector-class>.v</span><span class=hljs-selector-attr>[data-class=v]</span> <span class=hljs-selector-class>.vwrap</span> {
    <span class=hljs-attribute>border</span>: <span class=hljs-number>1px</span> solid rgba(<span class=hljs-number>255</span>, <span class=hljs-number>62</span>, <span class=hljs-number>0</span>, <span class=hljs-number>0.1</span>) <span class=hljs-meta>!important</span>;
}
<span class=hljs-selector-class>.v</span><span class=hljs-selector-attr>[data-class=v]</span> <span class=hljs-selector-class>.vwrap</span> <span class=hljs-selector-class>.vheader</span> <span class=hljs-selector-class>.vinput</span> {
    <span class=hljs-attribute>border-bottom</span>: none <span class=hljs-meta>!important</span>;
}
<span class=hljs-selector-class>.v</span><span class=hljs-selector-attr>[data-class=v]</span> <span class=hljs-selector-class>.txt-right</span> {
    <span class=hljs-attribute>display</span>: none <span class=hljs-meta>!important</span>;
}
</code></pre> <h2 id=推送>推送</h2> <p>在valine的文档中，有提到可以用一个扩展的valine-admin以实现评论通知功能。我在leancloud尝试了发现比较麻烦。外加之前使用GitHub Actions用到了一个推送服务实现了在action成功之后推送部署成功的通知到手机上。那是不是可以通过下面的思路去实现评论推送呢？</p> <blockquote> <p><a href=https://push.techulus.com/ target=_blank>PUSH注册</a>注册后使用免费的plan，可以每月100条推送限额。要推送到手机，只需要调用提供的接口还有下载一个手机APP就好了。</p> </blockquote> <p>要知道，做到推送到手机，只需要POST下面的接口：</p> <pre><code class=language-bash>https:<span class=hljs-regexp>//</span>push.techulus.com<span class=hljs-regexp>/api/</span>v1<span class=hljs-regexp>/notify/</span>{YOU API KEY}?title=Push by Techulus&body=This is your first push notification
</code></pre> <ol> <li>在评论接口POST请求之后，在lean端通过类似拦截/触发的方法调用推送接口。</li> <li>在网页端拦截POST请求，在评论发出之后，在调用推送接口。</li> </ol> <p>在查看对应文档之后，第一种方式我找不到可行的入口。我想确定数据库入库的逻辑在哪处理的也找不到，所以采用第二种方法。</p> <h2 id=拦截评论请求>拦截评论请求</h2> <ol> <li>博客引入ajax-hook全局拦截请求</li> </ol> <pre><code class=language-html><span class=hljs-tag>&lt;<span class=hljs-name>script</span> <span class=hljs-attr>src</span>=<span class=hljs-string>"https://unpkg.com/ajax-hook@2.0.3/dist/ajaxhook.min.js"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>
</code></pre> <ol start=2> <li><p>在ajax-hook实例上，处理onRequest钩子。</p> <pre><code class=language-javascript>ah.proxy({
         <span class=hljs-regexp>//</span>请求发起前进入
         onRequest: (config, handler) => {
             <span class=hljs-keyword>if</span> (config.url.includes(<span class=hljs-string>'classes/Comment'</span>) && config.method === <span class=hljs-string>'POST'</span>) {
                 console.log(<span class=hljs-string>'请求发起前'</span>, config.body)
                 fetch(
                     `https:<span class=hljs-regexp>//</span>push.techulus.com<span class=hljs-regexp>/api/</span>v1<span class=hljs-regexp>/notify/</span><span class=hljs-variable>${YOU API KEY}</span>?title=<span class=hljs-variable>${location.pathname || '文章'}</span>有新回复&body=<span class=hljs-variable>${config.body.substr(12, 30)}</span>`,
                     {
                         method: <span class=hljs-string>'POST'</span>,
                         mode: <span class=hljs-string>'cors'</span>,
                         headers: new Headers({
                             <span class=hljs-string>'Content-Type'</span>: <span class=hljs-string>'application/json'</span>
                         })
                     }
                 )
             }
             handler.<span class=hljs-keyword>next</span>(config);
         },
         <span class=hljs-regexp>//</span>请求发生错误时进入，比如超时；注意，不包括http状态码错误，如<span class=hljs-number>404</span>仍然会认为请求成功
         onError: (err, handler) => {
                 handler.<span class=hljs-keyword>next</span>(err)
         },
         <span class=hljs-regexp>//</span>请求成功后进入
         onResponse: (response, handler) => {
                 handler.<span class=hljs-keyword>next</span>(response)
         }
     })
</code></pre> <p>更多关于ajax-hook的文档，参阅：<a href=https://github.com/wendux/Ajax-hook target=_blank>ajax-hook</a> </p> </li> </ol> <h2 id=缺点提示>缺点提示</h2> <p>第一种方式可以很好的保护推送的API KEY，因为有限额，暴露后可以随意调用。第二种比较简单易行。不过，反正push服务免费的话，也不会有损失。如果push服务付费就不要用第二种方法了。</p> <p>完成以上操作就可以收到评论推送啦，还是很方便的。如果有更好的免费push服务提供的，可以评论留言，我会很快看到的。</p> </div> </div></main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"博客评论更改为valine并增加评论推送",description:"评论模块由gitalk转为valine，通过techulus的push进行评论推送",keywords:"sapper,blog,techulus push,valine,comments",labels:["前端"],date:"2020-06-29",path:"2020\u002F06\u002Fvaline-and-notifications.md",slug:"2020_06_valine-and-notifications",html:"\u003Cp\u003E通过一点时间的使用，发现gitalk可以解决静态博客评论问题，是挺方便的，但综合考虑下，存在以下两个缺点：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E需要github账号登录。\u003C\u002Fli\u003E\n\u003Cli\u003E访问非常慢。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E有意间，发现一个评论插件很适合静态博客植入：\u003Ca target='_blank'  href=\"https:\u002F\u002Fvaline.js.org\u002F\"\u003EValine\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E新样式\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F29\u002FRiSBpcyAQD1kXCN.jpg\" alt=\"style\" \u003E\u003C\u002Fp\u003E\n\u003Cp\u003E新评论模块默认很清新，和我当前的样式较为符合，只做了一点点的样式覆盖。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-css\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F* valine 样式覆盖 *\u002F\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-selector-class\"\u003E.v\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-selector-attr\"\u003E[data-class=v]\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-class\"\u003E.vwrap\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-attribute\"\u003Eborder\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-number\"\u003E1px\u003C\u002Fspan\u003E solid rgba(\u003Cspan class=\"hljs-number\"\u003E255\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E62\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E0.1\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-meta\"\u003E!important\u003C\u002Fspan\u003E;\n}\n\u003Cspan class=\"hljs-selector-class\"\u003E.v\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-selector-attr\"\u003E[data-class=v]\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-class\"\u003E.vwrap\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-class\"\u003E.vheader\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-class\"\u003E.vinput\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-attribute\"\u003Eborder-bottom\u003C\u002Fspan\u003E: none \u003Cspan class=\"hljs-meta\"\u003E!important\u003C\u002Fspan\u003E;\n}\n\u003Cspan class=\"hljs-selector-class\"\u003E.v\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-selector-attr\"\u003E[data-class=v]\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-selector-class\"\u003E.txt-right\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-attribute\"\u003Edisplay\u003C\u002Fspan\u003E: none \u003Cspan class=\"hljs-meta\"\u003E!important\u003C\u002Fspan\u003E;\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"推送\"\u003E推送\u003C\u002Fh2\u003E\n\u003Cp\u003E在valine的文档中，有提到可以用一个扩展的valine-admin以实现评论通知功能。我在leancloud尝试了发现比较麻烦。外加之前使用GitHub Actions用到了一个推送服务实现了在action成功之后推送部署成功的通知到手机上。那是不是可以通过下面的思路去实现评论推送呢？\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E\u003Ca target='_blank'  href=\"https:\u002F\u002Fpush.techulus.com\u002F\"\u003EPUSH注册\u003C\u002Fa\u003E注册后使用免费的plan，可以每月100条推送限额。要推送到手机，只需要调用提供的接口还有下载一个手机APP就好了。\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E要知道，做到推送到手机，只需要POST下面的接口：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Ehttps:\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003Epush.techulus.com\u003Cspan class=\"hljs-regexp\"\u003E\u002Fapi\u002F\u003C\u002Fspan\u003Ev1\u003Cspan class=\"hljs-regexp\"\u003E\u002Fnotify\u002F\u003C\u002Fspan\u003E{YOU API KEY}?title=Push by Techulus&amp;body=This is your first push notification\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col\u003E\n\u003Cli\u003E在评论接口POST请求之后，在lean端通过类似拦截\u002F触发的方法调用推送接口。\u003C\u002Fli\u003E\n\u003Cli\u003E在网页端拦截POST请求，在评论发出之后，在调用推送接口。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E在查看对应文档之后，第一种方式我找不到可行的入口。我想确定数据库入库的逻辑在哪处理的也找不到，所以采用第二种方法。\u003C\u002Fp\u003E\n\u003Ch2 id=\"拦截评论请求\"\u003E拦截评论请求\u003C\u002Fh2\u003E\n\u003Col\u003E\n\u003Cli\u003E博客引入ajax-hook全局拦截请求\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Esrc\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;https:\u002F\u002Funpkg.com\u002Fajax-hook@2.0.3\u002Fdist\u002Fajaxhook.min.js&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"2\"\u003E\n\u003Cli\u003E\u003Cp\u003E在ajax-hook实例上，处理onRequest钩子。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Eah.proxy({\n         \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E请求发起前进入\n         onRequest: (config, handler) =&gt; {\n             \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (config.url.includes(\u003Cspan class=\"hljs-string\"\u003E&#x27;classes\u002FComment&#x27;\u003C\u002Fspan\u003E) &amp;&amp; config.method === \u003Cspan class=\"hljs-string\"\u003E&#x27;POST&#x27;\u003C\u002Fspan\u003E) {\n                 console.log(\u003Cspan class=\"hljs-string\"\u003E&#x27;请求发起前&#x27;\u003C\u002Fspan\u003E, config.body)\n                 fetch(\n                     `https:\u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003Epush.techulus.com\u003Cspan class=\"hljs-regexp\"\u003E\u002Fapi\u002F\u003C\u002Fspan\u003Ev1\u003Cspan class=\"hljs-regexp\"\u003E\u002Fnotify\u002F\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-variable\"\u003E${YOU API KEY}\u003C\u002Fspan\u003E?title=\u003Cspan class=\"hljs-variable\"\u003E${location.pathname || &#x27;文章&#x27;}\u003C\u002Fspan\u003E有新回复&amp;body=\u003Cspan class=\"hljs-variable\"\u003E${config.body.substr(12, 30)}\u003C\u002Fspan\u003E`,\n                     {\n                         method: \u003Cspan class=\"hljs-string\"\u003E&#x27;POST&#x27;\u003C\u002Fspan\u003E,\n                         mode: \u003Cspan class=\"hljs-string\"\u003E&#x27;cors&#x27;\u003C\u002Fspan\u003E,\n                         headers: new Headers({\n                             \u003Cspan class=\"hljs-string\"\u003E&#x27;Content-Type&#x27;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;application\u002Fjson&#x27;\u003C\u002Fspan\u003E\n                         })\n                     }\n                 )\n             }\n             handler.\u003Cspan class=\"hljs-keyword\"\u003Enext\u003C\u002Fspan\u003E(config);\n         },\n         \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E请求发生错误时进入，比如超时；注意，不包括http状态码错误，如\u003Cspan class=\"hljs-number\"\u003E404\u003C\u002Fspan\u003E仍然会认为请求成功\n         onError: (err, handler) =&gt; {\n                 handler.\u003Cspan class=\"hljs-keyword\"\u003Enext\u003C\u002Fspan\u003E(err)\n         },\n         \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E请求成功后进入\n         onResponse: (response, handler) =&gt; {\n                 handler.\u003Cspan class=\"hljs-keyword\"\u003Enext\u003C\u002Fspan\u003E(response)\n         }\n     })\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E更多关于ajax-hook的文档，参阅：\u003Ca target='_blank'  href=\"https:\u002F\u002Fgithub.com\u002Fwendux\u002FAjax-hook\"\u003Eajax-hook\u003C\u002Fa\u003E    \u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch2 id=\"缺点提示\"\u003E缺点提示\u003C\u002Fh2\u003E\n\u003Cp\u003E第一种方式可以很好的保护推送的API KEY，因为有限额，暴露后可以随意调用。第二种比较简单易行。不过，反正push服务免费的话，也不会有损失。如果push服务付费就不要用第二种方法了。\u003C\u002Fp\u003E\n\u003Cp\u003E完成以上操作就可以收到评论推送啦，还是很方便的。如果有更好的免费push服务提供的，可以评论留言，我会很快看到的。\u003C\u002Fp\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.505ae8a1.js"}catch(e){main="/client/legacy/client.86ff3711.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 