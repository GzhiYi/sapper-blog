{"title":"2019-09/js-asset-import.md","path":"2019-09/js-asset-import","slug":"2019-09_js-asset-import","html":"<h2 id=\"js引入的时候放在哪比较好呢？\">JS引入的时候放在哪比较好呢？</h2>\n<p>很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。</p>\n<h2 id=\"浏览器渲染\">浏览器渲染</h2>\n<p>在知道放在哪最好之前，需要知道下浏览器渲染的过程。有以下的步骤：</p>\n<ul>\n<li>处理文档中的标签并构建DOM（Document Object Model）树。</li>\n<li>处理文档中的css并构建CSSOM（CSS Object Model）树。</li>\n<li>合并DOM和CSSOM为一个渲染树。</li>\n<li>处理渲染树没一个节点的布局。</li>\n<li>最后将没一个节点渲染（绘制）到浏览器上。</li>\n</ul>\n<h3 id=\"阻塞渲染：css和javascript\">阻塞渲染：CSS和JavaScript</h3>\n<p>浏览器资源阻塞是一个常见的问题。要知道，资源在大多数浏览器上都是并行加载的，这种情况下，当Html文档被javascript阻塞时，Html文档会终止构建，但仍会<code>识别阻塞脚本后面的资源，进行预加载</code>。有以下要点需要注意：</p>\n<ul>\n<li>css加载不会阻塞dom树解析，但会阻塞dom树渲染。</li>\n<li>浏览器dom构建会在遇到script标签的时候暂停，直到script内的脚本执行完毕。</li>\n<li>CSSOM在构建的时候，JavaScript的执行会暂停，直到CSSOM准备就绪。</li>\n</ul>\n<p>以上正好说明了，我该把js脚本放在哪😄。我们就得出这样的原则以加快文档构建渲染：</p>\n<ol>\n<li>CSS优先渲染。将css放在JavaScript资源之上，也就是普遍的放在 &lt; head &gt; 标签内。</li>\n<li>为减少script脚本对dom构建的影响，应该把script尽可能的放到最后（文档底部）。</li>\n</ol>\n<h2 id=\"defer和async\">defer和async</h2>\n<p>script标签的这两个属性，均是为解决上面问题的。defer和async的使用有所不同。\n<code>defer</code>：DOM元素的加载和脚本的 ** 加载 ** 异步执行。但是脚本的执行需要在所有dom元素解析完成之后，在<code>DOMContentLoaded</code>事件触发之前执行。\n<code>async</code>：DOM元素的加载和脚本的加载 ** 以及执行 ** 异步执行。</p>\n<p><img align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/65817605-0ae1dc00-e23c-11e9-890b-e70207d371b6.jpeg\" alt=\"284aec5bb7f16b3ef4e7482110c5ddbb_articlex\" ></p>\n<ul>\n<li>无async和defer的时候，dom渲染被脚本<del>加载以及执行</del>所中断。</li>\n<li>defer的时候，dom渲染未被阻塞，但脚本执行将会到最后。这个特性可以对需求有所利用。</li>\n<li>async的时候，dom渲染和脚本加载和执行异步。</li>\n</ul>\n<h2 id=\"有时候要用到动态引入？\">有时候要用到动态引入？</h2>\n<p>  统计脚本，广告脚本这类第三方嵌入脚本会在文档底部引入脚本文件。但都是以js生成script标签的形式进行动态引入。\n  先来看下百度统计脚本是怎么引入的：</p>\n<pre><code class=\"language-javascript\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">var</span> hm = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">\"script\"</span>);\n  hm.src = <span class=\"hljs-string\">\"https://hm.baidu.com/hm.js?10dbf7bc9ad86276329db7b\"</span>;\n  <span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-built_in\">document</span>.getElementsByTagName(<span class=\"hljs-string\">\"script\"</span>)[<span class=\"hljs-number\">0</span>];\n  s.parentNode.insertBefore(hm, s);\n})();</code></pre>\n<p>这就是动态创建script标签进行引入的方式。那么为什么要这样引入而不是直接:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">\"source_url\"</span> <span class=\"hljs-attr\">async</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></code></pre>\n<p>  ** 其实，这既不是自执行函数的问题，也不是阻塞渲染的问题。是为了防止用户把脚本放置在文档不规范的地方导致文档被阻塞，并不是所有的脚本嵌入用户都知道这个脚本应该嵌入在哪的。而这样动态引入就可以避免这样的问题。**</p>\n","fmData":{"attributes":{"title":"JS引入资源的一点总结","description":"很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。","keywords":"javascript,script,阻塞渲染,defer,async,动态引入","labels":["前端"],"date":"2019-09-28T00:00:00.000Z"},"body":"## JS引入的时候放在哪比较好呢？\n\n很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。\n\n## 浏览器渲染\n\n在知道放在哪最好之前，需要知道下浏览器渲染的过程。有以下的步骤：\n\n- 处理文档中的标签并构建DOM（Document Object Model）树。\n- 处理文档中的css并构建CSSOM（CSS Object Model）树。\n- 合并DOM和CSSOM为一个渲染树。\n- 处理渲染树没一个节点的布局。\n- 最后将没一个节点渲染（绘制）到浏览器上。\n\n### 阻塞渲染：CSS和JavaScript\n\n浏览器资源阻塞是一个常见的问题。要知道，资源在大多数浏览器上都是并行加载的，这种情况下，当Html文档被javascript阻塞时，Html文档会终止构建，但仍会`识别阻塞脚本后面的资源，进行预加载`。有以下要点需要注意：\n\n- css加载不会阻塞dom树解析，但会阻塞dom树渲染。\n- 浏览器dom构建会在遇到script标签的时候暂停，直到script内的脚本执行完毕。\n- CSSOM在构建的时候，JavaScript的执行会暂停，直到CSSOM准备就绪。\n\n以上正好说明了，我该把js脚本放在哪😄。我们就得出这样的原则以加快文档构建渲染：\n\n1. CSS优先渲染。将css放在JavaScript资源之上，也就是普遍的放在 < head > 标签内。\n2. 为减少script脚本对dom构建的影响，应该把script尽可能的放到最后（文档底部）。\n\n## defer和async\n\nscript标签的这两个属性，均是为解决上面问题的。defer和async的使用有所不同。\n`defer`：DOM元素的加载和脚本的 ** 加载 ** 异步执行。但是脚本的执行需要在所有dom元素解析完成之后，在`DOMContentLoaded`事件触发之前执行。\n`async`：DOM元素的加载和脚本的加载 ** 以及执行 ** 异步执行。\n\n![284aec5bb7f16b3ef4e7482110c5ddbb_articlex](https://user-images.githubusercontent.com/21136420/65817605-0ae1dc00-e23c-11e9-890b-e70207d371b6.jpeg)\n\n  - 无async和defer的时候，dom渲染被脚本~~加载以及执行~~所中断。\n  - defer的时候，dom渲染未被阻塞，但脚本执行将会到最后。这个特性可以对需求有所利用。\n  - async的时候，dom渲染和脚本加载和执行异步。\n\n## 有时候要用到动态引入？\n\n  统计脚本，广告脚本这类第三方嵌入脚本会在文档底部引入脚本文件。但都是以js生成script标签的形式进行动态引入。\n  先来看下百度统计脚本是怎么引入的：\n  ```javascript\n(function() {\n    var hm = document.createElement(\"script\");\n    hm.src = \"https://hm.baidu.com/hm.js?10dbf7bc9ad86276329db7b\";\n    var s = document.getElementsByTagName(\"script\")[0];\n    s.parentNode.insertBefore(hm, s);\n  })();\n```\n这就是动态创建script标签进行引入的方式。那么为什么要这样引入而不是直接:\n  ```html\n<script src=\"source_url\" async></script>\n```\n  ** 其实，这既不是自执行函数的问题，也不是阻塞渲染的问题。是为了防止用户把脚本放置在文档不规范的地方导致文档被阻塞，并不是所有的脚本嵌入用户都知道这个脚本应该嵌入在哪的。而这样动态引入就可以避免这样的问题。**\n","bodyBegin":9,"frontmatter":"title: JS引入资源的一点总结\ndescription: 很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。\nkeywords: javascript,script,阻塞渲染,defer,async,动态引入\nlabels: ['前端']\ndate: 2019-09-28"}}