<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <link href=client/client-8d9aba14.css rel=stylesheet><link href=client/[slug]-72c0ef40.css rel=stylesheet> <title>一次h5开发踩坑记录-GzhiYi's blog</title><meta content=这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。 name=description data-svelte=svelte-2vncnt><meta content=h5,踩坑,vue,vux name=keywords data-svelte=svelte-2vncnt> <link href=/client/client.ab57a19f.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-8d9aba14.css rel=preload as=style><link href=/client/[slug].9997cae7.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/config.026ad977.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/[slug]-72c0ef40.css rel=preload as=style></head> <body> <div id=sapper> <nav class=svelte-1dbd5up><ul class=svelte-1dbd5up> <li class=svelte-1dbd5up><a href=blog aria-current=page class=svelte-1dbd5up rel=prefetch>blog</a></ul></nav> <main class=svelte-1y51i2> <div class="svelte-23vme9 base"><div class=label>前端</div> <div class="svelte-23vme9 title">一次h5开发踩坑记录</div> <span class="svelte-23vme9 author">GzhiYi · 2018-10-15</span></div> <div class="svelte-23vme9 content"><h3 id=时间>时间</h3> <p>这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。</p> <h3 id=使用框架>使用框架</h3> <p>原本想直接了当用jQuery，毕竟用jQuery开发是真的快而且紧急情况可控。缺点是写起来会比较乱，维护也比较麻烦。但最后还是放弃，想尝试新的技术。最后试用了几套框架|库后，决定使用vux进行编写。</p> <h3 id=vux>Vux</h3> <p><img align=center alt="tim 20181015093748" data-zoomable src=https://user-images.githubusercontent.com/21136420/48887191-5af85100-ee69-11e8-84e9-fc534223e75b.png style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3></p> <p>使用原因： </p> <ol> <li>使用vue-cli构建，几乎不用配置其余东西，内建命令让开发和打包生产版十分便捷。</li> <li>vux有大量组件而且github上有非常多的issue记录，遇到问题可以快速定位解决。</li> <li>vue生态给力，写起来舒舒服服。</li> </ol> <h3 id=主要坑>主要坑</h3> <p>由于第一次用vux写h5，难免会遇到不少问题，不仅是框架本身的问题，还有其他业务上需要攻克的问题。就记录下踩过的坑：</p> <ul> <li>background-image在部署的时候路径不对。</li> </ul> <p>修改vue-cli的build文件夹下的utils.js为如下： <img align=center alt=util data-zoomable src=https://user-images.githubusercontent.com/21136420/48887225-7b281000-ee69-11e8-85a0-6e465667d9c4.png style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3></p> <p>这样在 CSS 中：background-image: url("./assets/bg.jpg")，不管是在开发环境下还是在生产环境下，背景图都可以读出来</p> <ul> <li>怎么生成图片并在微信端支持长按保存图片？ </li> </ul> <p>以前也做过类似的，但没做过微信支持长按保存图片的。首先当然是要用到将html转为canvas然后再考虑转为图片。</p> <ol> <li>库：<a href=https://html2canvas.hertzen.com/documentation target=_blank>html2canvas</a></li> <li>用法非常简单，指定挂载的元素进行转化。</li> </ol> <pre><code class=language-javascript>html2canvas(<span class=hljs-built_in>document</span>.body).then(<span class=hljs-function>(<span class=hljs-params>canvas</span>) =></span> {
    <span class=hljs-built_in>console</span>.log(canvas);    <span class=hljs-comment>// 这个是生成的canvas</span>
    <span class=hljs-keyword>const</span> base64Code = canvas.toDataURL(<span class=hljs-string>"image/png"</span>);    <span class=hljs-comment>//将生成的canvas通过api`toDataURL`转为base64格式图片。</span>
});
</code></pre> <ul> <li>怎么保存图片？</li> </ul> <p>不是已经生成图片了吗？生成就可以可以保存了。没错，但是业务问题，在生成的图片上还要包含可点击的按钮和一个超链接。可以想到，可以将按钮和超链接定位到生成的图片上。可是存在这样的问题，不同的移动端呈现的结果可能不一致，这会直接导致页面显示出现问题，进而影响使用体验。这种覆盖的想法最后放弃了。</p> <p>最后的做法：将生成的图片的透明度设置为0覆盖到原本要渲染的元素上，然后提高可点击按钮的层级。 <img align=center alt="tim 20181015100607" data-zoomable src=https://user-images.githubusercontent.com/21136420/48887259-95fa8480-ee69-11e8-8564-ddbccc8f1e26.png style=width:100%;margin-bottom:20px;border-radius:8px;background:#f8fdf3></p> <ul> <li>存在无法分享到朋友圈的问题</li> </ul> <p>微信浏览器唤起的分享菜单，存在点击分享到朋友圈出现卡死问题。 排查过程： 在页面操作第一步和第二步都不会有这个问题，在生成图片的第三步就出现无法分享的问题。在想是不是生成图片太大了导致太卡顿了？在开发调试过程，打开vue开发工具查看第三步data的时候，发现非常卡顿。这样就可以认定是图片造成的卡顿了。</p> <p>最后找到的原因：canvas生成的base64编码的图片码十分长，直接导致vue处理的时候出现卡顿严重进而影响页面分享效果。最后的解决方案：将base64转为file上传，最后展示返回的url图片。</p> <pre><code class=language-javascript>  <span class=hljs-keyword>const</span> base64Code = canvas.toDataURL(<span class=hljs-string>"image/png"</span>)
  <span class=hljs-comment>// 去掉url的头，并转换为byte。以下步骤生成JavaScript blob文件</span>
  <span class=hljs-keyword>const</span> bytes = <span class=hljs-built_in>window</span>.atob(base64Code.split(<span class=hljs-string>','</span>)[<span class=hljs-number>1</span>])
  <span class=hljs-keyword>const</span> ab = <span class=hljs-keyword>new</span> <span class=hljs-built_in>ArrayBuffer</span>(bytes.length)
  <span class=hljs-keyword>const</span> ia = <span class=hljs-keyword>new</span> <span class=hljs-built_in>Uint8Array</span>(ab)
  <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> i = <span class=hljs-number>0</span>; i &lt; bytes.length; i++) {
    ia[i] = bytes.charCodeAt(i)
  }
  <span class=hljs-keyword>let</span> files = self.blobToFile(<span class=hljs-keyword>new</span> Blob([ab], { <span class=hljs-attr>type</span>: <span class=hljs-string>'png'</span> }), <span class=hljs-string>'post'</span>)
  <span class=hljs-keyword>let</span> formData = <span class=hljs-keyword>new</span> FormData()
  formData.append(<span class=hljs-string>"file"</span>, files, <span class=hljs-string>`myPost-<span class=hljs-subst>${<span class=hljs-keyword>new</span> <span class=hljs-built_in>Date</span>().getTime()}</span>.png`</span>);
  self.$http.post(config.fileUploadURL, formData, {
    <span class=hljs-attr>headers</span>: {
      <span class=hljs-string>'Content-Type'</span>: <span class=hljs-string>'multipart/form-data'</span>
    }
  }).then (<span class=hljs-function><span class=hljs-params>uploadRes</span> =></span> {
    <span class=hljs-keyword>if</span> (uploadRes.data.code === <span class=hljs-number>200</span>) {
      self.imageBase = uploadRes.data.url
    }
  })
</code></pre> <pre><code class=language-javascript>  <span class=hljs-comment>// blob图片转为文件的函数</span>
  blobToFile (theBlob, fileName){
    theBlob.lastModifiedDate = <span class=hljs-keyword>new</span> <span class=hljs-built_in>Date</span>();
    theBlob.name = fileName;
    <span class=hljs-keyword>return</span> theBlob;
  }
</code></pre> <h3 id=成品>成品</h3> <p>虽然国庆过了，但是还是贴出来哈哈。 <a href=http://xiaolu.ybj.com/wechat/html/gqyx/index.html target=_blank>活动</a></p> </div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"一次h5开发踩坑记录",description:"这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。",keywords:"h5,踩坑,vue,vux",labels:["前端"],date:"2018-10-15",path:"2018\u002F10\u002Fh5-step.md",slug:"2018_10_h5-step",html:"\u003Ch3 id=\"时间\"\u003E时间\u003C\u002Fh3\u003E\n\u003Cp\u003E这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。\u003C\u002Fp\u003E\n\u003Ch3 id=\"使用框架\"\u003E使用框架\u003C\u002Fh3\u003E\n\u003Cp\u003E原本想直接了当用jQuery，毕竟用jQuery开发是真的快而且紧急情况可控。缺点是写起来会比较乱，维护也比较麻烦。但最后还是放弃，想尝试新的技术。最后试用了几套框架|库后，决定使用vux进行编写。\u003C\u002Fp\u003E\n\u003C!--more--\u003E\n\u003Ch3 id=\"vux\"\u003EVux\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48887191-5af85100-ee69-11e8-84e9-fc534223e75b.png\" alt=\"tim 20181015093748\" \u003E\u003C\u002Fp\u003E\n\u003Cp\u003E使用原因：  \u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E使用vue-cli构建，几乎不用配置其余东西，内建命令让开发和打包生产版十分便捷。\u003C\u002Fli\u003E\n\u003Cli\u003Evux有大量组件而且github上有非常多的issue记录，遇到问题可以快速定位解决。\u003C\u002Fli\u003E\n\u003Cli\u003Evue生态给力，写起来舒舒服服。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"主要坑\"\u003E主要坑\u003C\u002Fh3\u003E\n\u003Cp\u003E由于第一次用vux写h5，难免会遇到不少问题，不仅是框架本身的问题，还有其他业务上需要攻克的问题。就记录下踩过的坑：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Ebackground-image在部署的时候路径不对。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E修改vue-cli的build文件夹下的utils.js为如下：\n\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48887225-7b281000-ee69-11e8-85a0-6e465667d9c4.png\" alt=\"util\" \u003E\u003C\u002Fp\u003E\n\u003Cp\u003E这样在 CSS 中：background-image: url(&quot;.\u002Fassets\u002Fbg.jpg&quot;)，不管是在开发环境下还是在生产环境下，背景图都可以读出来\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E怎么生成图片并在微信端支持长按保存图片？  \u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E以前也做过类似的，但没做过微信支持长按保存图片的。首先当然是要用到将html转为canvas然后再考虑转为图片。\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E库：\u003Ca target='_blank'  href=\"https:\u002F\u002Fhtml2canvas.hertzen.com\u002Fdocumentation\"\u003Ehtml2canvas\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E用法非常简单，指定挂载的元素进行转化。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Ehtml2canvas(\u003Cspan class=\"hljs-built_in\"\u003Edocument\u003C\u002Fspan\u003E.body).then(\u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003Ecanvas\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(canvas);    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这个是生成的canvas\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E base64Code = canvas.toDataURL(\u003Cspan class=\"hljs-string\"\u003E&quot;image\u002Fpng&quot;\u003C\u002Fspan\u003E);    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F将生成的canvas通过api`toDataURL`转为base64格式图片。\u003C\u002Fspan\u003E\n});\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E怎么保存图片？\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E不是已经生成图片了吗？生成就可以可以保存了。没错，但是业务问题，在生成的图片上还要包含可点击的按钮和一个超链接。可以想到，可以将按钮和超链接定位到生成的图片上。可是存在这样的问题，不同的移动端呈现的结果可能不一致，这会直接导致页面显示出现问题，进而影响使用体验。这种覆盖的想法最后放弃了。\u003C\u002Fp\u003E\n\u003Cp\u003E最后的做法：将生成的图片的透明度设置为0覆盖到原本要渲染的元素上，然后提高可点击按钮的层级。\n\u003Cimg align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48887259-95fa8480-ee69-11e8-8564-ddbccc8f1e26.png\" alt=\"tim 20181015100607\" \u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E存在无法分享到朋友圈的问题\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E微信浏览器唤起的分享菜单，存在点击分享到朋友圈出现卡死问题。\n排查过程： 在页面操作第一步和第二步都不会有这个问题，在生成图片的第三步就出现无法分享的问题。在想是不是生成图片太大了导致太卡顿了？在开发调试过程，打开vue开发工具查看第三步data的时候，发现非常卡顿。这样就可以认定是图片造成的卡顿了。\u003C\u002Fp\u003E\n\u003Cp\u003E最后找到的原因：canvas生成的base64编码的图片码十分长，直接导致vue处理的时候出现卡顿严重进而影响页面分享效果。最后的解决方案：将base64转为file上传，最后展示返回的url图片。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E base64Code = canvas.toDataURL(\u003Cspan class=\"hljs-string\"\u003E&quot;image\u002Fpng&quot;\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 去掉url的头，并转换为byte。以下步骤生成JavaScript blob文件\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E bytes = \u003Cspan class=\"hljs-built_in\"\u003Ewindow\u003C\u002Fspan\u003E.atob(base64Code.split(\u003Cspan class=\"hljs-string\"\u003E&#x27;,&#x27;\u003C\u002Fspan\u003E)[\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E])\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E ab = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EArrayBuffer\u003C\u002Fspan\u003E(bytes.length)\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E ia = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EUint8Array\u003C\u002Fspan\u003E(ab)\n  \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; bytes.length; i++) {\n    ia[i] = bytes.charCodeAt(i)\n  }\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E files = self.blobToFile(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Blob([ab], { \u003Cspan class=\"hljs-attr\"\u003Etype\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;png&#x27;\u003C\u002Fspan\u003E }), \u003Cspan class=\"hljs-string\"\u003E&#x27;post&#x27;\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E formData = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E FormData()\n  formData.append(\u003Cspan class=\"hljs-string\"\u003E&quot;file&quot;\u003C\u002Fspan\u003E, files, \u003Cspan class=\"hljs-string\"\u003E`myPost-\u003Cspan class=\"hljs-subst\"\u003E${\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EDate\u003C\u002Fspan\u003E().getTime()}\u003C\u002Fspan\u003E.png`\u003C\u002Fspan\u003E);\n  self.$http.post(config.fileUploadURL, formData, {\n    \u003Cspan class=\"hljs-attr\"\u003Eheaders\u003C\u002Fspan\u003E: {\n      \u003Cspan class=\"hljs-string\"\u003E&#x27;Content-Type&#x27;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;multipart\u002Fform-data&#x27;\u003C\u002Fspan\u003E\n    }\n  }).then (\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003EuploadRes\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (uploadRes.data.code === \u003Cspan class=\"hljs-number\"\u003E200\u003C\u002Fspan\u003E) {\n      self.imageBase = uploadRes.data.url\n    }\n  })\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F blob图片转为文件的函数\u003C\u002Fspan\u003E\n  blobToFile (theBlob, fileName){\n    theBlob.lastModifiedDate = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EDate\u003C\u002Fspan\u003E();\n    theBlob.name = fileName;\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E theBlob;\n  }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"成品\"\u003E成品\u003C\u002Fh3\u003E\n\u003Cp\u003E虽然国庆过了，但是还是贴出来哈哈。\n\u003Ca target='_blank'  href=\"http:\u002F\u002Fxiaolu.ybj.com\u002Fwechat\u002Fhtml\u002Fgqyx\u002Findex.html\"\u003E活动\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.ab57a19f.js"}catch(e){main="/client/legacy/client.2d9a922f.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 