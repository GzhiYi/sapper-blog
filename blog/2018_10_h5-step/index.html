<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=main.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <script src=//unpkg.com/valine/dist/Valine.min.js></script> <script src=https://unpkg.com/ajax-hook@2.0.3/dist/ajaxhook.min.js></script> <link href=client/main.1029972362.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>一次h5开发踩坑记录-GzhiYi's Blog</title><meta content=这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。 name=description><meta content=h5,踩坑,vue,vux name=keywords><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-1wr5yce><ul class=svelte-1wr5yce> <li class=svelte-1wr5yce><a href=/ aria-current=blog class=svelte-1wr5yce rel=prefetch>blog</a></ul></nav> <main class=svelte-iwmse4> <div class="svelte-mzxg2z content"><h1>一次h5开发踩坑记录</h1> <p class="svelte-mzxg2z desc">10/15/2018 <span class="svelte-mzxg2z label">前端</span></p> <h3 id=时间>时间</h3> <p>这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。</p> <h3 id=使用框架>使用框架</h3> <p>原本想直接了当用jQuery，毕竟用jQuery开发是真的快而且紧急情况可控。缺点是写起来会比较乱，维护也比较麻烦。但最后还是放弃，想尝试新的技术。最后试用了几套框架|库后，决定使用vux进行编写。</p> <h3 id=vux>Vux</h3> <p><img align=center alt="tim 20181015093748" data-zoomable src=https://user-images.githubusercontent.com/21136420/48887191-5af85100-ee69-11e8-84e9-fc534223e75b.png style=width:100%></p> <p>使用原因： </p> <ol> <li>使用vue-cli构建，几乎不用配置其余东西，内建命令让开发和打包生产版十分便捷。</li> <li>vux有大量组件而且github上有非常多的issue记录，遇到问题可以快速定位解决。</li> <li>vue生态给力，写起来舒舒服服。</li> </ol> <h3 id=主要坑>主要坑</h3> <p>由于第一次用vux写h5，难免会遇到不少问题，不仅是框架本身的问题，还有其他业务上需要攻克的问题。就记录下踩过的坑：</p> <ul> <li>background-image在部署的时候路径不对。</li> </ul> <p>修改vue-cli的build文件夹下的utils.js为如下： <img align=center alt=util data-zoomable src=https://user-images.githubusercontent.com/21136420/48887225-7b281000-ee69-11e8-85a0-6e465667d9c4.png style=width:100%></p> <p>这样在 CSS 中：background-image: url("./assets/bg.jpg")，不管是在开发环境下还是在生产环境下，背景图都可以读出来</p> <ul> <li>怎么生成图片并在微信端支持长按保存图片？ </li> </ul> <p>以前也做过类似的，但没做过微信支持长按保存图片的。首先当然是要用到将html转为canvas然后再考虑转为图片。</p> <ol> <li>库：<a href=https://html2canvas.hertzen.com/documentation target=_blank>html2canvas</a></li> <li>用法非常简单，指定挂载的元素进行转化。</li> </ol> <pre><code class=language-javascript>html2canvas(<span class=hljs-built_in>document</span>.body).then(<span class=hljs-function>(<span class=hljs-params>canvas</span>) =></span> {
    <span class=hljs-built_in>console</span>.log(canvas);    <span class=hljs-comment>// 这个是生成的canvas</span>
    <span class=hljs-keyword>const</span> base64Code = canvas.toDataURL(<span class=hljs-string>"image/png"</span>);    <span class=hljs-comment>//将生成的canvas通过api`toDataURL`转为base64格式图片。</span>
});</code></pre> <ul> <li>怎么保存图片？</li> </ul> <p>不是已经生成图片了吗？生成就可以可以保存了。没错，但是业务问题，在生成的图片上还要包含可点击的按钮和一个超链接。可以想到，可以将按钮和超链接定位到生成的图片上。可是存在这样的问题，不同的移动端呈现的结果可能不一致，这会直接导致页面显示出现问题，进而影响使用体验。这种覆盖的想法最后放弃了。</p> <p>最后的做法：将生成的图片的透明度设置为0覆盖到原本要渲染的元素上，然后提高可点击按钮的层级。 <img align=center alt="tim 20181015100607" data-zoomable src=https://user-images.githubusercontent.com/21136420/48887259-95fa8480-ee69-11e8-8564-ddbccc8f1e26.png style=width:100%></p> <ul> <li>存在无法分享到朋友圈的问题</li> </ul> <p>微信浏览器唤起的分享菜单，存在点击分享到朋友圈出现卡死问题。 排查过程： 在页面操作第一步和第二步都不会有这个问题，在生成图片的第三步就出现无法分享的问题。在想是不是生成图片太大了导致太卡顿了？在开发调试过程，打开vue开发工具查看第三步data的时候，发现非常卡顿。这样就可以认定是图片造成的卡顿了。</p> <p>最后找到的原因：canvas生成的base64编码的图片码十分长，直接导致vue处理的时候出现卡顿严重进而影响页面分享效果。最后的解决方案：将base64转为file上传，最后展示返回的url图片。</p> <pre><code class=language-javascript>  <span class=hljs-keyword>const</span> base64Code = canvas.toDataURL(<span class=hljs-string>"image/png"</span>)
  <span class=hljs-comment>// 去掉url的头，并转换为byte。以下步骤生成JavaScript blob文件</span>
  <span class=hljs-keyword>const</span> bytes = <span class=hljs-built_in>window</span>.atob(base64Code.split(<span class=hljs-string>','</span>)[<span class=hljs-number>1</span>])
  <span class=hljs-keyword>const</span> ab = <span class=hljs-keyword>new</span> <span class=hljs-built_in>ArrayBuffer</span>(bytes.length)
  <span class=hljs-keyword>const</span> ia = <span class=hljs-keyword>new</span> <span class=hljs-built_in>Uint8Array</span>(ab)
  <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> i = <span class=hljs-number>0</span>; i &lt; bytes.length; i++) {
    ia[i] = bytes.charCodeAt(i)
  }
  <span class=hljs-keyword>let</span> files = self.blobToFile(<span class=hljs-keyword>new</span> Blob([ab], { <span class=hljs-attr>type</span>: <span class=hljs-string>'png'</span> }), <span class=hljs-string>'post'</span>)
  <span class=hljs-keyword>let</span> formData = <span class=hljs-keyword>new</span> FormData()
  formData.append(<span class=hljs-string>"file"</span>, files, <span class=hljs-string>`myPost-<span class=hljs-subst>${<span class=hljs-keyword>new</span> <span class=hljs-built_in>Date</span>().getTime()}</span>.png`</span>);
  self.$http.post(config.fileUploadURL, formData, {
    <span class=hljs-attr>headers</span>: {
      <span class=hljs-string>'Content-Type'</span>: <span class=hljs-string>'multipart/form-data'</span>
    }
  }).then (<span class=hljs-function><span class=hljs-params>uploadRes</span> =></span> {
    <span class=hljs-keyword>if</span> (uploadRes.data.code === <span class=hljs-number>200</span>) {
      self.imageBase = uploadRes.data.url
    }
  })</code></pre> <pre><code class=language-javascript>  <span class=hljs-comment>// blob图片转为文件的函数</span>
  blobToFile (theBlob, fileName){
    theBlob.lastModifiedDate = <span class=hljs-keyword>new</span> <span class=hljs-built_in>Date</span>();
    theBlob.name = fileName;
    <span class=hljs-keyword>return</span> theBlob;
  }</code></pre> <h3 id=成品>成品</h3> <p>虽然国庆过了，但是还是贴出来哈哈。 <a href=http://xiaolu.ybj.com/wechat/html/gqyx/index.html target=_blank>活动</a></p> </div> <div class=my-8 id=vcomments></div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"2018\u002F10\u002Fh5-step.md",path:"2018\u002F10\u002Fh5-step",slug:"2018_10_h5-step",html:"\u003Ch3 id=\"时间\"\u003E时间\u003C\u002Fh3\u003E\n\u003Cp\u003E这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。\u003C\u002Fp\u003E\n\u003Ch3 id=\"使用框架\"\u003E使用框架\u003C\u002Fh3\u003E\n\u003Cp\u003E原本想直接了当用jQuery，毕竟用jQuery开发是真的快而且紧急情况可控。缺点是写起来会比较乱，维护也比较麻烦。但最后还是放弃，想尝试新的技术。最后试用了几套框架|库后，决定使用vux进行编写。\u003C\u002Fp\u003E\n\u003C!--more--\u003E\n\u003Ch3 id=\"vux\"\u003EVux\u003C\u002Fh3\u003E\n\u003Cp\u003E\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48887191-5af85100-ee69-11e8-84e9-fc534223e75b.png\" alt=\"tim 20181015093748\" \u003E\u003C\u002Fp\u003E\n\u003Cp\u003E使用原因：  \u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E使用vue-cli构建，几乎不用配置其余东西，内建命令让开发和打包生产版十分便捷。\u003C\u002Fli\u003E\n\u003Cli\u003Evux有大量组件而且github上有非常多的issue记录，遇到问题可以快速定位解决。\u003C\u002Fli\u003E\n\u003Cli\u003Evue生态给力，写起来舒舒服服。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Ch3 id=\"主要坑\"\u003E主要坑\u003C\u002Fh3\u003E\n\u003Cp\u003E由于第一次用vux写h5，难免会遇到不少问题，不仅是框架本身的问题，还有其他业务上需要攻克的问题。就记录下踩过的坑：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003Ebackground-image在部署的时候路径不对。\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E修改vue-cli的build文件夹下的utils.js为如下：\n\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48887225-7b281000-ee69-11e8-85a0-6e465667d9c4.png\" alt=\"util\" \u003E\u003C\u002Fp\u003E\n\u003Cp\u003E这样在 CSS 中：background-image: url(&quot;.\u002Fassets\u002Fbg.jpg&quot;)，不管是在开发环境下还是在生产环境下，背景图都可以读出来\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E怎么生成图片并在微信端支持长按保存图片？  \u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E以前也做过类似的，但没做过微信支持长按保存图片的。首先当然是要用到将html转为canvas然后再考虑转为图片。\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E库：\u003Ca target='_blank'  href=\"https:\u002F\u002Fhtml2canvas.hertzen.com\u002Fdocumentation\"\u003Ehtml2canvas\u003C\u002Fa\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E用法非常简单，指定挂载的元素进行转化。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Ehtml2canvas(\u003Cspan class=\"hljs-built_in\"\u003Edocument\u003C\u002Fspan\u003E.body).then(\u003Cspan class=\"hljs-function\"\u003E(\u003Cspan class=\"hljs-params\"\u003Ecanvas\u003C\u002Fspan\u003E) =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(canvas);    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这个是生成的canvas\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E base64Code = canvas.toDataURL(\u003Cspan class=\"hljs-string\"\u003E\"image\u002Fpng\"\u003C\u002Fspan\u003E);    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F将生成的canvas通过api`toDataURL`转为base64格式图片。\u003C\u002Fspan\u003E\n});\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cul\u003E\n\u003Cli\u003E怎么保存图片？\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E不是已经生成图片了吗？生成就可以可以保存了。没错，但是业务问题，在生成的图片上还要包含可点击的按钮和一个超链接。可以想到，可以将按钮和超链接定位到生成的图片上。可是存在这样的问题，不同的移动端呈现的结果可能不一致，这会直接导致页面显示出现问题，进而影响使用体验。这种覆盖的想法最后放弃了。\u003C\u002Fp\u003E\n\u003Cp\u003E最后的做法：将生成的图片的透明度设置为0覆盖到原本要渲染的元素上，然后提高可点击按钮的层级。\n\u003Cimg align=\"center\" style=\"width: 100%;\" data-zoomable src=\"https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48887259-95fa8480-ee69-11e8-8564-ddbccc8f1e26.png\" alt=\"tim 20181015100607\" \u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E存在无法分享到朋友圈的问题\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E微信浏览器唤起的分享菜单，存在点击分享到朋友圈出现卡死问题。\n排查过程： 在页面操作第一步和第二步都不会有这个问题，在生成图片的第三步就出现无法分享的问题。在想是不是生成图片太大了导致太卡顿了？在开发调试过程，打开vue开发工具查看第三步data的时候，发现非常卡顿。这样就可以认定是图片造成的卡顿了。\u003C\u002Fp\u003E\n\u003Cp\u003E最后找到的原因：canvas生成的base64编码的图片码十分长，直接导致vue处理的时候出现卡顿严重进而影响页面分享效果。最后的解决方案：将base64转为file上传，最后展示返回的url图片。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E base64Code = canvas.toDataURL(\u003Cspan class=\"hljs-string\"\u003E\"image\u002Fpng\"\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 去掉url的头，并转换为byte。以下步骤生成JavaScript blob文件\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E bytes = \u003Cspan class=\"hljs-built_in\"\u003Ewindow\u003C\u002Fspan\u003E.atob(base64Code.split(\u003Cspan class=\"hljs-string\"\u003E','\u003C\u002Fspan\u003E)[\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E])\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E ab = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EArrayBuffer\u003C\u002Fspan\u003E(bytes.length)\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E ia = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EUint8Array\u003C\u002Fspan\u003E(ab)\n  \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E i = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E; i &lt; bytes.length; i++) {\n    ia[i] = bytes.charCodeAt(i)\n  }\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E files = self.blobToFile(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E Blob([ab], { \u003Cspan class=\"hljs-attr\"\u003Etype\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'png'\u003C\u002Fspan\u003E }), \u003Cspan class=\"hljs-string\"\u003E'post'\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E formData = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E FormData()\n  formData.append(\u003Cspan class=\"hljs-string\"\u003E\"file\"\u003C\u002Fspan\u003E, files, \u003Cspan class=\"hljs-string\"\u003E`myPost-\u003Cspan class=\"hljs-subst\"\u003E${\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EDate\u003C\u002Fspan\u003E().getTime()}\u003C\u002Fspan\u003E.png`\u003C\u002Fspan\u003E);\n  self.$http.post(config.fileUploadURL, formData, {\n    \u003Cspan class=\"hljs-attr\"\u003Eheaders\u003C\u002Fspan\u003E: {\n      \u003Cspan class=\"hljs-string\"\u003E'Content-Type'\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'multipart\u002Fform-data'\u003C\u002Fspan\u003E\n    }\n  }).then (\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003EuploadRes\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (uploadRes.data.code === \u003Cspan class=\"hljs-number\"\u003E200\u003C\u002Fspan\u003E) {\n      self.imageBase = uploadRes.data.url\n    }\n  })\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F blob图片转为文件的函数\u003C\u002Fspan\u003E\n  blobToFile (theBlob, fileName){\n    theBlob.lastModifiedDate = \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003EDate\u003C\u002Fspan\u003E();\n    theBlob.name = fileName;\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E theBlob;\n  }\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3 id=\"成品\"\u003E成品\u003C\u002Fh3\u003E\n\u003Cp\u003E虽然国庆过了，但是还是贴出来哈哈。\n\u003Ca target='_blank'  href=\"http:\u002F\u002Fxiaolu.ybj.com\u002Fwechat\u002Fhtml\u002Fgqyx\u002Findex.html\"\u003E活动\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n",fmData:{attributes:{title:"一次h5开发踩坑记录",description:"这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。",keywords:"h5,踩坑,vue,vux",labels:["前端"],date:"2018-10-15T00:00:00.000Z"},body:"### 时间\n这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。\n\n### 使用框架\n\n原本想直接了当用jQuery，毕竟用jQuery开发是真的快而且紧急情况可控。缺点是写起来会比较乱，维护也比较麻烦。但最后还是放弃，想尝试新的技术。最后试用了几套框架|库后，决定使用vux进行编写。\n\u003C!--more--\u003E\n### Vux\n![tim 20181015093748](https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48887191-5af85100-ee69-11e8-84e9-fc534223e75b.png)\n\n使用原因：  \n\n1. 使用vue-cli构建，几乎不用配置其余东西，内建命令让开发和打包生产版十分便捷。\n2. vux有大量组件而且github上有非常多的issue记录，遇到问题可以快速定位解决。\n3. vue生态给力，写起来舒舒服服。\n\n### 主要坑\n\n由于第一次用vux写h5，难免会遇到不少问题，不仅是框架本身的问题，还有其他业务上需要攻克的问题。就记录下踩过的坑：\n\n- background-image在部署的时候路径不对。\n\n修改vue-cli的build文件夹下的utils.js为如下：\n![util](https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48887225-7b281000-ee69-11e8-85a0-6e465667d9c4.png)\n\n这样在 CSS 中：background-image: url(\".\u002Fassets\u002Fbg.jpg\")，不管是在开发环境下还是在生产环境下，背景图都可以读出来\n\n- 怎么生成图片并在微信端支持长按保存图片？  \n\n以前也做过类似的，但没做过微信支持长按保存图片的。首先当然是要用到将html转为canvas然后再考虑转为图片。\n\n1. 库：[html2canvas](https:\u002F\u002Fhtml2canvas.hertzen.com\u002Fdocumentation)\n2. 用法非常简单，指定挂载的元素进行转化。\n\n```javascript\nhtml2canvas(document.body).then((canvas) =\u003E {\n    console.log(canvas);    \u002F\u002F 这个是生成的canvas\n    const base64Code = canvas.toDataURL(\"image\u002Fpng\");    \u002F\u002F将生成的canvas通过api`toDataURL`转为base64格式图片。\n});\n```\n\n- 怎么保存图片？\n\n不是已经生成图片了吗？生成就可以可以保存了。没错，但是业务问题，在生成的图片上还要包含可点击的按钮和一个超链接。可以想到，可以将按钮和超链接定位到生成的图片上。可是存在这样的问题，不同的移动端呈现的结果可能不一致，这会直接导致页面显示出现问题，进而影响使用体验。这种覆盖的想法最后放弃了。\n\n最后的做法：将生成的图片的透明度设置为0覆盖到原本要渲染的元素上，然后提高可点击按钮的层级。\n![tim 20181015100607](https:\u002F\u002Fuser-images.githubusercontent.com\u002F21136420\u002F48887259-95fa8480-ee69-11e8-8564-ddbccc8f1e26.png)\n\n- 存在无法分享到朋友圈的问题\n\n微信浏览器唤起的分享菜单，存在点击分享到朋友圈出现卡死问题。\n排查过程： 在页面操作第一步和第二步都不会有这个问题，在生成图片的第三步就出现无法分享的问题。在想是不是生成图片太大了导致太卡顿了？在开发调试过程，打开vue开发工具查看第三步data的时候，发现非常卡顿。这样就可以认定是图片造成的卡顿了。\n\n最后找到的原因：canvas生成的base64编码的图片码十分长，直接导致vue处理的时候出现卡顿严重进而影响页面分享效果。最后的解决方案：将base64转为file上传，最后展示返回的url图片。\n```javascript\n  const base64Code = canvas.toDataURL(\"image\u002Fpng\")\n  \u002F\u002F 去掉url的头，并转换为byte。以下步骤生成JavaScript blob文件\n  const bytes = window.atob(base64Code.split(',')[1])\n  const ab = new ArrayBuffer(bytes.length)\n  const ia = new Uint8Array(ab)\n  for (let i = 0; i \u003C bytes.length; i++) {\n    ia[i] = bytes.charCodeAt(i)\n  }\n  let files = self.blobToFile(new Blob([ab], { type: 'png' }), 'post')\n  let formData = new FormData()\n  formData.append(\"file\", files, `myPost-${new Date().getTime()}.png`);\n  self.$http.post(config.fileUploadURL, formData, {\n    headers: {\n      'Content-Type': 'multipart\u002Fform-data'\n    }\n  }).then (uploadRes =\u003E {\n    if (uploadRes.data.code === 200) {\n      self.imageBase = uploadRes.data.url\n    }\n  })\n```\n```javascript\n  \u002F\u002F blob图片转为文件的函数\n  blobToFile (theBlob, fileName){\n    theBlob.lastModifiedDate = new Date();\n    theBlob.name = fileName;\n    return theBlob;\n  }\n```\n### 成品\n虽然国庆过了，但是还是贴出来哈哈。\n[活动](http:\u002F\u002Fxiaolu.ybj.com\u002Fwechat\u002Fhtml\u002Fgqyx\u002Findex.html)",bodyBegin:9,frontmatter:"title: 一次h5开发踩坑记录\ndescription: 这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。\nkeywords: h5,踩坑,vue,vux\nlabels: ['前端']\ndate: 2018-10-15"}}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.34d3e2bd.js"}catch(e){main="/client/legacy/client.9a4bf57e.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1" async></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 