<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <link href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css rel=stylesheet> <link href=client/main.250686488.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>用sapper构建一个博客</title><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-1wr5yce><ul class=svelte-1wr5yce> <li class=svelte-1wr5yce><a href=blog aria-current=page class=svelte-1wr5yce rel=prefetch>blog</a></ul></nav> <main class=svelte-iwmse4> <div class="content svelte-1dlbxyy"><h1 id=用sapper构建一个博客>用sapper构建一个博客</h1> <p>发现自己好久没有写博客了。之前在github开了一个仓库，在仓库的<a href=https://github.com/GzhiYi/blog/issues>issue区</a>写一些内容。issue区体验挺好的，可以refer上项目代码，也可以追加评论。但我想自己写一个博客，不需要很多花里胡哨的功能，只对内容专注，极大的好处是，可以随心所欲的编写自己喜欢的页面样式。刚好最近有接触了下<a href=https://svelte.dev/ >svelte</a>，就顺带的用<a href=https://sapper.svelte.dev/ >sapper</a>写一个静态页面。</p> <p>实现需要用到的知识点/技术：</p> <ol> <li>svelte</li> <li>sapper</li> <li>tailwindcss</li> <li>typescript</li> </ol> <p>后面两点非必须，可以根据自己需要进行增减。</p> <h2 id=思路>思路</h2> <p>整体的思路比较简单。</p> <p>sapper支持export出静态文件，我只需要将静态文件部署到一个静态站点，首选的就是github pages。sapper导出export有一个好处：</p> <blockquote> <p>Static doesn't mean non-interactive — your Svelte components work exactly as they do normally, and you still get all the benefits of client-side routing and prefetching.</p> </blockquote> <p>sapper默认的template就是一个blog，这不是刚好可以拿来起手嘛！但默认的template的 blog内容是固定的数据，大致内容是一个js文件，export一个blog的array。</p> <pre><code class=language-javascript><span class=hljs-keyword>export</span> <span class=hljs-keyword>const</span> [
  {
    <span class=hljs-attr>title</span>: <span class=hljs-string>'2020-06/build-blog.md'</span>,
    <span class=hljs-attr>slug</span>: <span class=hljs-string>'2020-06_build-blog'</span>, <span class=hljs-comment>// 生成的路由路径</span>
    <span class=hljs-attr>html</span>: <span class=hljs-string>'&lt;h1 id=\"用sapper构建一个博客\">用sapper构建一个博客&lt;/h1>'</span>
  }
]</code></pre> <p>在sapper export之后，可以在<code>__sapper__/export/blog</code>看到生成html静态文件。也就意味着最后需要部署到github pages的目录，就是<code>__sapper__</code>目录啦。</p> <p><strong>可如果要写博客，那肯定也优先选择Markdown。</strong></p> <p>所以需要解决的也就是将Markdown文件转为上面提到的js文件。</p> <h2 id=将markdown转为js文件>将Markdown转为js文件</h2> <p>需要用到<a href=https://github.com/markedjs/marked>Markedjs</a>。</p> <p>使用也是简单粗暴：</p> <pre><code class=language-javascript><span class=hljs-keyword>const</span> marked = <span class=hljs-built_in>require</span>(<span class=hljs-string>'marked'</span>)
marked.setOptions({
  <span class=hljs-attr>renderer</span>: <span class=hljs-keyword>new</span> marked.Renderer(),
  <span class=hljs-attr>highlight</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>code, language</span>) </span>{
    <span class=hljs-keyword>const</span> hljs = <span class=hljs-built_in>require</span>(<span class=hljs-string>'highlight.js'</span>)
    <span class=hljs-keyword>const</span> validLanguage = hljs.getLanguage(language) ? language : <span class=hljs-string>'plaintext'</span>
    <span class=hljs-keyword>return</span> hljs.highlight(validLanguage, code).value
  },
  <span class=hljs-comment>// ...(more options)</span>
});
marked(markdownString)</code></pre> <p>例如markdownString为：</p> <pre><code>*hello world*</code></pre> <p>将会被转为：</p> <pre><code class=language-html><span class=hljs-tag>&lt;<span class=hljs-name>p</span>></span><span class=hljs-tag>&lt;<span class=hljs-name>em</span>></span>hello world<span class=hljs-tag>&lt;/<span class=hljs-name>em</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>p</span>></span></code></pre> <p>知道用法之后，只需要通过fs文件操作，将目标的Markdown文件全部push进一个数组，最后将数组写入一个js文件。</p> <h2 id=读取markdown并写入文件>读取Markdown并写入文件</h2> <p>node对操作文件提供了<code>readir</code>、<code>readFile</code>、<code>writeFile</code>等函数。</p> <p>其中核心的处理逻辑如下：</p> <pre><code class=language-javascript><span class=hljs-comment>// 获取所有文件</span>
<span class=hljs-keyword>const</span> getAllFiles = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>dirPath, arrayOfFiles</span>) </span>{
    files = fs.readdirSync(dirPath)
    arrayOfFiles = arrayOfFiles || []
    files.forEach(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>file</span>) </span>{
        <span class=hljs-keyword>if</span> (fs.statSync(dirPath + <span class=hljs-string>"/"</span> + file).isDirectory()) {
            arrayOfFiles = getAllFiles(dirPath + <span class=hljs-string>"/"</span> + file, arrayOfFiles)
        } <span class=hljs-keyword>else</span> {
            arrayOfFiles.push(path.join(dirPath, <span class=hljs-string>"/"</span>, file))
        }
    })
    <span class=hljs-keyword>return</span> arrayOfFiles
}
<span class=hljs-comment>// 将markdown转为js文件</span>
<span class=hljs-keyword>const</span> compile = <span class=hljs-function><span class=hljs-params>()</span> =></span> {
    <span class=hljs-keyword>try</span> {
        <span class=hljs-keyword>const</span> dirs = getAllFiles(<span class=hljs-string>'./'</span>) <span class=hljs-comment>// 读取所有文件</span>
        <span class=hljs-keyword>const</span> inPosts = [] <span class=hljs-comment>// 文章数组</span>
        <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> fileName <span class=hljs-keyword>of</span> dirs) {
            <span class=hljs-keyword>if</span> (<span class=hljs-regexp>/.md/</span>.test(fileName)) {
                <span class=hljs-keyword>const</span> fileData = fs.readFileSync(<span class=hljs-string>`./<span class=hljs-subst>${fileName}</span>`</span>, <span class=hljs-string>'utf-8'</span>) <span class=hljs-comment>// markdown内容</span>
                <span class=hljs-keyword>const</span> fmData = fm(fileData) <span class=hljs-comment>// 此处可以忽略fm（fm是处理markdown front matter的，可有可无）</span>
                <span class=hljs-keyword>const</span> rmSuffix = fileName.split(<span class=hljs-string>'.'</span>)[<span class=hljs-number>0</span>] <span class=hljs-comment>// 移除文件名后缀</span>
                inPosts.push({
                    <span class=hljs-attr>title</span>: fileName,
                    <span class=hljs-attr>path</span>: rmSuffix,
                    <span class=hljs-attr>slug</span>: rmSuffix.replace(<span class=hljs-string>'/'</span>, <span class=hljs-string>'_'</span>),
                    <span class=hljs-attr>html</span>: marked(fmData.body),
                    fmData
                })
            }
        }
        inPosts.forEach(<span class=hljs-function><span class=hljs-params>post</span> =></span> {
            post.html = post.html.replace(<span class=hljs-regexp>/^\t{3}/gm</span>, <span class=hljs-string>''</span>);
        });
        <span class=hljs-keyword>const</span> outPutContent = <span class=hljs-string>`export default <span class=hljs-subst>${<span class=hljs-built_in>JSON</span>.stringify(inPosts)}</span>`</span>
        fs.writeFile(<span class=hljs-string>'../routes/blog/_posts.js'</span>, outPutContent, err => {
            <span class=hljs-keyword>if</span> (err) <span class=hljs-keyword>return</span> <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'生成post失败'</span>, err)
            <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'已生成_posts.js'</span>)
        })
    } <span class=hljs-keyword>catch</span> (error) {
        <span class=hljs-built_in>console</span>.error(<span class=hljs-string>'error'</span>, error)
    }
}
<span class=hljs-keyword>const</span> watcher = chokidar.watch(<span class=hljs-string>'./'</span>)
watcher
    .on(<span class=hljs-string>'all'</span>, () => {
        compile()
    })</code></pre> <h1 id=部署到github-pages>部署到github pages</h1> <p>对于sapper，执行export命令生成静态文件。</p> <pre><code class=language-bash>npm run <span class=hljs-built_in>export</span></code></pre> <p>将<code>__sapper__/export</code>推送到仓库的gh-pages分支。</p> <pre><code class=language-bash>git subtree push --prefix __sapper__/<span class=hljs-built_in>export</span> origin gh-pages</code></pre> <p>最后在仓库设置出将gh-pages分支设置为部署分支就好了。</p> <p>以上完成了从写Markdown到可以看到文章，后续页面的编写就可以随心所欲啦！</p> </div> <div id=gitalk-container></div></main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"2020-06\u002Fbuild-blog.md",path:"2020-06\u002Fbuild-blog",slug:"2020-06_build-blog",html:"\u003Ch1 id=\"用sapper构建一个博客\"\u003E用sapper构建一个博客\u003C\u002Fh1\u003E\n\u003Cp\u003E发现自己好久没有写博客了。之前在github开了一个仓库，在仓库的\u003Ca href=\"https:\u002F\u002Fgithub.com\u002FGzhiYi\u002Fblog\u002Fissues\"\u003Eissue区\u003C\u002Fa\u003E写一些内容。issue区体验挺好的，可以refer上项目代码，也可以追加评论。但我想自己写一个博客，不需要很多花里胡哨的功能，只对内容专注，极大的好处是，可以随心所欲的编写自己喜欢的页面样式。刚好最近有接触了下\u003Ca href=\"https:\u002F\u002Fsvelte.dev\u002F\"\u003Esvelte\u003C\u002Fa\u003E，就顺带的用\u003Ca href=\"https:\u002F\u002Fsapper.svelte.dev\u002F\"\u003Esapper\u003C\u002Fa\u003E写一个静态页面。\u003C\u002Fp\u003E\n\u003Cp\u003E实现需要用到的知识点\u002F技术：\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003Esvelte\u003C\u002Fli\u003E\n\u003Cli\u003Esapper\u003C\u002Fli\u003E\n\u003Cli\u003Etailwindcss\u003C\u002Fli\u003E\n\u003Cli\u003Etypescript\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E后面两点非必须，可以根据自己需要进行增减。\u003C\u002Fp\u003E\n\u003Ch2 id=\"思路\"\u003E思路\u003C\u002Fh2\u003E\n\u003Cp\u003E整体的思路比较简单。\u003C\u002Fp\u003E\n\u003Cp\u003Esapper支持export出静态文件，我只需要将静态文件部署到一个静态站点，首选的就是github pages。sapper导出export有一个好处：\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EStatic doesn&#39;t mean non-interactive — your Svelte components work exactly as they do normally, and you still get all the benefits of client-side routing and prefetching.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003Esapper默认的template就是一个blog，这不是刚好可以拿来起手嘛！但默认的template的 blog内容是固定的数据，大致内容是一个js文件，export一个blog的array。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E [\n  {\n    \u003Cspan class=\"hljs-attr\"\u003Etitle\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'2020-06\u002Fbuild-blog.md'\u003C\u002Fspan\u003E,\n    \u003Cspan class=\"hljs-attr\"\u003Eslug\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'2020-06_build-blog'\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 生成的路由路径\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-attr\"\u003Ehtml\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E'&lt;h1 id=\\\"用sapper构建一个博客\\\"&gt;用sapper构建一个博客&lt;\u002Fh1&gt;'\u003C\u002Fspan\u003E\n  }\n]\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在sapper export之后，可以在\u003Ccode\u003E__sapper__\u002Fexport\u002Fblog\u003C\u002Fcode\u003E看到生成html静态文件。也就意味着最后需要部署到github pages的目录，就是\u003Ccode\u003E__sapper__\u003C\u002Fcode\u003E目录啦。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E可如果要写博客，那肯定也优先选择Markdown。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E所以需要解决的也就是将Markdown文件转为上面提到的js文件。\u003C\u002Fp\u003E\n\u003Ch2 id=\"将markdown转为js文件\"\u003E将Markdown转为js文件\u003C\u002Fh2\u003E\n\u003Cp\u003E需要用到\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fmarkedjs\u002Fmarked\"\u003EMarkedjs\u003C\u002Fa\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E使用也是简单粗暴：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E marked = \u003Cspan class=\"hljs-built_in\"\u003Erequire\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E'marked'\u003C\u002Fspan\u003E)\nmarked.setOptions({\n  \u003Cspan class=\"hljs-attr\"\u003Erenderer\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E marked.Renderer(),\n  \u003Cspan class=\"hljs-attr\"\u003Ehighlight\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Ecode, language\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E hljs = \u003Cspan class=\"hljs-built_in\"\u003Erequire\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-string\"\u003E'highlight.js'\u003C\u002Fspan\u003E)\n    \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E validLanguage = hljs.getLanguage(language) ? language : \u003Cspan class=\"hljs-string\"\u003E'plaintext'\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E hljs.highlight(validLanguage, code).value\n  },\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F ...(more options)\u003C\u002Fspan\u003E\n});\nmarked(markdownString)\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E例如markdownString为：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E*hello world*\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E将会被转为：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Eem\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003Ehello world\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Eem\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E知道用法之后，只需要通过fs文件操作，将目标的Markdown文件全部push进一个数组，最后将数组写入一个js文件。\u003C\u002Fp\u003E\n\u003Ch2 id=\"读取markdown并写入文件\"\u003E读取Markdown并写入文件\u003C\u002Fh2\u003E\n\u003Cp\u003Enode对操作文件提供了\u003Ccode\u003Ereadir\u003C\u002Fcode\u003E、\u003Ccode\u003EreadFile\u003C\u002Fcode\u003E、\u003Ccode\u003EwriteFile\u003C\u002Fcode\u003E等函数。\u003C\u002Fp\u003E\n\u003Cp\u003E其中核心的处理逻辑如下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 获取所有文件\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E getAllFiles = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003EdirPath, arrayOfFiles\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    files = fs.readdirSync(dirPath)\n    arrayOfFiles = arrayOfFiles || []\n    files.forEach(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-params\"\u003Efile\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n        \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (fs.statSync(dirPath + \u003Cspan class=\"hljs-string\"\u003E\"\u002F\"\u003C\u002Fspan\u003E + file).isDirectory()) {\n            arrayOfFiles = getAllFiles(dirPath + \u003Cspan class=\"hljs-string\"\u003E\"\u002F\"\u003C\u002Fspan\u003E + file, arrayOfFiles)\n        } \u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E {\n            arrayOfFiles.push(path.join(dirPath, \u003Cspan class=\"hljs-string\"\u003E\"\u002F\"\u003C\u002Fspan\u003E, file))\n        }\n    })\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E arrayOfFiles\n}\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 将markdown转为js文件\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E compile = \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Etry\u003C\u002Fspan\u003E {\n        \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E dirs = getAllFiles(\u003Cspan class=\"hljs-string\"\u003E'.\u002F'\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 读取所有文件\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E inPosts = [] \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 文章数组\u003C\u002Fspan\u003E\n        \u003Cspan class=\"hljs-keyword\"\u003Efor\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E fileName \u003Cspan class=\"hljs-keyword\"\u003Eof\u003C\u002Fspan\u003E dirs) {\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (\u003Cspan class=\"hljs-regexp\"\u003E\u002F.md\u002F\u003C\u002Fspan\u003E.test(fileName)) {\n                \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E fileData = fs.readFileSync(\u003Cspan class=\"hljs-string\"\u003E`.\u002F\u003Cspan class=\"hljs-subst\"\u003E${fileName}\u003C\u002Fspan\u003E`\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E'utf-8'\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F markdown内容\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E fmData = fm(fileData) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 此处可以忽略fm（fm是处理markdown front matter的，可有可无）\u003C\u002Fspan\u003E\n                \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E rmSuffix = fileName.split(\u003Cspan class=\"hljs-string\"\u003E'.'\u003C\u002Fspan\u003E)[\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E] \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 移除文件名后缀\u003C\u002Fspan\u003E\n                inPosts.push({\n                    \u003Cspan class=\"hljs-attr\"\u003Etitle\u003C\u002Fspan\u003E: fileName,\n                    \u003Cspan class=\"hljs-attr\"\u003Epath\u003C\u002Fspan\u003E: rmSuffix,\n                    \u003Cspan class=\"hljs-attr\"\u003Eslug\u003C\u002Fspan\u003E: rmSuffix.replace(\u003Cspan class=\"hljs-string\"\u003E'\u002F'\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E'_'\u003C\u002Fspan\u003E),\n                    \u003Cspan class=\"hljs-attr\"\u003Ehtml\u003C\u002Fspan\u003E: marked(fmData.body),\n                    fmData\n                })\n            }\n        }\n        inPosts.forEach(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Epost\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E {\n            post.html = post.html.replace(\u003Cspan class=\"hljs-regexp\"\u003E\u002F^\\t{3}\u002Fgm\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-string\"\u003E''\u003C\u002Fspan\u003E);\n        });\n        \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E outPutContent = \u003Cspan class=\"hljs-string\"\u003E`export default \u003Cspan class=\"hljs-subst\"\u003E${\u003Cspan class=\"hljs-built_in\"\u003EJSON\u003C\u002Fspan\u003E.stringify(inPosts)}\u003C\u002Fspan\u003E`\u003C\u002Fspan\u003E\n        fs.writeFile(\u003Cspan class=\"hljs-string\"\u003E'..\u002Froutes\u002Fblog\u002F_posts.js'\u003C\u002Fspan\u003E, outPutContent, err =&gt; {\n            \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E (err) \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\u003Cspan class=\"hljs-string\"\u003E'生成post失败'\u003C\u002Fspan\u003E, err)\n            \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\u003Cspan class=\"hljs-string\"\u003E'已生成_posts.js'\u003C\u002Fspan\u003E)\n        })\n    } \u003Cspan class=\"hljs-keyword\"\u003Ecatch\u003C\u002Fspan\u003E (error) {\n        \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.error(\u003Cspan class=\"hljs-string\"\u003E'error'\u003C\u002Fspan\u003E, error)\n    }\n}\n\u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E watcher = chokidar.watch(\u003Cspan class=\"hljs-string\"\u003E'.\u002F'\u003C\u002Fspan\u003E)\nwatcher\n    .on(\u003Cspan class=\"hljs-string\"\u003E'all'\u003C\u002Fspan\u003E, () =&gt; {\n        compile()\n    })\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch1 id=\"部署到github-pages\"\u003E部署到github pages\u003C\u002Fh1\u003E\n\u003Cp\u003E对于sapper，执行export命令生成静态文件。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Enpm run \u003Cspan class=\"hljs-built_in\"\u003Eexport\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E将\u003Ccode\u003E__sapper__\u002Fexport\u003C\u002Fcode\u003E推送到仓库的gh-pages分支。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-bash\"\u003Egit subtree push --prefix __sapper__\u002F\u003Cspan class=\"hljs-built_in\"\u003Eexport\u003C\u002Fspan\u003E origin gh-pages\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E最后在仓库设置出将gh-pages分支设置为部署分支就好了。\u003C\u002Fp\u003E\n\u003Cp\u003E以上完成了从写Markdown到可以看到文章，后续页面的编写就可以随心所欲啦！\u003C\u002Fp\u003E\n",fmData:{attributes:{title:"用sapper构建一个博客",date:"2020-06-20T00:00:00.000Z"},body:"# 用sapper构建一个博客\n\n发现自己好久没有写博客了。之前在github开了一个仓库，在仓库的[issue区](https:\u002F\u002Fgithub.com\u002FGzhiYi\u002Fblog\u002Fissues)写一些内容。issue区体验挺好的，可以refer上项目代码，也可以追加评论。但我想自己写一个博客，不需要很多花里胡哨的功能，只对内容专注，极大的好处是，可以随心所欲的编写自己喜欢的页面样式。刚好最近有接触了下[svelte](https:\u002F\u002Fsvelte.dev\u002F)，就顺带的用[sapper](https:\u002F\u002Fsapper.svelte.dev\u002F)写一个静态页面。\n\n实现需要用到的知识点\u002F技术：\n\n1. svelte\n2. sapper\n3. tailwindcss\n4. typescript\n\n后面两点非必须，可以根据自己需要进行增减。\n\n## 思路\n整体的思路比较简单。\n\nsapper支持export出静态文件，我只需要将静态文件部署到一个静态站点，首选的就是github pages。sapper导出export有一个好处：\n\n\u003E Static doesn't mean non-interactive — your Svelte components work exactly as they do normally, and you still get all the benefits of client-side routing and prefetching.\n\nsapper默认的template就是一个blog，这不是刚好可以拿来起手嘛！但默认的template的 blog内容是固定的数据，大致内容是一个js文件，export一个blog的array。\n\n```javascript\nexport const [\n  {\n    title: '2020-06\u002Fbuild-blog.md',\n    slug: '2020-06_build-blog', \u002F\u002F 生成的路由路径\n    html: '\u003Ch1 id=\\\"用sapper构建一个博客\\\"\u003E用sapper构建一个博客\u003C\u002Fh1\u003E'\n  }\n]\n```\n\n在sapper export之后，可以在`__sapper__\u002Fexport\u002Fblog`看到生成html静态文件。也就意味着最后需要部署到github pages的目录，就是`__sapper__`目录啦。\n\n**可如果要写博客，那肯定也优先选择Markdown。**\n\n所以需要解决的也就是将Markdown文件转为上面提到的js文件。\n\n## 将Markdown转为js文件\n\n需要用到[Markedjs](https:\u002F\u002Fgithub.com\u002Fmarkedjs\u002Fmarked)。\n\n使用也是简单粗暴：\n\n```javascript\nconst marked = require('marked')\nmarked.setOptions({\n  renderer: new marked.Renderer(),\n  highlight: function(code, language) {\n    const hljs = require('highlight.js')\n    const validLanguage = hljs.getLanguage(language) ? language : 'plaintext'\n    return hljs.highlight(validLanguage, code).value\n  },\n  \u002F\u002F ...(more options)\n});\nmarked(markdownString)\n```\n\n例如markdownString为：\n\n```\n*hello world*\n```\n\n将会被转为：\n\n```html\n\u003Cp\u003E\u003Cem\u003Ehello world\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n```\n\n知道用法之后，只需要通过fs文件操作，将目标的Markdown文件全部push进一个数组，最后将数组写入一个js文件。\n\n## 读取Markdown并写入文件\n\nnode对操作文件提供了`readir`、`readFile`、`writeFile`等函数。\n\n其中核心的处理逻辑如下：\n\n```javascript\n\u002F\u002F 获取所有文件\nconst getAllFiles = function (dirPath, arrayOfFiles) {\n\tfiles = fs.readdirSync(dirPath)\n\tarrayOfFiles = arrayOfFiles || []\n\tfiles.forEach(function (file) {\n\t\tif (fs.statSync(dirPath + \"\u002F\" + file).isDirectory()) {\n\t\t\tarrayOfFiles = getAllFiles(dirPath + \"\u002F\" + file, arrayOfFiles)\n\t\t} else {\n\t\t\tarrayOfFiles.push(path.join(dirPath, \"\u002F\", file))\n\t\t}\n\t})\n\treturn arrayOfFiles\n}\n\u002F\u002F 将markdown转为js文件\nconst compile = () =\u003E {\n\ttry {\n\t\tconst dirs = getAllFiles('.\u002F') \u002F\u002F 读取所有文件\n\t\tconst inPosts = [] \u002F\u002F 文章数组\n\t\tfor (let fileName of dirs) {\n\t\t\tif (\u002F.md\u002F.test(fileName)) {\n\t\t\t\tconst fileData = fs.readFileSync(`.\u002F${fileName}`, 'utf-8') \u002F\u002F markdown内容\n\t\t\t\tconst fmData = fm(fileData) \u002F\u002F 此处可以忽略fm（fm是处理markdown front matter的，可有可无）\n\t\t\t\tconst rmSuffix = fileName.split('.')[0] \u002F\u002F 移除文件名后缀\n\t\t\t\tinPosts.push({\n\t\t\t\t\ttitle: fileName,\n\t\t\t\t\tpath: rmSuffix,\n\t\t\t\t\tslug: rmSuffix.replace('\u002F', '_'),\n\t\t\t\t\thtml: marked(fmData.body),\n\t\t\t\t\tfmData\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tinPosts.forEach(post =\u003E {\n\t\t\tpost.html = post.html.replace(\u002F^\\t{3}\u002Fgm, '');\n\t\t});\n\t\tconst outPutContent = `export default ${JSON.stringify(inPosts)}`\n\t\tfs.writeFile('..\u002Froutes\u002Fblog\u002F_posts.js', outPutContent, err =\u003E {\n\t\t\tif (err) return console.log('生成post失败', err)\n\t\t\tconsole.log('已生成_posts.js')\n\t\t})\n\t} catch (error) {\n\t\tconsole.error('error', error)\n\t}\n}\nconst watcher = chokidar.watch('.\u002F')\nwatcher\n\t.on('all', () =\u003E {\n\t\tcompile()\n\t})\n```\n\n# 部署到github pages\n\n对于sapper，执行export命令生成静态文件。\n\n```bash\nnpm run export\n```\n\n将`__sapper__\u002Fexport`推送到仓库的gh-pages分支。\n\n```bash\ngit subtree push --prefix __sapper__\u002Fexport origin gh-pages\n```\n\n最后在仓库设置出将gh-pages分支设置为部署分支就好了。\n\n以上完成了从写Markdown到可以看到文章，后续页面的编写就可以随心所欲啦！",bodyBegin:6,frontmatter:"title: 用sapper构建一个博客\ndate: 2020-06-20"}}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.36f251c5.js"}catch(e){main="/client/legacy/client.1ee41c40.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script> 