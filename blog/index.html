<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=global.css rel=stylesheet> <link href=main.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <link href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css rel=stylesheet> <link href=client/main.3380611318.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>GzhiYi's blog</title><meta content=web前端工程师，编程是一份兴趣，热爱着生活。 name=description><meta content=frontend开发者，熟悉web前端，vue，React，svelte，小程序等等。 name=keywords><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-1wr5yce><ul class=svelte-1wr5yce> <li class=svelte-1wr5yce><a href=blog rel=prefetch aria-current=page class=svelte-1wr5yce>blog</a></ul></nav> <main class=svelte-iwmse4> <h1>Recent posts</h1> <ul class=svelte-1ect80f> <li><a href=blog/2020-06_firebase rel=prefetch>6/28/2020 用firebase给静态博客页面增加点赞功能 </a></li> <li><a href=blog/2020-06_apple-wwdc-2020 rel=prefetch>6/23/2020 2020年苹果开发者大会 </a></li> <li><a href=blog/2020-06_sapper-github-actions rel=prefetch>6/22/2020 使用github actions自动编译部署sapper-blog </a></li> <li><a href=blog/2020-06_eclipse rel=prefetch>6/21/2020 日环食 </a></li> <li><a href=blog/2020-06_build-blog rel=prefetch>6/20/2020 用sapper构建一个博客 </a></ul></main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,(function(a,b,c,d,e){return {posts:[{title:"2020-06\u002Ffirebase.md",path:"2020-06\u002Ffirebase",slug:"2020-06_firebase",fmData:{attributes:{title:c,description:c,keywords:"firebase,like",labels:[b],date:"2020-06-28T00:00:00.000Z"},body:"想给博客增加一个点赞功能。最后，看起来就是这样：\n\n![like](https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F28\u002FEj9in7gr5uNHIJO.jpg)\n\n实现这个功能要考虑几个问题：\n\n1. 没有服务器，接口怎么编写部署？\n2. 博客没有登录，数据库设计的时候怎么识别用户唯一性。\n\n## Firebase\n\n对于firebase的介绍，最好是直接进入[主站](https:\u002F\u002Ffirebase.google.com)开通spark版尝试。\n\n使用firebase，就可以很好的解决第一个问题。spark方案提供免费的空间支持，对于博客这种量级小，交互少的页面来说再适合不过了。\n\n如果用过tx云的云开发，就可以知道，其实概念有些相似，甚至在云函数的编写上也有几分相似。\n\n## fingerprintjs2\n\n利用[fingerprintjs2](https:\u002F\u002Fgithub.com\u002Ffingerprintjs\u002Ffingerprintjs2)，可以通过user agent等信息生成用户唯一的一个ID，虽然不能100%保证用户唯一性，但对于无需登录的博客而言，已经足够了。\n生成指纹的主要用法：\n\n```javascript\nFingerprint2.x64hash128(values.join(''), 31)\n```\n\n## 过程\n\n整个过程，时间大部分花在云函数执行数据库操作语法上。以下前提是开通了firebase的spark方案，开通方式直接明了就不赘述啦。\n\n### 控制台\n\n需要在控制台创建你的一个项目，创建好项目之后再执行下面的步骤。\n\n### 函数（functions）编写\n\n相关代码可以查看：[blog-like](https:\u002F\u002Fgithub.com\u002FGzhiYi\u002Fblog-like\u002Fblob\u002Fmaster\u002Ffunctions\u002Findex.js)\n\n1. 安装Firebase CLI工具以初始化函数仓库。\n\n```bash\nnpm install -g firebase-tools\n```\n2. 登录\n\n```bash\nfirebase login\n```\n\n3. 创建一个空目录，然后初始化这个目录，例如目录名为blog-like\n\n```bash\nmkdir blog-like && cd blog-like && firebase init\n```\n\n执行init命令后会提示选择新建项目的一些规则。（以下是规则过程）\n\n`q: Which Firebase CLI features do you want to set up for this folder? Press Space to select features, then Enter to confirm your choices.`\n`a: 选择Firestore: Deploy rules and create indexes for Firestore以及Functions: Configure and deploy Cloud Functions`  \n\n`q: Please select an option:`\n`a: Use an existing project，随后选择在控制台创建的项目。`\n\n随后几个按enter就好了。\n\n4. 函数编写。\n\n需要两个接口，一个是新增点赞接口，路由为：`\u002FnewLike`，一个是获取点赞数据的接口，路由为：`\u002FgetLikes`。\n\n - newLike。先判断该用户是否已经点过赞。需要存储的数据：文章标题、点赞时间、用户指纹。\n - getLikes。先获取该文章点赞总数，在判断用户是否已经点过赞。\n\n有了以下基本代码：\n\n点赞数据表：\n\n```json\n{\n    id: 用户指纹，\n    likeTime：点赞时间，\n    postTitle：文章标题\n}\n```\n\n\n\nnewLike，创建点赞数据：\n\n```javascript\ndb.collection('like')\n  .where(\"postTitle\", \"==\", request.body.title)\n  .get()\n  .then(res =\u003E {\n  let isLike = false\n  try {\n    \u002F\u002F 判断是否已经点赞过\n    res.forEach(doc =\u003E {\n      if (doc.id === request.body.id && !isLike) {\n        isLike = true\n      }\n    })\n    if (!isLike) {\n      let docRef = db.collection('like').doc(params.id);\n      docRef.set({\n        postTitle: params.title,\n        likeTime: new Date().toLocaleString()\n      });\n      response.send({\n        data: 'like success!',\n        code: 0\n      })\n    } else {\n      response.send({\n        data: '',\n        message: 'like 过啦',\n        code: 1\n      })\n    }\n  } catch (error) {\n    console.log('error', error)\n  }\n})\n```\n\ngetLikes，获取点赞数据：\n\n```javascript\ndb.collection('like')\n  .where(\"postTitle\", \"==\", title)\n  .get()\n  .then(res =\u003E {\n  let isLike = false\n  try {\n    res.forEach(doc =\u003E {\n      if (doc.id === id && !isLike) {\n        isLike = true\n      }\n    })\n  } catch (error) {\n    console.log('error', error)\n  }\n  response.send({\n    data: res.size,\n    isLike,\n    message: 'oooooooook',\n    code: 0\n  })\n})\n  .catch(error =\u003E {\n  response.send({\n    data: error,\n    message: request.body,\n    code: 1\n  })\n})\n```\n\n在函数编写之后，执行命令就可以部署到云端啦。\n\n```bash\nfirebase deploy --only functions\n```\n\n## 用户端\n\n在博客页面上生成用户唯一ID后用fetch请求点赞接口就可以了。\n\n另外，跨域问题需要函数端用上cors处理。详细的都可以在[仓库](https:\u002F\u002Fgithub.com\u002FGzhiYi\u002Fblog-like)看到。\n\n## 体验\n\n最后说一下体验。整个开发过程比较愉快，花了点点时间查阅数据库操作语法。上线尝试访问，发现google的果然访问好慢！\n\n你可以点击下面clap按钮试试，如果没有，说明网络问题，unreachable。",bodyBegin:a,frontmatter:"title: 用firebase给静态博客页面增加点赞功能\ndescription: 用firebase给静态博客页面增加点赞功能\nkeywords: firebase,like\nlabels: ['前端']\ndate: 2020-06-28"}},{title:"2020-06\u002Fapple-wwdc-2020.md",path:"2020-06\u002Fapple-wwdc-2020",slug:"2020-06_apple-wwdc-2020",fmData:{attributes:{title:"2020年苹果开发者大会",description:"2020 Apple Worldwide Developers Conference",keywords:"apple,2020,wwdc",labels:[d],date:"2020-06-23T00:00:00.000Z"},body:"昨晚苹果线上直播了2020年开发者大会。本次大会给了不少的东西出来。其中最引瞩目的就是宣布自研Mac ARM芯片，从Intel中跳出来。\n\n这是苹果想统一多平台下的一个大棋。在会之前就有不少的人分析arm架构的处理器会给市场带来什么影响。用户无需考虑太多，而开发者倒会更多的考虑开发兼容性的问题。\n\n## 苹果生态\n\n毫无疑问，苹果在生态上走的越来越靠拢，强化多平台优秀的体验拉拢了越来越多的用户。我个人觉得iOS很流畅，能稳定的运行不会忽然卡顿就已经很满足了。但也非常不喜欢苹果的一些缺失的功能。拿着超前的体验做着安卓好几年前就有的功能，不知道iOS开发的执行力是不是不够，但个别地方的体验真的不尽人意。短信不能未读提示，电量不足20%还强制弹窗提示...有好多地方在产品的设计上就有问题。\n\n后面接触了macOS，我常将它比作是ui更精致，系统更稳定的linux。开发体验非常好，从此告别了windows。windows在开发过程总会遇到不明不白的卡顿问题，terminal也总是让人觉得帧数很低不顺畅。还有一个很重要的优点就是macOS没有广告弹窗，这点就不得不吐槽windows下国产应用肆意妄为弹窗、捆绑了。未来会一直用macOS开发，总结一个词就是相见恨晚。\n\n![007S8ZIlgy1gg24hxohtfj31c00u07wn.jpg](https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F23\u002FAgv9hHwZI4eMyqT.jpg)\n\n新的macOS ui有了更新，图标改为了圆角矩形，和ipadOS、iOS越来越相似。个人觉得改动并不会丑，大概率又会是真香体验。\n\n",bodyBegin:a,frontmatter:"title: 2020年苹果开发者大会\ndescription: 2020 Apple Worldwide Developers Conference\nkeywords: apple,2020,wwdc\nlabels: ['随笔']\ndate: 2020-06-23"}},{title:"2020-06\u002Fsapper-github-actions.md",path:"2020-06\u002Fsapper-github-actions",slug:"2020-06_sapper-github-actions",fmData:{attributes:{title:"使用github actions自动编译部署sapper-blog",description:"使用github actions打包部署sapper项目并部署到github pages。",keywords:"github actions,sapper,github pages",labels:[b],date:"2020-06-22T00:00:00.000Z"},body:"之前构建好了的[博客](\u002Fblog\u002F2020-06_build-blog)，通过编写一个脚本实现本地自动化部署。脚本实现的功能就是在本地处理项目的打包并将静态文件推送到远端的`gh-pages`分支以实现静态文件部署。在了解github actions之后，决定增加一个自动化打包部署的workflow。这样就可以将编译打包的操作完全放置在”云端“。\n\n## 编写workflow配置文件\n\n在项目根目录创建`.github\u002Fworkflows\u002Fmain.yml`\n\n```yaml\nname: Deploy GitHub Pages\n\non:\n  push:\n  \t# push钩子监听的分支，为编译打包的分支\n    branches:\n      - feat\u002Fdev\n\n# 任务\njobs:\n  build-and-deploy:\n    # 服务器环境：最新版 Ubuntu\n    runs-on: ubuntu-latest\n    steps:\n      # 拉取代码\n      - name: Checkout\n        uses: actions\u002Fcheckout@v2\n        with:\n          persist-credentials: false\n\n      # 生成静态文件\n      - name: Build\n        run: npm install && npm run export && cp -i CNAME __sapper__\u002Fexport\n\n      # 部署到 GitHub Pages\n      - name: Deploy\n        uses: JamesIves\u002Fgithub-pages-deploy-action@releases\u002Fv3\n        with:\n          ACCESS_TOKEN: ${{ secrets.GH_PAGES }}\n          BRANCH: gh-pages\n          FOLDER: __sapper__\u002Fexport\n```\n\n上面配置有个别要注意的点：\n\n1. branches需要设置为要处理的分支。\n\n2. with\u002FACCESS_TOKEN为github生成的token。\n\n   生成步骤：\n\n   [github右上角的Settings-Developer settings-Personal access tokens](https:\u002F\u002Fgithub.com\u002Fsettings\u002Ftokens) 点击`Generate new token`，为了和配置文件对应，token的note需要填写为GH_PAGES，然后勾选scope为repo。\n\n   在博客的仓库的setting设置secret。\n\n   ![Xnip2020-06-22_14-12-10.jpg](https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F22\u002FjurxoLcUY7p5C8a.jpg)\n\n3. with\u002FFOLDER为sapper导出export的静态文件目录。\n\n以上完成之后，将代码push到远端仓库，就可以在Actions看到名字为`Deploy Github Pages`的workflow。\n\n![Xnip2020-06-22_14-15-32.jpg](https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F22\u002FbCxitLWKVlgHD8P.jpg)\n\n## 体会\n\nGithub Actions比在公司使用gitlab cicd快了不少，体验非常不错。在写完博客之后，只需要做的，只有将更新的内容push到github就可以了。\n\n",bodyBegin:a,frontmatter:"title: 使用github actions自动编译部署sapper-blog\ndescription: 使用github actions打包部署sapper项目并部署到github pages。\nkeywords: github actions,sapper,github pages\nlabels: ['前端']\ndate: 2020-06-22"}},{title:"2020-06\u002Feclipse.md",path:"2020-06\u002Feclipse",slug:"2020-06_eclipse",fmData:{attributes:{title:e,description:"日环食，10年一遇，还有自己的一点小思考。",keywords:e,labels:[d],date:"2020-06-21T00:00:00.000Z"},body:"或许是不留意，像日环食、日全食这样难得一见的新闻像是突然冒出来一样。今天遇上了10年一遇的日环食。\n\n当然是不能用眼睛直视啦，不过我在的屋子刚好下午是看不到阳光，外加上兴趣也不是十分大（没有工具，手机也拍不到好，外面又很热很热），就没有特意跑到楼下去看了。倒是朋友圈和微博都有非常多的直播，看他们发的，其实也就够了。新闻也提到了可以用小孔成像原理，就是拿一个带小孔的“东西”放在阳光下就可以看到日食的样子。恰巧有人路过拍下下面有意思的画面。\n\n![IMG_6668.JPG](https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F21\u002F3y8KMzdDhmQWBtq.jpg)\n\n也不是我现场看到，但如果这是日环食通过小孔成像体验的模样，就颇为奇妙了，奇妙的不仅仅是这一自然现象，还有的是大千世界无与伦比的恰巧带来奇妙的画面。\n\n## 小思考\n\n自己也常常浮想联翩。就拿今天的日环食，我会想为啥星球都是如此的圆；为什么会有那么巧的情况，让太阳被某个星球所刚好阻挡住光线。《星际穿越》是我最喜欢的电影，对于浩瀚太空的探索，显得我们那么渺小，就像男主结尾疑惑是谁把空间放在那的，我也在想，所有的一切都是自然发生的吗？还是有更高的物质将我们赋予生命、时间、还有空间？恐怕人类从开始到结束，都不会知道。走出浮想，想想今天也是天气很好的一天，我总可以好好享受自然带来的乐趣，觉得人类到底也是幸运的。",bodyBegin:a,frontmatter:"title: 日环食\ndescription: 日环食，10年一遇，还有自己的一点小思考。\nkeywords: 日环食\nlabels: ['随笔']\ndate: 2020-06-21"}},{title:"2020-06\u002Fbuild-blog.md",path:"2020-06\u002Fbuild-blog",slug:"2020-06_build-blog",fmData:{attributes:{title:"用sapper构建一个博客",description:"用sapper构建一个博客，相关技术：svelte、sapper、tailwindcss、typescript。编写markdown后一键部署到github pages。",keywords:"sapper，博客，svelte，tailwindcss，typescript，github pages，markdown",labels:[b,"技术"],date:"2020-06-20T00:00:00.000Z"},body:"发现自己好久没有写博客了。之前在github开了一个仓库，在仓库的[issue区](https:\u002F\u002Fgithub.com\u002FGzhiYi\u002Fblog\u002Fissues)写一些内容。issue区体验挺好的，可以refer上项目代码，也可以追加评论。但我想自己写一个博客，不需要很多花里胡哨的功能，只对内容专注，极大的好处是，可以随心所欲的编写自己喜欢的页面样式。刚好最近有接触了下[svelte](https:\u002F\u002Fsvelte.dev\u002F)，就顺带的用[sapper](https:\u002F\u002Fsapper.svelte.dev\u002F)写一个静态页面。\n\n实现需要用到的知识点\u002F技术：\n\n1. svelte\n2. sapper\n3. tailwindcss\n4. typescript\n\n后面两点非必须，可以根据自己需要进行增减。\n\n## 思路\n整体的思路比较简单。\n\nsapper支持export出静态文件，我只需要将静态文件部署到一个静态站点，首选的就是github pages。sapper导出export有一个好处：\n\n\u003E Static doesn't mean non-interactive — your Svelte components work exactly as they do normally, and you still get all the benefits of client-side routing and prefetching.\n\nsapper默认的template就是一个blog，这不是刚好可以拿来起手嘛！但默认的template的 blog内容是固定的数据，大致内容是一个js文件，export一个blog的array。\n\n```javascript\nexport const [\n  {\n    title: '2020-06\u002Fbuild-blog.md',\n    slug: '2020-06_build-blog', \u002F\u002F 生成的路由路径\n    html: '\u003Ch1 id=\\\"用sapper构建一个博客\\\"\u003E用sapper构建一个博客\u003C\u002Fh1\u003E'\n  }\n]\n```\n\n在sapper export之后，可以在`__sapper__\u002Fexport\u002Fblog`看到生成html静态文件。也就意味着最后需要部署到github pages的目录，就是`__sapper__`目录啦。\n\n**可如果要写博客，那肯定也优先选择Markdown。**\n\n所以需要解决的也就是将Markdown文件转为上面提到的js文件。\n\n## 将Markdown转为js文件\n\n需要用到[Markedjs](https:\u002F\u002Fgithub.com\u002Fmarkedjs\u002Fmarked)。\n\n使用也是简单粗暴：\n\n```javascript\nconst marked = require('marked')\nmarked.setOptions({\n  renderer: new marked.Renderer(),\n  highlight: function(code, language) {\n    const hljs = require('highlight.js')\n    const validLanguage = hljs.getLanguage(language) ? language : 'plaintext'\n    return hljs.highlight(validLanguage, code).value\n  },\n  \u002F\u002F ...(more options)\n});\nmarked(markdownString)\n```\n\n例如markdownString为：\n\n```\n*hello world*\n```\n\n将会被转为：\n\n```html\n\u003Cp\u003E\u003Cem\u003Ehello world\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n```\n\n知道用法之后，只需要通过fs文件操作，将目标的Markdown文件全部push进一个数组，最后将数组写入一个js文件。\n\n## 读取Markdown并写入文件\n\nnode对操作文件提供了`readir`、`readFile`、`writeFile`等函数。\n\n其中核心的处理逻辑如下：\n\n```javascript\n\u002F\u002F 获取所有文件\nconst getAllFiles = function (dirPath, arrayOfFiles) {\n\tfiles = fs.readdirSync(dirPath)\n\tarrayOfFiles = arrayOfFiles || []\n\tfiles.forEach(function (file) {\n\t\tif (fs.statSync(dirPath + \"\u002F\" + file).isDirectory()) {\n\t\t\tarrayOfFiles = getAllFiles(dirPath + \"\u002F\" + file, arrayOfFiles)\n\t\t} else {\n\t\t\tarrayOfFiles.push(path.join(dirPath, \"\u002F\", file))\n\t\t}\n\t})\n\treturn arrayOfFiles\n}\n\u002F\u002F 将markdown转为js文件\nconst compile = () =\u003E {\n\ttry {\n\t\tconst dirs = getAllFiles('.\u002F') \u002F\u002F 读取所有文件\n\t\tconst inPosts = [] \u002F\u002F 文章数组\n\t\tfor (let fileName of dirs) {\n\t\t\tif (\u002F.md\u002F.test(fileName)) {\n\t\t\t\tconst fileData = fs.readFileSync(`.\u002F${fileName}`, 'utf-8') \u002F\u002F markdown内容\n\t\t\t\tconst fmData = fm(fileData) \u002F\u002F 此处可以忽略fm（fm是处理markdown front matter的，可有可无）\n\t\t\t\tconst rmSuffix = fileName.split('.')[0] \u002F\u002F 移除文件名后缀\n\t\t\t\tinPosts.push({\n\t\t\t\t\ttitle: fileName,\n\t\t\t\t\tpath: rmSuffix,\n\t\t\t\t\tslug: rmSuffix.replace('\u002F', '_'),\n\t\t\t\t\thtml: marked(fmData.body),\n\t\t\t\t\tfmData\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tinPosts.forEach(post =\u003E {\n\t\t\tpost.html = post.html.replace(\u002F^\\t{3}\u002Fgm, '');\n\t\t});\n\t\tconst outPutContent = `export default ${JSON.stringify(inPosts)}`\n\t\tfs.writeFile('..\u002Froutes\u002Fblog\u002F_posts.js', outPutContent, err =\u003E {\n\t\t\tif (err) return console.log('生成post失败', err)\n\t\t\tconsole.log('已生成_posts.js')\n\t\t})\n\t} catch (error) {\n\t\tconsole.error('error', error)\n\t}\n}\nconst watcher = chokidar.watch('.\u002F')\nwatcher\n\t.on('all', () =\u003E {\n\t\tcompile()\n\t})\n```\n\n## 部署到github pages\n\n对于sapper，执行export命令生成静态文件。\n\n```bash\nnpm run export\n```\n\n将`__sapper__\u002Fexport`推送到仓库的gh-pages分支。\n\n```bash\ngit subtree push --prefix __sapper__\u002Fexport origin gh-pages\n```\n\n最后在仓库设置出将gh-pages分支设置为部署分支就好了。\n\n以上完成了从写Markdown到可以看到文章，后续页面的编写就可以随心所欲啦！",bodyBegin:a,frontmatter:"title: 用sapper构建一个博客\ndescription: 用sapper构建一个博客，相关技术：svelte、sapper、tailwindcss、typescript。编写markdown后一键部署到github pages。\nkeywords: sapper，博客，svelte，tailwindcss，typescript，github pages，markdown\nlabels: ['前端', '技术']\ndate: 2020-06-20"}}]}}(9,"前端","用firebase给静态博客页面增加点赞功能","随笔","日环食"))]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.c7e18bc4.js"}catch(e){main="/client/legacy/client.aa8cd007.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script> <script src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1" async></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 