<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <link href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css rel=stylesheet> <link href=client/main.250686488.css rel=stylesheet> <noscript id=sapper-head-start></noscript><title>GzhiYi's blog</title><noscript id=sapper-head-end></noscript> </head> <body> <div id=sapper> <nav class=svelte-1wr5yce><ul class=svelte-1wr5yce> <li class=svelte-1wr5yce><a href=blog rel=prefetch aria-current=page class=svelte-1wr5yce>blog</a></ul></nav> <main class=svelte-iwmse4> <h1>Recent posts</h1> <ul class=svelte-1ect80f> <li><a href=blog/2020-06_sapper-github-actions rel=prefetch>6/22/2020 使用github actions自动编译部署sapper-blog </a></li> <li><a href=blog/2020-06_eclipse rel=prefetch>6/21/2020 日环食 </a></li> <li><a href=blog/2020-06_build-blog rel=prefetch>6/20/2020 用sapper构建一个博客 </a></ul></main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,(function(a,b){return {posts:[{title:"2020-06\u002Fsapper-github-actions.md",path:"2020-06\u002Fsapper-github-actions",slug:"2020-06_sapper-github-actions",fmData:{attributes:{title:"使用github actions自动编译部署sapper-blog",description:"使用github actions打包部署sapper项目并部署到github pages。",keywords:"github actions,sapper,github pages",date:"2020-06-22T00:00:00.000Z"},body:"# 使用github actions自动编译部署sapper-blog\n\n之前构建好了的[博客](\u002Fblog\u002F2020-06_build-blog)，通过编写一个脚本实现本地自动化部署。脚本实现的功能就是在本地处理项目的打包并将静态文件推送到远端的`gh-pages`分支以实现静态文件部署。在了解github actions之后，决定增加一个自动化打包部署的workflow。这样就可以将编译打包的操作完全放置在”云端“。\n\n## 编写workflow配置文件\n\n```yaml\nname: Deploy GitHub Pages\n\non:\n  push:\n  \t# push钩子监听的分支，为编译打包的分支\n    branches:\n      - feat\u002Fdev\n\n# 任务\njobs:\n  build-and-deploy:\n    # 服务器环境：最新版 Ubuntu\n    runs-on: ubuntu-latest\n    steps:\n      # 拉取代码\n      - name: Checkout\n        uses: actions\u002Fcheckout@v2\n        with:\n          persist-credentials: false\n\n      # 生成静态文件\n      - name: Build\n        run: npm install && npm run export && cp -i CNAME __sapper__\u002Fexport\n\n      # 部署到 GitHub Pages\n      - name: Deploy\n        uses: JamesIves\u002Fgithub-pages-deploy-action@releases\u002Fv3\n        with:\n          ACCESS_TOKEN: ${{ secrets.GH_PAGES }}\n          BRANCH: gh-pages\n          FOLDER: __sapper__\u002Fexport\n```\n\n上面配置有个别要注意的点：\n\n1. branches需要设置为要处理的分支。\n\n2. with\u002FACCESS_TOKEN为github生成的token。\n\n   生成步骤：\n\n   [github右上角的Settings-Developer settings-Personal access tokens](https:\u002F\u002Fgithub.com\u002Fsettings\u002Ftokens) 点击`Generate new token`，为了和配置文件对应，token的note需要填写为GH_PAGES，然后勾选scope为repo。\n\n   在博客的仓库的setting设置secret。\n\n   ![Xnip2020-06-22_14-12-10.jpg](https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F22\u002FjurxoLcUY7p5C8a.jpg)\n\n3. with\u002FFOLDER为sapper导出export的静态文件目录。\n\n以上完成之后，将代码push到远端仓库，就可以在Actions看到名字为`Deploy Github Pages`的workflow。\n\n![Xnip2020-06-22_14-15-32.jpg](https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F22\u002FbCxitLWKVlgHD8P.jpg)\n\n## 体会\n\nGithub Actions比在公司使用gitlab cicd快了不少，体验非常不错。在写完博客之后，只需要做的，只有将更新的内容push到github就可以了。\n\n",bodyBegin:a,frontmatter:"title: 使用github actions自动编译部署sapper-blog\ndescription: 使用github actions打包部署sapper项目并部署到github pages。\nkeywords: github actions,sapper,github pages\ndate: 2020-06-22"}},{title:"2020-06\u002Feclipse.md",path:"2020-06\u002Feclipse",slug:"2020-06_eclipse",fmData:{attributes:{title:b,description:"日环食，10年一遇，还有自己的一点小思考。",keywords:b,date:"2020-06-21T00:00:00.000Z"},body:"# 日环食\n\n或许是不留意，像日环食、日全食这样难得一见的新闻像是突然冒出来一样。今天遇上了10年一遇的日环食。\n\n\n\n![IMG_6669.JPG](https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F21\u002FzQfrTOo7ZENBGg6.jpg)\n\n当然是不能用眼睛直视啦，不过我在的屋子刚好下午是看不到阳光，外加上兴趣也不是十分大（没有工具，手机也拍不到好，外面又很热很热），就没有特意跑到楼下去看了。倒是朋友圈和微博都有非常多的直播，看他们发的，其实也就够了。新闻也提到了可以用小孔成像原理，就是拿一个带小孔的“东西”放在阳光下就可以看到日食的样子。恰巧有人路过拍下下面有意思的画面。\n\n![IMG_6668.JPG](https:\u002F\u002Fi.loli.net\u002F2020\u002F06\u002F21\u002F3y8KMzdDhmQWBtq.jpg)\n\n也不是我现场看到，但如果这是日环食通过小孔成像体验的模样，就颇为奇妙了，奇妙的不仅仅是这一自然现象，还有的是大千世界无与伦比的恰巧带来奇妙的画面。\n\n## 小思考\n\n自己也常常浮想联翩。就拿今天的日环食，我会想为啥星球都是如此的圆；为什么会有那么巧的情况，让太阳被某个星球所刚好阻挡住光线。《星际穿越》是我最喜欢的电影，对于浩瀚太空的探索，显得我们那么渺小，就像男主结尾疑惑是谁把空间放在那的，我也在想，所有的一切都是自然发生的吗？还是有更高的物质将我们赋予生命、时间、还有空间？恐怕人类从开始到结束，都不会知道。走出浮想，想想今天也是天气很好的一天，我总可以好好享受自然带来的乐趣，觉得人类到底也是幸运的。",bodyBegin:a,frontmatter:"title: 日环食\ndescription: 日环食，10年一遇，还有自己的一点小思考。\nkeywords: 日环食\ndate: 2020-06-21"}},{title:"2020-06\u002Fbuild-blog.md",path:"2020-06\u002Fbuild-blog",slug:"2020-06_build-blog",fmData:{attributes:{title:"用sapper构建一个博客",description:"用sapper构建一个博客，相关技术：svelte、sapper、tailwindcss、typescript。编写markdown后一键部署到github pages。",keywords:"sapper，博客，svelte，tailwindcss，typescript，github pages，markdown",date:"2020-06-20T00:00:00.000Z"},body:"# 用sapper构建一个博客\n\n发现自己好久没有写博客了。之前在github开了一个仓库，在仓库的[issue区](https:\u002F\u002Fgithub.com\u002FGzhiYi\u002Fblog\u002Fissues)写一些内容。issue区体验挺好的，可以refer上项目代码，也可以追加评论。但我想自己写一个博客，不需要很多花里胡哨的功能，只对内容专注，极大的好处是，可以随心所欲的编写自己喜欢的页面样式。刚好最近有接触了下[svelte](https:\u002F\u002Fsvelte.dev\u002F)，就顺带的用[sapper](https:\u002F\u002Fsapper.svelte.dev\u002F)写一个静态页面。\n\n实现需要用到的知识点\u002F技术：\n\n1. svelte\n2. sapper\n3. tailwindcss\n4. typescript\n\n后面两点非必须，可以根据自己需要进行增减。\n\n## 思路\n整体的思路比较简单。\n\nsapper支持export出静态文件，我只需要将静态文件部署到一个静态站点，首选的就是github pages。sapper导出export有一个好处：\n\n\u003E Static doesn't mean non-interactive — your Svelte components work exactly as they do normally, and you still get all the benefits of client-side routing and prefetching.\n\nsapper默认的template就是一个blog，这不是刚好可以拿来起手嘛！但默认的template的 blog内容是固定的数据，大致内容是一个js文件，export一个blog的array。\n\n```javascript\nexport const [\n  {\n    title: '2020-06\u002Fbuild-blog.md',\n    slug: '2020-06_build-blog', \u002F\u002F 生成的路由路径\n    html: '\u003Ch1 id=\\\"用sapper构建一个博客\\\"\u003E用sapper构建一个博客\u003C\u002Fh1\u003E'\n  }\n]\n```\n\n在sapper export之后，可以在`__sapper__\u002Fexport\u002Fblog`看到生成html静态文件。也就意味着最后需要部署到github pages的目录，就是`__sapper__`目录啦。\n\n**可如果要写博客，那肯定也优先选择Markdown。**\n\n所以需要解决的也就是将Markdown文件转为上面提到的js文件。\n\n## 将Markdown转为js文件\n\n需要用到[Markedjs](https:\u002F\u002Fgithub.com\u002Fmarkedjs\u002Fmarked)。\n\n使用也是简单粗暴：\n\n```javascript\nconst marked = require('marked')\nmarked.setOptions({\n  renderer: new marked.Renderer(),\n  highlight: function(code, language) {\n    const hljs = require('highlight.js')\n    const validLanguage = hljs.getLanguage(language) ? language : 'plaintext'\n    return hljs.highlight(validLanguage, code).value\n  },\n  \u002F\u002F ...(more options)\n});\nmarked(markdownString)\n```\n\n例如markdownString为：\n\n```\n*hello world*\n```\n\n将会被转为：\n\n```html\n\u003Cp\u003E\u003Cem\u003Ehello world\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n```\n\n知道用法之后，只需要通过fs文件操作，将目标的Markdown文件全部push进一个数组，最后将数组写入一个js文件。\n\n## 读取Markdown并写入文件\n\nnode对操作文件提供了`readir`、`readFile`、`writeFile`等函数。\n\n其中核心的处理逻辑如下：\n\n```javascript\n\u002F\u002F 获取所有文件\nconst getAllFiles = function (dirPath, arrayOfFiles) {\n\tfiles = fs.readdirSync(dirPath)\n\tarrayOfFiles = arrayOfFiles || []\n\tfiles.forEach(function (file) {\n\t\tif (fs.statSync(dirPath + \"\u002F\" + file).isDirectory()) {\n\t\t\tarrayOfFiles = getAllFiles(dirPath + \"\u002F\" + file, arrayOfFiles)\n\t\t} else {\n\t\t\tarrayOfFiles.push(path.join(dirPath, \"\u002F\", file))\n\t\t}\n\t})\n\treturn arrayOfFiles\n}\n\u002F\u002F 将markdown转为js文件\nconst compile = () =\u003E {\n\ttry {\n\t\tconst dirs = getAllFiles('.\u002F') \u002F\u002F 读取所有文件\n\t\tconst inPosts = [] \u002F\u002F 文章数组\n\t\tfor (let fileName of dirs) {\n\t\t\tif (\u002F.md\u002F.test(fileName)) {\n\t\t\t\tconst fileData = fs.readFileSync(`.\u002F${fileName}`, 'utf-8') \u002F\u002F markdown内容\n\t\t\t\tconst fmData = fm(fileData) \u002F\u002F 此处可以忽略fm（fm是处理markdown front matter的，可有可无）\n\t\t\t\tconst rmSuffix = fileName.split('.')[0] \u002F\u002F 移除文件名后缀\n\t\t\t\tinPosts.push({\n\t\t\t\t\ttitle: fileName,\n\t\t\t\t\tpath: rmSuffix,\n\t\t\t\t\tslug: rmSuffix.replace('\u002F', '_'),\n\t\t\t\t\thtml: marked(fmData.body),\n\t\t\t\t\tfmData\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tinPosts.forEach(post =\u003E {\n\t\t\tpost.html = post.html.replace(\u002F^\\t{3}\u002Fgm, '');\n\t\t});\n\t\tconst outPutContent = `export default ${JSON.stringify(inPosts)}`\n\t\tfs.writeFile('..\u002Froutes\u002Fblog\u002F_posts.js', outPutContent, err =\u003E {\n\t\t\tif (err) return console.log('生成post失败', err)\n\t\t\tconsole.log('已生成_posts.js')\n\t\t})\n\t} catch (error) {\n\t\tconsole.error('error', error)\n\t}\n}\nconst watcher = chokidar.watch('.\u002F')\nwatcher\n\t.on('all', () =\u003E {\n\t\tcompile()\n\t})\n```\n\n# 部署到github pages\n\n对于sapper，执行export命令生成静态文件。\n\n```bash\nnpm run export\n```\n\n将`__sapper__\u002Fexport`推送到仓库的gh-pages分支。\n\n```bash\ngit subtree push --prefix __sapper__\u002Fexport origin gh-pages\n```\n\n最后在仓库设置出将gh-pages分支设置为部署分支就好了。\n\n以上完成了从写Markdown到可以看到文章，后续页面的编写就可以随心所欲啦！",bodyBegin:a,frontmatter:"title: 用sapper构建一个博客\ndescription: 用sapper构建一个博客，相关技术：svelte、sapper、tailwindcss、typescript。编写markdown后一键部署到github pages。\nkeywords: sapper，博客，svelte，tailwindcss，typescript，github pages，markdown\ndate: 2020-06-20"}}]}}(8,"日环食"))]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.a2e3aa7d.js"}catch(e){main="/client/legacy/client.5d16ad05.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@1.0.1.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js></script> <script src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1" async></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 