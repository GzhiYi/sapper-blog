<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <meta content=Mrn4dXO3Z_939geeswIgr2wIpspT6n7X5cX1Tjp69Ko name=google-site-verification> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=atom-one-light.min.css rel=stylesheet> <link href=client/client-8d9aba14.css rel=stylesheet><link href=client/[slug]-72c0ef40.css rel=stylesheet> <title>svelte语法点小记-GzhiYi's blog</title><meta content=svelte和vue、react不同，在构建页面的时候语法需要和其余框架区别开，记录官方文档有助于理解使用。 name=description data-svelte=svelte-2vncnt><meta content="svelte, vue, react, 文档" name=keywords data-svelte=svelte-2vncnt> <link href=/client/client.ab57a19f.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/client-8d9aba14.css rel=preload as=style><link href=/client/[slug].9997cae7.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/config.026ad977.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/inject_styles.5607aec6.js rel=modulepreload as=script crossorigin=use-credentials><link href=/client/[slug]-72c0ef40.css rel=preload as=style></head> <body> <div id=sapper> <nav class=svelte-1dbd5up><ul class=svelte-1dbd5up> <li class=svelte-1dbd5up><a aria-current=page class=svelte-1dbd5up href=blog rel=prefetch>blog</a></ul></nav> <main class=svelte-1y51i2> <div class="svelte-23vme9 base"><div class=label>前端</div><div class=label>svelte</div> <div class="svelte-23vme9 title">svelte语法点小记</div> <span class="svelte-23vme9 author">GzhiYi · 2021-06-24</span></div> <div class="svelte-23vme9 content"><p>计划重写原本由sapper编写的博客，需要移除sapper，只用svelte和一般的构建即可。在此之前，需要花点时间学习（回顾）一下svelte的一下语法点，会和vue进行对比，暂不深入理解内部原理，单纯建立在官方文档的基础上。</p> <p>记录并不是所有细节都要兼顾。遇到和vue理念比较大，或者说这个语法并没有让我那么容易记住的知识点，我都会记录下来，并在后续闲暇的时间下进行回顾复习，有点类似于做一下错题本。</p> <ol> <li><p>变量和代码块都只需要放在一个花括号里面就好了。在vue里面是<code>{{}}</code>包裹，有点不同。不要有带入vue语法的惯性思维。</p> </li> <li><p>和vue类似，一个<code>.svelte</code>文件就是一个组件，包含了script、html、还有css。可以在另一个svelte组件中引入svelte组件。</p> </li> <li><p>{@html 字符串}，包裹的字符串会被转化为不信任来源的html代码，注意防止xss攻击。</p> </li> <li><p>当组件中的变量更新的时候，svelte会自动更新对应的dom。类似于vue中的计算属性，svelte是这么处理的：</p> <pre><code class=language-javascript>const <span class=hljs-attr>varable</span> = <span class=hljs-number>0</span>
$: <span class=hljs-attr>varableName</span> = varable + <span class=hljs-number>1</span>
</code></pre> <p>其中<code>$:</code>就是可以标识变量为“计算属性”，其中varable变化的话，对应的varableName也会跟着变化。</p> <p><code>$:</code>不仅仅是标识变量为计算属性，还可以是一串代码块，在该代码块中的变量一旦发生变化，就会执行这个代码块，而如果没有变量变化，这一个代码块就不会执行。所以把这个符号理解为响应式定义符更好，官网提到的名词就叫响应式声明。</p> </li> <li><p>对于一般变量，直接赋值就可以产生响应式的效果，但如果是对象类型就不可以，比如数组的push等操作，就不会更新dom。svelte的解决方式有</p> <ol> <li><p>在数组操作之后，将结果数组赋值给原数组。</p> <pre><code class=language-js>let num = [<span class=hljs-number>1</span>, <span class=hljs-number>2</span>, <span class=hljs-number>3</span>]
<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>addNum</span></span>(<span class=hljs-keyword>new</span><span class=hljs-type>Num</span>) {
  num.push(<span class=hljs-keyword>new</span><span class=hljs-type>Num</span>)
}
<span class=hljs-comment>// 直接在html上调用这个addNum函数，是不会对num进行更新的，需要改为</span>
<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>addNum</span></span>(<span class=hljs-keyword>new</span><span class=hljs-type>Num</span>) {
  num.push(<span class=hljs-keyword>new</span><span class=hljs-type>Num</span>)
  num = num
}
<span class=hljs-comment>// 抑或者</span>
<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>addNum</span></span>(<span class=hljs-keyword>new</span><span class=hljs-type>Num</span>) {
  num = [...num, <span class=hljs-keyword>new</span><span class=hljs-type>Num</span>]
}
</code></pre> </li> <li><p>对于对象属性的更新，可以直接赋值。</p> <pre><code class=language-javascript><span class=hljs-keyword>let</span> obj = {
 <span class=hljs-built_in> name</span>: <span class=hljs-string>'cat'</span>
}
// 可以直接更新obj上<span class=hljs-built_in>的name</span>属性
<span class=hljs-keyword>function</span> changeName(newName) {
  obj<span class=hljs-built_in>.name</span> = newName
}
</code></pre> </li> </ol> </li> </ol> <p>6.组件参数传递。和vue不一样，vue在一个组件中对传入参数是直接在props上进行声明的。而svelte是直接在组件内export参数。</p> <pre><code class=language-vue>// 组件displayName.svelte
<span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>
  <span class=hljs-keyword>export</span> <span class=hljs-keyword>let</span> name = <span class=hljs-string>"name参数的默认值"</span> <span class=hljs-comment>// 这里就直接表示组件a具有一个name的参数，外部可以传递进来</span>
</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>

// 组件b.svelte
<span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>
  <span class=hljs-keyword>import</span> DisplayName <span class=hljs-keyword>from</span> <span class=hljs-string>'./displayName.svelte'</span>
    <span class=hljs-keyword>let</span> myName = <span class=hljs-string>'cat'</span>
</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>
<span class=hljs-tag>&lt;<span class=hljs-name>DisplayName</span> <span class=hljs-attr>name</span>=<span class=hljs-string>{myName}</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>DisplayName</span>></span>

</code></pre> <ol start=7> <li><p>if块。初次感受肯定是没有vue方便快捷，但写多几遍之后，发现还是可以接受这样的一个语法糖。注意#号不能遗漏掉。</p> <pre><code class=language-vue>{<span class=hljs-comment>#if isTrue}</span>
    <span class=hljs-regexp>//</span> 执行为isTrue的html
{:<span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> 条件} <span class=hljs-regexp>//</span> 这个是额外可能出现的条件
{:<span class=hljs-keyword>else</span>}
    <span class=hljs-regexp>//</span> 执行isTrue为false的html
{/<span class=hljs-keyword>if</span>}
</code></pre> </li> <li><p>循环块。类比vue中的v-for。其中（）内的数值表示为id，可以有效更新dom。</p> <pre><code class=language-vue><span class=xml>let arr = [
    </span><span class=hljs-template-variable>{
        id: 1,
        name: 'cat'
    }</span><span class=xml>,
    </span><span class=hljs-template-variable>{
        id: 2,
        name: 'dog'
    }</span><span class=xml>
]
</span><span class=hljs-template-tag>{#<span class=hljs-name>each</span> arr as item, index(item.id)}</span><span class=xml>
    <span class=hljs-tag>&lt;<span class=hljs-name>p</span>></span></span><span class=hljs-template-variable>{index}</span><span class=xml>: </span><span class=hljs-template-variable>{item.name}</span><span class=xml><span class=hljs-tag>&lt;/<span class=hljs-name>p</span>></span>
</span><span class=hljs-template-tag>{/<span class=hljs-name>each</span>}</span><span class=xml>
// 用上解构，会更加简洁明了
</span><span class=hljs-template-tag>{#<span class=hljs-name>each</span> arr as {id, name}</span><span class=xml>, index(id)}
    <span class=hljs-tag>&lt;<span class=hljs-name>p</span>></span></span><span class=hljs-template-variable>{index}</span><span class=xml>: </span><span class=hljs-template-variable>{id}</span><span class=xml> </span><span class=hljs-template-variable>{name}</span><span class=xml><span class=hljs-tag>&lt;/<span class=hljs-name>p</span>></span></span>
</code></pre> </li> <li><p>await块。没想到真的有这个东西，可以直接拿来判断一个promise在多个状态下的表现，这可以说不用写那一堆loading了，大致的代码如下：</p> <pre><code class=language-vue><span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>
    <span class=hljs-keyword>let</span> promise = getDataFromUrl()
  <span class=hljs-keyword>async</span> getDataFromUrl() </span></span><span class=hljs-template-variable>{}</span><span class=xml>
<span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>
// 直接拿promise就像是一个promise一样在html中await
</span><span class=hljs-template-tag>{#<span class=hljs-name>await</span> promise}</span><span class=xml>
    <span class=hljs-tag>&lt;<span class=hljs-name>p</span>></span>正在请求中...<span class=hljs-tag>&lt;/<span class=hljs-name>p</span>></span>
</span><span class=hljs-template-variable>{:then res}</span><span class=xml>
    <span class=hljs-tag>&lt;<span class=hljs-name>p</span>></span>返回的内容</span><span class=hljs-template-variable>{res}</span><span class=xml><span class=hljs-tag>&lt;/<span class=hljs-name>p</span>></span>
</span><span class=hljs-template-variable>{:catch error}</span><span class=xml>
    <span class=hljs-tag>&lt;<span class=hljs-name>p</span>></span>请求出现异常<span class=hljs-tag>&lt;/<span class=hljs-name>p</span>></span>
</span><span class=hljs-template-tag>{/<span class=hljs-name>await</span>}</span><span class=xml>

// 抑或者，你不需要展示loading以及catch错误的话，可以直接then出来
</span><span class=hljs-template-tag>{#<span class=hljs-name>await</span> promise then res}</span><span class=xml>
    <span class=hljs-tag>&lt;<span class=hljs-name>p</span>></span>返回的内容</span><span class=hljs-template-variable>{res}</span><span class=xml><span class=hljs-tag>&lt;/<span class=hljs-name>p</span>></span>
</span><span class=hljs-template-tag>{/<span class=hljs-name>await</span>}</span>
</code></pre> </li> <li><p>事件处理。通过on定义符进行事件绑定。</p> <pre><code class=language-vue>&lt;<span class=hljs-keyword>button</span> <span class=hljs-keyword>on</span>:click={事件名}>点击&lt;/<span class=hljs-keyword>button</span>>
<span class=hljs-comment>// on后面接上原生的事件就好了，比如click、mousemove等</span>
<span class=hljs-comment>// 事件名可以替换为代码块，如</span>
&lt;<span class=hljs-keyword>button</span> <span class=hljs-keyword>on</span>:click={e => {<span class=hljs-comment>// 对变量进行操作}>点击&lt;/button></span>
</code></pre> <p>有些框架由于性能的原因建议不要用行内的方式写事件，尤其是在循环里面。但svelte并没有这个问题，你可以直接用而不用担心那些琐碎，svelte总会做到最好。</p> <p>事件修饰符，可以对事件进行几个有用的修饰。以previewDefault举例：</p> <pre><code class=language-vue><span class=hljs-tag>&lt;<span class=hljs-name>button</span> <span class=hljs-attr>on:click</span>|<span class=hljs-attr>preventDefault</span>=<span class=hljs-string>{事件名}</span>></span>点击<span class=hljs-tag>&lt;/<span class=hljs-name>button</span>></span>
</code></pre> <ol> <li>preventDefault 阻止默认事件。</li> <li>stopPropagation 阻止事件冒泡。</li> <li>passive 优化对touch、wheel事件的滚动表现。</li> <li>capture 在 <em>capture</em> 阶段而不是<em>bubbling</em> 阶段触发事件处理程序。</li> <li>once 事件只运行一次就删除绑定。</li> <li>self 仅当 event.target 是其本身时才执行。</li> </ol> <p>以上修饰符可以串联使用。</p> </li> <li><p>组件通信。老生常谈，业务中遇到的太多了。</p> <pre><code class=language-vue><span class=hljs-comment>// 父组件 parent.svelte</span>
&lt;script>
    <span class=hljs-keyword>import</span> child <span class=hljs-keyword>from</span> <span class=hljs-string>'./child.svelte'</span>
  <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>sayHello</span>(<span class=hljs-params>name</span>) </span>{
    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>`Hi, <span class=hljs-subst>${name}</span>`</span>)
  }
&lt;/script>
<span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>child</span> <span class=hljs-attr>on:say</span>=<span class=hljs-string>{sayHello}</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>child</span>></span></span>

<span class=hljs-comment>// 子组件 child.svelte</span>
<span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>
  <span class=hljs-comment>// 子组件要调用父组件的事件，需要用到事件派发器</span>
  <span class=hljs-keyword>import</span> { createEventDispatcher } <span class=hljs-keyword>from</span> <span class=hljs-string>'svelte'</span>
  <span class=hljs-keyword>const</span> dispatch = createEventDispatcher()
    <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>sayHello</span>(<span class=hljs-params></span>) </span>{
    <span class=hljs-comment>// 这里的话有些类似vue中的$emit</span>
    dispatch(<span class=hljs-string>'say'</span>, {
      <span class=hljs-attr>name</span>: <span class=hljs-string>'我'</span>
    })
  }
</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></span>
<span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>button</span> <span class=hljs-attr>on:click</span>=<span class=hljs-string>{sayHello}</span>></span>点击<span class=hljs-tag>&lt;/<span class=hljs-name>button</span>></span></span>
<span class=hljs-comment>// 如果是dom事件，那么子组件只要不具名，就可以直接调用父组件的事件</span>
<span class=hljs-comment>// 父组件事件定义</span>
<span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>button</span> <span class=hljs-attr>on:click</span>=<span class=hljs-string>{eventName}</span>></span>点击<span class=hljs-tag>&lt;/<span class=hljs-name>button</span>></span></span>
<span class=hljs-comment>// 如果子组件想直接调用dom事件eventName，则</span>
<span class=hljs-comment>// 子组件</span>
<span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>button</span> <span class=hljs-attr>on:click</span>></span>点击<span class=hljs-tag>&lt;/<span class=hljs-name>button</span>></span></span>
</code></pre> <p>如果组件嵌套，需要多次转发事件的话，可以把中间的组件都加一个on:eventName，那么事件名为eventName的事件就会一直转发到目标组件上。</p> <p><em>2021-06-01 23:20</em></p> </li> </ol> <p>12.双向绑定。和vue原理对比TODO。在svelte中的双向绑定，只需要通过bind修饰就可以。</p> <pre><code class=language-vue><span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>
    <span class=hljs-keyword>let</span> name = <span class=hljs-string>'cat'</span>
</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span>
<span class=hljs-tag>&lt;<span class=hljs-name>input</span> <span class=hljs-attr>bind:value</span>=<span class=hljs-string>{name}</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>input</span>></span>
</code></pre> <p>表单元素都可以通过bind进行双向绑定，比如checkbox等。</p> <p>对数组对象，可以直接对值进行循环绑定，这个和vue类似。</p> <p>每个块级标签都可以对<code>clientWidth</code>、<code>clientHeight</code>、<code>offsetWidth</code>、<code>offsetHeight</code>进行绑定。但绑定值只是可读，直接赋值不会进行更新。可以用在读取块元素的尺寸后用于展示等业务上。</p> <ol start=13> <li><p>组件绑定。这个有点意思，我觉得像是vue中的.sync修饰。可以做到在父组件中直接读取子组件export的值。</p> </li> <li><p>生命周期。类比vue的生命周期，svelte的生命周期钩子还是很容易理解的。</p> </li> </ol> <p>在svelte中，每一个组件都有其完整的生命周期，周期的函数需要从svelte中引入。</p> <ul> <li><p><code>onMount</code>。使用最多的应该是<code>onMount</code>钩子，它在组件渲染到dom后执行。可以在这个周期内进行数据的请求操作，这是svelte所推荐的，如果把请求操作放到script内则不好，因为如果需要服务端渲染的话，生命周期函数是没法在服务端渲染过程中执行的。</p> </li> <li><p><code>onDestroy</code>。组件销毁的时候调用，可以对计时器进行清除等操作。文档中有一个有意思的封装，可以把计数器的操作和组件销毁时销毁计时器一起封装。</p> <pre><code class=language-javascript><span class=hljs-comment>// 比如封装到util.js中</span>
imoprt { onDestroy } from 'svelte'
export <span class=hljs-keyword>function</span> on<span class=hljs-constructor>Interval(<span class=hljs-params>callback</span>, <span class=hljs-params>time</span>)</span> {
  const interval = set<span class=hljs-constructor>Interval(<span class=hljs-params>callback</span>, <span class=hljs-params>time</span>)</span>
  on<span class=hljs-constructor>Destroy(()</span> => {
    clear<span class=hljs-constructor>Interval(<span class=hljs-params>interval</span>)</span>
  })
}
</code></pre> <p>那么在组件中就可以直接引入onInterval并调用，那就不需要关切组件销毁的时候有没有把计时器进行销毁。</p> <pre><code class=language-vue><span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>
  <span class=hljs-keyword>import</span> </span></span><span class=hljs-template-variable>{ onInterval }</span><span class=xml><span class=javascript> <span class=hljs-keyword>from</span> <span class=hljs-string>'./util.js'</span>
  onInterval(<span class=hljs-function>() =></span> </span></span><span class=hljs-template-variable>{}</span><span class=xml>, 1000)
<span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></span>
</code></pre> </li> <li><p><code>beforeUpdate</code>、<code>afterUpdate</code>。该钩子在DOM渲染完成前执行。场景例如：渲染标签的滚动位置。</p> </li> <li><p><code>tick</code>。可以随时调用，是一个带有resolve方法的promise，解释是每当组件pendding状态变化就会立即提现到DOM中，类似于vue的<code>$nextTick()</code>?</p> </li> </ul> <ol start=15> <li><p>store。svelte自带了壮态管理，由引入自svelte/store的writable定义：</p> <p><strong>可写store</strong></p> <pre><code class=language-javascript>imoprt { writable } <span class=hljs-keyword>from</span> <span class=hljs-string>'svelte/store'</span>

export <span class=hljs-keyword>const</span> <span class=hljs-keyword>count</span> = writable(<span class=hljs-number>0</span>) <span class=hljs-comment>// 默认值为0，这里注意可以使用const进行定义，即便count是一个数值</span>
</code></pre> <p>在组件中，count具备update、set方法，分别表示更新和重置值。</p> <p>在store创建后，开启的事件订阅，需要在不使用的时候销毁。我们可以在组件的onDestroy周期中取消订阅，避免内存溢出。</p> <pre><code class=language-vue><span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>script</span>></span><span class=javascript>
    <span class=hljs-keyword>import</span> </span></span><span class=hljs-template-variable>{ onDestroy }</span><span class=xml><span class=javascript> <span class=hljs-keyword>from</span> <span class=hljs-string>'svelte'</span>
  <span class=hljs-keyword>import</span> </span></span><span class=hljs-template-variable>{ count }</span><span class=xml><span class=javascript> <span class=hljs-keyword>from</span> <span class=hljs-string>'./store.js'</span>
  
  <span class=hljs-keyword>let</span> countValue
  <span class=hljs-keyword>const</span> unsubscribe = count.subscribe(<span class=hljs-function><span class=hljs-params>value</span> =></span> </span></span><span class=hljs-template-variable>{ // 手动订阅
    count_value = value
  }</span><span class=xml><span class=javascript>)
  onDestroy(unsubscribe) <span class=hljs-comment>// 在组件销毁的时候取消订阅</span>
</span><span class=hljs-tag>&lt;/<span class=hljs-name>script</span>></span></span>
</code></pre> <p>那如果每一个状态都需要这么订阅和销毁的话，就太冗余了，svelte提供一个$符。可以对状态自动进行订阅和取消订阅。yyds。</p> <pre><code class=language-vue><span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>scirpt</span>></span>
    imoprt </span><span class=hljs-template-variable>{ count }</span><span class=xml> from './store.js'
<span class=hljs-tag>&lt;/<span class=hljs-name>scirpt</span>></span>
<span class=hljs-tag>&lt;<span class=hljs-name>p</span>></span> </span><span class=hljs-template-variable>{$count}</span><span class=xml> <span class=hljs-tag>&lt;/<span class=hljs-name>p</span>></span></span>
</code></pre> <p><strong>只读store</strong></p> <p>只需在定义的时候，由writable改为readable就可以定义一个只读的store。</p> <p><strong>防止暴露set、update方法的自定义store</strong></p> <pre><code class=language-javascript>import { writable } from <span class=hljs-string>'svelte/store'</span>
<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createCount</span>(<span class=hljs-params></span>) </span>{
  const { subscribe, set, update } = writable(<span class=hljs-number>0</span>)
  <span class=hljs-keyword>return</span> {
    subscribe,
    <span class=hljs-attr>increment</span>: <span class=hljs-function><span class=hljs-params>()</span> =></span> update(<span class=hljs-function><span class=hljs-params>n</span> =></span> n + <span class=hljs-number>1</span>),
    <span class=hljs-attr>decrement</span>: <span class=hljs-function><span class=hljs-params>()</span> =></span> update(<span class=hljs-function><span class=hljs-params>n</span> =></span> n - <span class=hljs-number>1</span>),
    <span class=hljs-attr>reset</span>: <span class=hljs-function><span class=hljs-params>()</span> =></span> set(<span class=hljs-number>0</span>)
  }
}
</code></pre> </li> <li><p>class指令。在svelte中动态设置class或者说其余的dom属性，会和vue有一些不一样。</p> <pre><code class=language-vue>&lt;<span class=hljs-keyword>div</span> <span class=hljs-keyword>class</span>=<span class=hljs-string>"{isTrue ? 'true-class' : 'false-class'}"</span>>
  name
&lt;/<span class=hljs-keyword>div</span>>
&lt;<span class=hljs-keyword>div</span> <span class=hljs-keyword>class</span>:selected=<span class=hljs-string>"{isTrue}"</span>> <span class=hljs-comment>// 之后留意如何设置camel-case的class名</span>
  name
&lt;/<span class=hljs-keyword>div</span>>
</code></pre> </li> <li><p>组件插槽，和vue的思想一样，这里看文档注意多个插槽怎么具名。</p> <pre><code class=language-vue>// 例如slot.svelte
<span class=hljs-tag>&lt;<span class=hljs-name>slot</span> <span class=hljs-attr>name</span>=<span class=hljs-string>"slot-a"</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>slot</span>></span>

// 调用的组件
<span class=hljs-tag>&lt;<span class=hljs-name>Slot</span>></span>
    <span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>slot</span>=<span class=hljs-string>"slot-a"</span>></span>
    这里是一个具名插槽
  <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>></span>
<span class=hljs-tag>&lt;/<span class=hljs-name>Slot</span>></span>
</code></pre> </li> </ol> <p>18.context API。通过context api，可以跨越组件进行通信。具备setContext和getContext两个api。如果在一个组件中调用了setContext(key, context)，那么，在所有该子组件中都可以调用该context。</p> <pre><code class=language-javascript><span class=hljs-comment>// 父组件中</span>
set<span class=hljs-constructor>Context(<span class=hljs-params>key</span>, <span class=hljs-params>context</span>)</span>
<span class=hljs-comment>// 任意的子组件中</span>
const context = get<span class=hljs-constructor>Context(<span class=hljs-params>key</span>)</span>
</code></pre> <ol start=19> <li><p>特殊标签。svelte具备一些特殊的标签。</p> <ul> <li><p>svelte:self。允许组件递归的去包含自己本身。</p> </li> <li><p>svelte:component。动态组件，与vue类似的用法，通过传入this的组件名，动态挂在组件。</p> <pre><code class=language-vue><span class=hljs-tag>&lt;<span class=hljs-name>svelte:component</span> <span class=hljs-attr>this</span>=<span class=hljs-string>{compnentName}</span>></span><span class=hljs-tag>&lt;/<span class=hljs-name>svelte:component</span>></span>
</code></pre> </li> <li><p>svelte:window。把它当作是一个window对象，可以在该标签上进行事件的监听等操作。</p> </li> <li><p>svelte:body。和window的标签一样，可以在document.body上添加事件监听。</p> </li> <li><p>svelte:head。允许你在页面的</p><head>标签内插入内容。<p></p> <pre><code class=language-html><span class=hljs-section>&lt;svelte:head></span>
  <span class=hljs-section>&lt;link></span><span class=hljs-section>&lt;/link></span>
<span class=hljs-section>&lt;/svelte:head></span>
</code></pre> <p>需要注意的是，在服务端渲染下，这个标签的内容将会单独返回到html中。</p> </li> </ul> </li> </ol> </div> </main></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{post:{title:"svelte语法点小记",description:"svelte和vue、react不同，在构建页面的时候语法需要和其余框架区别开，记录官方文档有助于理解使用。",keywords:"svelte, vue, react, 文档",labels:["前端","svelte"],date:"2021-06-24",path:"2021\u002F06\u002Fsvelte.md",slug:"2021_06_svelte",html:"\u003Cp\u003E计划重写原本由sapper编写的博客，需要移除sapper，只用svelte和一般的构建即可。在此之前，需要花点时间学习（回顾）一下svelte的一下语法点，会和vue进行对比，暂不深入理解内部原理，单纯建立在官方文档的基础上。\u003C\u002Fp\u003E\n\u003Cp\u003E记录并不是所有细节都要兼顾。遇到和vue理念比较大，或者说这个语法并没有让我那么容易记住的知识点，我都会记录下来，并在后续闲暇的时间下进行回顾复习，有点类似于做一下错题本。\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E变量和代码块都只需要放在一个花括号里面就好了。在vue里面是\u003Ccode\u003E{{}}\u003C\u002Fcode\u003E包裹，有点不同。不要有带入vue语法的惯性思维。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E和vue类似，一个\u003Ccode\u003E.svelte\u003C\u002Fcode\u003E文件就是一个组件，包含了script、html、还有css。可以在另一个svelte组件中引入svelte组件。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E{@html 字符串}，包裹的字符串会被转化为不信任来源的html代码，注意防止xss攻击。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E当组件中的变量更新的时候，svelte会自动更新对应的dom。类似于vue中的计算属性，svelte是这么处理的：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Econst \u003Cspan class=\"hljs-attr\"\u003Evarable\u003C\u002Fspan\u003E = \u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E\n$: \u003Cspan class=\"hljs-attr\"\u003EvarableName\u003C\u002Fspan\u003E = varable + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E其中\u003Ccode\u003E$:\u003C\u002Fcode\u003E就是可以标识变量为“计算属性”，其中varable变化的话，对应的varableName也会跟着变化。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003E$:\u003C\u002Fcode\u003E不仅仅是标识变量为计算属性，还可以是一串代码块，在该代码块中的变量一旦发生变化，就会执行这个代码块，而如果没有变量变化，这一个代码块就不会执行。所以把这个符号理解为响应式定义符更好，官网提到的名词就叫响应式声明。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E对于一般变量，直接赋值就可以产生响应式的效果，但如果是对象类型就不可以，比如数组的push等操作，就不会更新dom。svelte的解决方式有\u003C\u002Fp\u003E\n\u003Col\u003E\n\u003Cli\u003E\u003Cp\u003E在数组操作之后，将结果数组赋值给原数组。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-js\"\u003Elet num = [\u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E3\u003C\u002Fspan\u003E]\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EaddNum\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-type\"\u003ENum\u003C\u002Fspan\u003E) {\n  num.push(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-type\"\u003ENum\u003C\u002Fspan\u003E)\n}\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 直接在html上调用这个addNum函数，是不会对num进行更新的，需要改为\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EaddNum\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-type\"\u003ENum\u003C\u002Fspan\u003E) {\n  num.push(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-type\"\u003ENum\u003C\u002Fspan\u003E)\n  num = num\n}\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 抑或者\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EaddNum\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-type\"\u003ENum\u003C\u002Fspan\u003E) {\n  num = [...num, \u003Cspan class=\"hljs-keyword\"\u003Enew\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-type\"\u003ENum\u003C\u002Fspan\u003E]\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E对于对象属性的更新，可以直接赋值。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E obj = {\n \u003Cspan class=\"hljs-built_in\"\u003E name\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;cat&#x27;\u003C\u002Fspan\u003E\n}\n\u002F\u002F 可以直接更新obj上\u003Cspan class=\"hljs-built_in\"\u003E的name\u003C\u002Fspan\u003E属性\n\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E changeName(newName) {\n  obj\u003Cspan class=\"hljs-built_in\"\u003E.name\u003C\u002Fspan\u003E = newName\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E6.组件参数传递。和vue不一样，vue在一个组件中对传入参数是直接在props上进行声明的。而svelte是直接在组件内export参数。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u002F\u002F 组件displayName.svelte\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eexport\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E name = \u003Cspan class=\"hljs-string\"\u003E&quot;name参数的默认值&quot;\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这里就直接表示组件a具有一个name的参数，外部可以传递进来\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\n\u002F\u002F 组件b.svelte\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E DisplayName \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002FdisplayName.svelte&#x27;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E myName = \u003Cspan class=\"hljs-string\"\u003E&#x27;cat&#x27;\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003EDisplayName\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ename\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E{myName}\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003EDisplayName\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"7\"\u003E\n\u003Cli\u003E\u003Cp\u003Eif块。初次感受肯定是没有vue方便快捷，但写多几遍之后，发现还是可以接受这样的一个语法糖。注意#号不能遗漏掉。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E{\u003Cspan class=\"hljs-comment\"\u003E#if isTrue}\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 执行为isTrue的html\n{:\u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E 条件} \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 这个是额外可能出现的条件\n{:\u003Cspan class=\"hljs-keyword\"\u003Eelse\u003C\u002Fspan\u003E}\n    \u003Cspan class=\"hljs-regexp\"\u003E\u002F\u002F\u003C\u002Fspan\u003E 执行isTrue为false的html\n{\u002F\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E循环块。类比vue中的v-for。其中（）内的数值表示为id，可以有效更新dom。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"xml\"\u003Elet arr = [\n    \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{\n        id: 1,\n        name: &#x27;cat&#x27;\n    }\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E,\n    \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{\n        id: 2,\n        name: &#x27;dog&#x27;\n    }\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n]\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-tag\"\u003E{#\u003Cspan class=\"hljs-name\"\u003Eeach\u003C\u002Fspan\u003E arr as item, index(item.id)}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{index}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E: \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{item.name}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-tag\"\u003E{\u002F\u003Cspan class=\"hljs-name\"\u003Eeach\u003C\u002Fspan\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n\u002F\u002F 用上解构，会更加简洁明了\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-tag\"\u003E{#\u003Cspan class=\"hljs-name\"\u003Eeach\u003C\u002Fspan\u003E arr as {id, name}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E, index(id)}\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{index}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E: \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{id}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{name}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Eawait块。没想到真的有这个东西，可以直接拿来判断一个promise在多个状态下的表现，这可以说不用写那一堆loading了，大致的代码如下：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E promise = getDataFromUrl()\n  \u003Cspan class=\"hljs-keyword\"\u003Easync\u003C\u002Fspan\u003E getDataFromUrl() \u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u002F\u002F 直接拿promise就像是一个promise一样在html中await\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-tag\"\u003E{#\u003Cspan class=\"hljs-name\"\u003Eawait\u003C\u002Fspan\u003E promise}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E正在请求中...\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{:then res}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E返回的内容\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{res}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{:catch error}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E请求出现异常\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-tag\"\u003E{\u002F\u003Cspan class=\"hljs-name\"\u003Eawait\u003C\u002Fspan\u003E}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n\n\u002F\u002F 抑或者，你不需要展示loading以及catch错误的话，可以直接then出来\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-tag\"\u003E{#\u003Cspan class=\"hljs-name\"\u003Eawait\u003C\u002Fspan\u003E promise then res}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E返回的内容\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{res}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-tag\"\u003E{\u002F\u003Cspan class=\"hljs-name\"\u003Eawait\u003C\u002Fspan\u003E}\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E事件处理。通过on定义符进行事件绑定。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E&lt;\u003Cspan class=\"hljs-keyword\"\u003Ebutton\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eon\u003C\u002Fspan\u003E:click={事件名}&gt;点击&lt;\u002F\u003Cspan class=\"hljs-keyword\"\u003Ebutton\u003C\u002Fspan\u003E&gt;\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F on后面接上原生的事件就好了，比如click、mousemove等\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 事件名可以替换为代码块，如\u003C\u002Fspan\u003E\n&lt;\u003Cspan class=\"hljs-keyword\"\u003Ebutton\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eon\u003C\u002Fspan\u003E:click={e =&gt; {\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 对变量进行操作}&gt;点击&lt;\u002Fbutton&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E有些框架由于性能的原因建议不要用行内的方式写事件，尤其是在循环里面。但svelte并没有这个问题，你可以直接用而不用担心那些琐碎，svelte总会做到最好。\u003C\u002Fp\u003E\n\u003Cp\u003E事件修饰符，可以对事件进行几个有用的修饰。以previewDefault举例：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eon:click\u003C\u002Fspan\u003E|\u003Cspan class=\"hljs-attr\"\u003EpreventDefault\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E{事件名}\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E点击\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col\u003E\n\u003Cli\u003EpreventDefault 阻止默认事件。\u003C\u002Fli\u003E\n\u003Cli\u003EstopPropagation 阻止事件冒泡。\u003C\u002Fli\u003E\n\u003Cli\u003Epassive 优化对touch、wheel事件的滚动表现。\u003C\u002Fli\u003E\n\u003Cli\u003Ecapture 在 \u003Cem\u003Ecapture\u003C\u002Fem\u003E 阶段而不是\u003Cem\u003Ebubbling\u003C\u002Fem\u003E 阶段触发事件处理程序。\u003C\u002Fli\u003E\n\u003Cli\u003Eonce 事件只运行一次就删除绑定。\u003C\u002Fli\u003E\n\u003Cli\u003Eself 仅当 event.target 是其本身时才执行。\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E以上修饰符可以串联使用。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E组件通信。老生常谈，业务中遇到的太多了。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 父组件 parent.svelte\u003C\u002Fspan\u003E\n&lt;script&gt;\n    \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E child \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002Fchild.svelte&#x27;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EsayHello\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003Ename\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-built_in\"\u003Econsole\u003C\u002Fspan\u003E.log(\u003Cspan class=\"hljs-string\"\u003E`Hi, \u003Cspan class=\"hljs-subst\"\u003E${name}\u003C\u002Fspan\u003E`\u003C\u002Fspan\u003E)\n  }\n&lt;\u002Fscript&gt;\n\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Echild\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eon:say\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E{sayHello}\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Echild\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 子组件 child.svelte\u003C\u002Fspan\u003E\n\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n  \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 子组件要调用父组件的事件，需要用到事件派发器\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E { createEventDispatcher } \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;svelte&#x27;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E dispatch = createEventDispatcher()\n    \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EsayHello\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n    \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 这里的话有些类似vue中的$emit\u003C\u002Fspan\u003E\n    dispatch(\u003Cspan class=\"hljs-string\"\u003E&#x27;say&#x27;\u003C\u002Fspan\u003E, {\n      \u003Cspan class=\"hljs-attr\"\u003Ename\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&#x27;我&#x27;\u003C\u002Fspan\u003E\n    })\n  }\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eon:click\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E{sayHello}\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E点击\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果是dom事件，那么子组件只要不具名，就可以直接调用父组件的事件\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 父组件事件定义\u003C\u002Fspan\u003E\n\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eon:click\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E{eventName}\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E点击\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 如果子组件想直接调用dom事件eventName，则\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 子组件\u003C\u002Fspan\u003E\n\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eon:click\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E点击\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ebutton\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E如果组件嵌套，需要多次转发事件的话，可以把中间的组件都加一个on:eventName，那么事件名为eventName的事件就会一直转发到目标组件上。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cem\u003E2021-06-01 23:20\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E12.双向绑定。和vue原理对比TODO。在svelte中的双向绑定，只需要通过bind修饰就可以。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E name = \u003Cspan class=\"hljs-string\"\u003E&#x27;cat&#x27;\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Einput\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ebind:value\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E{name}\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Einput\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E表单元素都可以通过bind进行双向绑定，比如checkbox等。\u003C\u002Fp\u003E\n\u003Cp\u003E对数组对象，可以直接对值进行循环绑定，这个和vue类似。\u003C\u002Fp\u003E\n\u003Cp\u003E每个块级标签都可以对\u003Ccode\u003EclientWidth\u003C\u002Fcode\u003E、\u003Ccode\u003EclientHeight\u003C\u002Fcode\u003E、\u003Ccode\u003EoffsetWidth\u003C\u002Fcode\u003E、\u003Ccode\u003EoffsetHeight\u003C\u002Fcode\u003E进行绑定。但绑定值只是可读，直接赋值不会进行更新。可以用在读取块元素的尺寸后用于展示等业务上。\u003C\u002Fp\u003E\n\u003Col start=\"13\"\u003E\n\u003Cli\u003E\u003Cp\u003E组件绑定。这个有点意思，我觉得像是vue中的.sync修饰。可以做到在父组件中直接读取子组件export的值。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E生命周期。类比vue的生命周期，svelte的生命周期钩子还是很容易理解的。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E在svelte中，每一个组件都有其完整的生命周期，周期的函数需要从svelte中引入。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EonMount\u003C\u002Fcode\u003E。使用最多的应该是\u003Ccode\u003EonMount\u003C\u002Fcode\u003E钩子，它在组件渲染到dom后执行。可以在这个周期内进行数据的请求操作，这是svelte所推荐的，如果把请求操作放到script内则不好，因为如果需要服务端渲染的话，生命周期函数是没法在服务端渲染过程中执行的。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EonDestroy\u003C\u002Fcode\u003E。组件销毁的时候调用，可以对计时器进行清除等操作。文档中有一个有意思的封装，可以把计数器的操作和组件销毁时销毁计时器一起封装。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 比如封装到util.js中\u003C\u002Fspan\u003E\nimoprt { onDestroy } from &#x27;svelte&#x27;\nexport \u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E on\u003Cspan class=\"hljs-constructor\"\u003EInterval(\u003Cspan class=\"hljs-params\"\u003Ecallback\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Etime\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E {\n  const interval = set\u003Cspan class=\"hljs-constructor\"\u003EInterval(\u003Cspan class=\"hljs-params\"\u003Ecallback\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Etime\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\n  on\u003Cspan class=\"hljs-constructor\"\u003EDestroy(()\u003C\u002Fspan\u003E =&gt; {\n    clear\u003Cspan class=\"hljs-constructor\"\u003EInterval(\u003Cspan class=\"hljs-params\"\u003Einterval\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\n  })\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E那么在组件中就可以直接引入onInterval并调用，那就不需要关切组件销毁的时候有没有把计时器进行销毁。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{ onInterval }\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"javascript\"\u003E \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002Futil.js&#x27;\u003C\u002Fspan\u003E\n  onInterval(\u003Cspan class=\"hljs-function\"\u003E() =&gt;\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E, 1000)\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003EbeforeUpdate\u003C\u002Fcode\u003E、\u003Ccode\u003EafterUpdate\u003C\u002Fcode\u003E。该钩子在DOM渲染完成前执行。场景例如：渲染标签的滚动位置。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E\u003Ccode\u003Etick\u003C\u002Fcode\u003E。可以随时调用，是一个带有resolve方法的promise，解释是每当组件pendding状态变化就会立即提现到DOM中，类似于vue的\u003Ccode\u003E$nextTick()\u003C\u002Fcode\u003E?\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Col start=\"15\"\u003E\n\u003Cli\u003E\u003Cp\u003Estore。svelte自带了壮态管理，由引入自svelte\u002Fstore的writable定义：\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E可写store\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Eimoprt { writable } \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;svelte\u002Fstore&#x27;\u003C\u002Fspan\u003E\n\nexport \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Ecount\u003C\u002Fspan\u003E = writable(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 默认值为0，这里注意可以使用const进行定义，即便count是一个数值\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E在组件中，count具备update、set方法，分别表示更新和重置值。\u003C\u002Fp\u003E\n\u003Cp\u003E在store创建后，开启的事件订阅，需要在不使用的时候销毁。我们可以在组件的onDestroy周期中取消订阅，避免内存溢出。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"javascript\"\u003E\n    \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{ onDestroy }\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"javascript\"\u003E \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;svelte&#x27;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-keyword\"\u003Eimport\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{ count }\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"javascript\"\u003E \u003Cspan class=\"hljs-keyword\"\u003Efrom\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-string\"\u003E&#x27;.\u002Fstore.js&#x27;\u003C\u002Fspan\u003E\n  \n  \u003Cspan class=\"hljs-keyword\"\u003Elet\u003C\u002Fspan\u003E countValue\n  \u003Cspan class=\"hljs-keyword\"\u003Econst\u003C\u002Fspan\u003E unsubscribe = count.subscribe(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003Evalue\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{ \u002F\u002F 手动订阅\n    count_value = value\n  }\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"javascript\"\u003E)\n  onDestroy(unsubscribe) \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 在组件销毁的时候取消订阅\u003C\u002Fspan\u003E\n\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escript\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E那如果每一个状态都需要这么订阅和销毁的话，就太冗余了，svelte提供一个$符。可以对状态自动进行订阅和取消订阅。yyds。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"xml\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Escirpt\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    imoprt \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{ count }\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E from &#x27;.\u002Fstore.js&#x27;\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Escirpt\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E \u003C\u002Fspan\u003E\u003Cspan class=\"hljs-template-variable\"\u003E{$count}\u003C\u002Fspan\u003E\u003Cspan class=\"xml\"\u003E \u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ep\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E只读store\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E只需在定义的时候，由writable改为readable就可以定义一个只读的store。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E防止暴露set、update方法的自定义store\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003Eimport { writable } from \u003Cspan class=\"hljs-string\"\u003E&#x27;svelte\u002Fstore&#x27;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunction\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EcreateCount\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-params\"\u003E\u003C\u002Fspan\u003E) \u003C\u002Fspan\u003E{\n  const { subscribe, set, update } = writable(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E)\n  \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E {\n    subscribe,\n    \u003Cspan class=\"hljs-attr\"\u003Eincrement\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E update(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003En\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E n + \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E),\n    \u003Cspan class=\"hljs-attr\"\u003Edecrement\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E update(\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003En\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E n - \u003Cspan class=\"hljs-number\"\u003E1\u003C\u002Fspan\u003E),\n    \u003Cspan class=\"hljs-attr\"\u003Ereset\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E =&gt;\u003C\u002Fspan\u003E set(\u003Cspan class=\"hljs-number\"\u003E0\u003C\u002Fspan\u003E)\n  }\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Eclass指令。在svelte中动态设置class或者说其余的dom属性，会和vue有一些不一样。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E&lt;\u003Cspan class=\"hljs-keyword\"\u003Ediv\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;{isTrue ? &#x27;true-class&#x27; : &#x27;false-class&#x27;}&quot;\u003C\u002Fspan\u003E&gt;\n  name\n&lt;\u002F\u003Cspan class=\"hljs-keyword\"\u003Ediv\u003C\u002Fspan\u003E&gt;\n&lt;\u003Cspan class=\"hljs-keyword\"\u003Ediv\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-keyword\"\u003Eclass\u003C\u002Fspan\u003E:selected=\u003Cspan class=\"hljs-string\"\u003E&quot;{isTrue}&quot;\u003C\u002Fspan\u003E&gt; \u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 之后留意如何设置camel-case的class名\u003C\u002Fspan\u003E\n  name\n&lt;\u002F\u003Cspan class=\"hljs-keyword\"\u003Ediv\u003C\u002Fspan\u003E&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E组件插槽，和vue的思想一样，这里看文档注意多个插槽怎么具名。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u002F\u002F 例如slot.svelte\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Eslot\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ename\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;slot-a&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Eslot\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\n\u002F\u002F 调用的组件\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003ESlot\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    \u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Ediv\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Eslot\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E&quot;slot-a&quot;\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n    这里是一个具名插槽\n  \u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Ediv\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003ESlot\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003Cp\u003E18.context API。通过context api，可以跨越组件进行通信。具备setContext和getContext两个api。如果在一个组件中调用了setContext(key, context)，那么，在所有该子组件中都可以调用该context。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-javascript\"\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 父组件中\u003C\u002Fspan\u003E\nset\u003Cspan class=\"hljs-constructor\"\u003EContext(\u003Cspan class=\"hljs-params\"\u003Ekey\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-params\"\u003Econtext\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F 任意的子组件中\u003C\u002Fspan\u003E\nconst context = get\u003Cspan class=\"hljs-constructor\"\u003EContext(\u003Cspan class=\"hljs-params\"\u003Ekey\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Col start=\"19\"\u003E\n\u003Cli\u003E\u003Cp\u003E特殊标签。svelte具备一些特殊的标签。\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\u003Cp\u003Esvelte:self。允许组件递归的去包含自己本身。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Esvelte:component。动态组件，与vue类似的用法，通过传入this的组件名，动态挂在组件。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-vue\"\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u003Cspan class=\"hljs-name\"\u003Esvelte:component\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-attr\"\u003Ethis\u003C\u002Fspan\u003E=\u003Cspan class=\"hljs-string\"\u003E{compnentName}\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-tag\"\u003E&lt;\u002F\u003Cspan class=\"hljs-name\"\u003Esvelte:component\u003C\u002Fspan\u003E&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Esvelte:window。把它当作是一个window对象，可以在该标签上进行事件的监听等操作。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Esvelte:body。和window的标签一样，可以在document.body上添加事件监听。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003Esvelte:head。允许你在页面的\u003Chead\u003E标签内插入内容。\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"language-html\"\u003E\u003Cspan class=\"hljs-section\"\u003E&lt;svelte:head&gt;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"hljs-section\"\u003E&lt;link&gt;\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-section\"\u003E&lt;\u002Flink&gt;\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-section\"\u003E&lt;\u002Fsvelte:head&gt;\u003C\u002Fspan\u003E\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E需要注意的是，在服务端渲染下，这个标签的内容将会单独返回到html中。\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');(function(){try{eval("async function x(){}");var main="/client/client.ab57a19f.js"}catch(e){main="/client/legacy/client.2d9a922f.js"};var s=document.createElement("script");try{new Function("if(0)import('')")();s.src=main;s.type="module";s.crossOrigin="use-credentials";}catch(e){s.src="/client/shimport@2.0.4.js";s.setAttribute("data-main",main);}document.head.appendChild(s);}());</script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-170295070-1"></script> <script> window.dataLayer = window.dataLayer || [];
		function gtag(){dataLayer.push(arguments);}
		gtag('js', new Date());

		gtag('config', 'UA-170295070-1'); </script> 