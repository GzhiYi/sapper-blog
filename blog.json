[{"title":"npm全局安装package出现EACCES permissions","slug":"2021_07_npm-global-EACCES","description":"npm全局安装包的时候有权限问题，提示permissions denied，尝试修改用户权限并未生效","keywords":null,"labels":["npm","linux","global","全局安装","权限","permission","denied","用户"],"date":"2021-07-16","path":"2021/07/npm-global-EACCES.md","html":"<p>如果在使用npm安装全局package的时候出现EACCES错误，可以这样解决：</p>\n<ol>\n<li>重新安装npm（推荐）。</li>\n<li>手动修改npm的默认目录。</li>\n</ol>\n<h3 id=\"重新安装npm\">重新安装npm</h3>\n<p>重新安装是最好的解决这个问题的办法。可以点击<a target='_blank'  href=\"https://docs.npmjs.com/downloading-and-installing-node-js-and-npm\">这里</a>看看重新安装的步骤。在安装node版本管理工具之前是不需要删除在你设备的当前的npm或者nodejs。</p>\n<h3 id=\"手动修改npm的默认目录\">手动修改npm的默认目录</h3>\n<blockquote>\n<p>这种方法不适用于windows平台。</p>\n</blockquote>\n<ol>\n<li>在终端中创建一个用于npm全局安装的目录.npm-global</li>\n</ol>\n<pre><code class=\"language-bash\">mkdir ~/.<span class=\"hljs-built_in\">npm</span>-<span class=\"hljs-built_in\">global</span>\n</code></pre>\n<ol start=\"2\">\n<li>配置npm为一个新的文件目录路径</li>\n</ol>\n<pre><code class=\"language-bash\">npm<span class=\"hljs-built_in\"> config </span><span class=\"hljs-builtin-name\">set</span><span class=\"hljs-built_in\"> prefix </span><span class=\"hljs-string\">&#x27;~/.npm-global&#x27;</span>\n</code></pre>\n<ol start=\"3\">\n<li>在~/.profile中增加下面这一行，没有这个文件的可以新建一个。</li>\n</ol>\n<pre><code class=\"language-bash\"><span class=\"hljs-builtin-name\">export</span> <span class=\"hljs-attribute\">PATH</span>=~/.npm-global/bin:$PATH\n</code></pre>\n<ol start=\"4\">\n<li>更新系统变量。</li>\n</ol>\n<pre><code class=\"language-bash\"><span class=\"hljs-keyword\">source</span> ~/.<span class=\"hljs-keyword\">profile</span>\n</code></pre>\n<ol start=\"5\">\n<li>测试看看还有没有权限报错。</li>\n</ol>\n<pre><code class=\"language-bash\">npm <span class=\"hljs-keyword\">install</span> -g jshint\n</code></pre>\n"},{"title":"lodash数组中chunk、compact方法","slug":"2021_07_lodash-array-chunk","description":"lodash中chunk、compac方法的使用，在业务中用到多少呢，怎么对数组使用chunk进行切割","keywords":"lodash,chunk,compact,array,数组,切割,源码分析,每天一个lodash函数","labels":["lodash"],"date":"2021-07-15","path":"2021/07/lodash-array-chunk.md","html":"<h2 id=\"chunk\">Chunk</h2>\n<p>lodash的chunk方法用于对数组进行按size切割。如果最后数组不满足size的长度，则剩余的部分会放到最后一个数组上。</p>\n<h3 id=\"使用\">使用</h3>\n<pre><code class=\"language-javascript\">const arr = <span class=\"hljs-comment\">[1, 2, 3, 4, 5]</span>\n_.chunk(arr, 2) // <span class=\"hljs-comment\">[<span class=\"hljs-comment\">[1, 2]</span>, <span class=\"hljs-comment\">[3, 4]</span>, <span class=\"hljs-comment\">[5]</span>]</span> \n</code></pre>\n<p>结果返回的是一个二维数组。开发了这么久，想了下这个函数所实现的功能需求貌似少之又少。</p>\n<h3 id=\"源码\">源码</h3>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\">function <span class=\"hljs-title\">chunk</span><span class=\"hljs-params\">(array, size = <span class=\"hljs-number\">1</span>)</span> </span>{ <span class=\"hljs-comment\">// 存在参数默认</span>\n  size = Math.<span class=\"hljs-built_in\">max</span>(<span class=\"hljs-built_in\">toInteger</span>(size), <span class=\"hljs-number\">0</span>)     <span class=\"hljs-comment\">// 【验证输入参数的合法性】toInteger会把传入的size转为整数</span>\n  <span class=\"hljs-keyword\">const</span> length = array == null ? <span class=\"hljs-number\">0</span> : array.length   <span class=\"hljs-comment\">//  【验证输入参数的合法性】计算传入数组的长度</span>\n  <span class=\"hljs-keyword\">if</span> (!length || size &lt; <span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">return</span> []\n  }\n  let index = <span class=\"hljs-number\">0</span>\n  let resIndex = <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Array</span>(Math.<span class=\"hljs-built_in\">ceil</span>(length / size)) <span class=\"hljs-comment\">//   这里新建一个包含切割结果个数的空数组，如[, , , ]</span>\n\n  <span class=\"hljs-keyword\">while</span> (index &lt; length) {\n    result[resIndex++] = <span class=\"hljs-built_in\">slice</span>(array, index, (index += size)) <span class=\"hljs-comment\">//    slice是封装的函数，可以切割回数组的第二个参数到第三个参数的值</span>\n  }\n  <span class=\"hljs-keyword\">return</span> result\n}\n</code></pre>\n<h2 id=\"compact\">compact</h2>\n<p>compact在字面上的意思是紧凑的，在lodash中，就是把一个数组中值为 <code>false</code>, <code>null</code>, <code>0</code>, <code>&quot;&quot;</code>, <code>undefined</code>, <code>NaN</code>的都剔除。</p>\n<h3 id=\"使用-1\">使用</h3>\n<pre><code class=\"language-javascript\"><span class=\"hljs-attribute\">_</span>.compact([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, false, <span class=\"hljs-number\">2</span>, &#x27;&#x27;, <span class=\"hljs-number\">3</span>]) // =&gt;<span class=\"hljs-meta\"> [1, 2, 3]</span>\n</code></pre>\n<p>业务中使用的也比较少。</p>\n<h3 id=\"源码-1\">源码</h3>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">compact</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">array</span>)</span> </span>{\n  <span class=\"hljs-keyword\">let</span> resIndex = <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\">//   貌似都喜欢把下标定位resIndex这个变量名。。</span>\n  <span class=\"hljs-keyword\">const</span> result = []\n\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">array</span> == <span class=\"hljs-keyword\">null</span>) {\n    <span class=\"hljs-keyword\">return</span> result\n  }\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> value of <span class=\"hljs-keyword\">array</span>) { <span class=\"hljs-comment\">//   这里用for of对数组进行遍历</span>\n    <span class=\"hljs-keyword\">if</span> (value) { <span class=\"hljs-comment\">//   核心的过滤就是这里，在if下，falsy的参数会被过滤掉。</span>\n      result[resIndex++] = value\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> result\n}\n</code></pre>\n<blockquote>\n<p>Lodash 源码理解 1</p>\n</blockquote>\n"},{"title":"vue获取不到dom节点","slug":"2021_06_vue-dom-not-found","description":"开发中出现拿不到dom节点的问题，在mounted后也读取不到节点","keywords":"vue，dom节点，node，获取不到，loading，echarts，渲染，图表","labels":["前端"],"date":"2021-06-29","path":"2021/06/vue-dom-not-found.md","html":"<p>在vue开发中，出现拿不到dom节点的问题，具体的场景是页面需要对echarts进行实例化，画布需要挂在到某个id的dom上，图表的数据需要从接口上获取，大致的代码如下：</p>\n<pre><code class=\"language-vue\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;pug&quot;</span>&gt;</span>\n  div#render-id\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-title\">mounted</span>(<span class=\"hljs-params\"></span>)</span> {\n      <span class=\"hljs-built_in\">this</span>.getChartData()\n    },\n    <span class=\"hljs-attr\">methods</span>: {\n      <span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-title\">getChartData</span>(<span class=\"hljs-params\"></span>)</span> {\n        <span class=\"hljs-comment\">// do fetch chart data</span>\n        <span class=\"hljs-built_in\">this</span>.renderChart()\n      },\n      <span class=\"hljs-function\"><span class=\"hljs-title\">renderChart</span>(<span class=\"hljs-params\"></span>)</span> {\n        <span class=\"hljs-keyword\">const</span> node = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;#render-id&#x27;</span>)\n        <span class=\"hljs-built_in\">console</span>.log(node) \n      }\n    }\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>出现的异常：</p>\n<pre><code> Cannot <span class=\"hljs-keyword\">read</span> <span class=\"hljs-keyword\">property</span><span class=\"hljs-title\"> </span>&#x27;getAttribute&#x27; of undefined<span class=\"hljs-string\">&quot;</span>\n</code></pre>\n<p>打印node节点发现为null。</p>\n<h3 id=\"问题解决\">问题解决</h3>\n<p>解决这个问题需要知道的是，获取不到节点的直接原因就是在query节点的时候render-id还没挂载到dom上。但会问，不是在mounted后才读这个节点吗？按照上面的代码逻辑，想法是正确的，即便是接口数据大，获取数据的时间长，也会在render-id这个元素挂载到dom后才会执行query操作。理论是不会出现读取不到该节点的问题。</p>\n<p>处理思路应该聚集在渲染dom有什么另外的操作会影响。总结无外乎就是：</p>\n<ol>\n<li>优先确认query节点的操作要在dom渲染完成后操作（这是核心思路）。</li>\n<li>检查有无异步的操作产生影响。比如元素需要在接口获取到之后写入到document，但写入前读取是会出现这样的问题的。</li>\n<li>检查获取的元素或者元素的外层是否有loading的操作。</li>\n<li>$nextTick(f)有时候会解决此类问题。</li>\n</ol>\n"},{"title":"svelte语法点小记","slug":"2021_06_svelte","description":"svelte和vue、react不同，在构建页面的时候语法需要和其余框架区别开，记录官方文档有助于理解使用。","keywords":"svelte, vue, react, 文档","labels":["前端","svelte"],"date":"2021-06-24","path":"2021/06/svelte.md","html":"<p>计划重写原本由sapper编写的博客，需要移除sapper，只用svelte和一般的构建即可。在此之前，需要花点时间学习（回顾）一下svelte的一下语法点，会和vue进行对比，暂不深入理解内部原理，单纯建立在官方文档的基础上。</p>\n<p>记录并不是所有细节都要兼顾。遇到和vue理念比较大，或者说这个语法并没有让我那么容易记住的知识点，我都会记录下来，并在后续闲暇的时间下进行回顾复习，有点类似于做一下错题本。</p>\n<ol>\n<li><p>变量和代码块都只需要放在一个花括号里面就好了。在vue里面是<code>{{}}</code>包裹，有点不同。不要有带入vue语法的惯性思维。</p>\n</li>\n<li><p>和vue类似，一个<code>.svelte</code>文件就是一个组件，包含了script、html、还有css。可以在另一个svelte组件中引入svelte组件。</p>\n</li>\n<li><p>{@html 字符串}，包裹的字符串会被转化为不信任来源的html代码，注意防止xss攻击。</p>\n</li>\n<li><p>当组件中的变量更新的时候，svelte会自动更新对应的dom。类似于vue中的计算属性，svelte是这么处理的：</p>\n<pre><code class=\"language-javascript\">const <span class=\"hljs-attr\">varable</span> = <span class=\"hljs-number\">0</span>\n$: <span class=\"hljs-attr\">varableName</span> = varable + <span class=\"hljs-number\">1</span>\n</code></pre>\n<p>其中<code>$:</code>就是可以标识变量为“计算属性”，其中varable变化的话，对应的varableName也会跟着变化。</p>\n<p><code>$:</code>不仅仅是标识变量为计算属性，还可以是一串代码块，在该代码块中的变量一旦发生变化，就会执行这个代码块，而如果没有变量变化，这一个代码块就不会执行。所以把这个符号理解为响应式定义符更好，官网提到的名词就叫响应式声明。</p>\n</li>\n<li><p>对于一般变量，直接赋值就可以产生响应式的效果，但如果是对象类型就不可以，比如数组的push等操作，就不会更新dom。svelte的解决方式有</p>\n<ol>\n<li><p>在数组操作之后，将结果数组赋值给原数组。</p>\n<pre><code class=\"language-js\">let num = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addNum</span></span>(<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">Num</span>) {\n  num.push(<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">Num</span>)\n}\n<span class=\"hljs-comment\">// 直接在html上调用这个addNum函数，是不会对num进行更新的，需要改为</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addNum</span></span>(<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">Num</span>) {\n  num.push(<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">Num</span>)\n  num = num\n}\n<span class=\"hljs-comment\">// 抑或者</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addNum</span></span>(<span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">Num</span>) {\n  num = [...num, <span class=\"hljs-keyword\">new</span><span class=\"hljs-type\">Num</span>]\n}\n</code></pre>\n</li>\n<li><p>对于对象属性的更新，可以直接赋值。</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> obj = {\n <span class=\"hljs-built_in\"> name</span>: <span class=\"hljs-string\">&#x27;cat&#x27;</span>\n}\n// 可以直接更新obj上<span class=\"hljs-built_in\">的name</span>属性\n<span class=\"hljs-keyword\">function</span> changeName(newName) {\n  obj<span class=\"hljs-built_in\">.name</span> = newName\n}\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<p>6.组件参数传递。和vue不一样，vue在一个组件中对传入参数是直接在props上进行声明的。而svelte是直接在组件内export参数。</p>\n<pre><code class=\"language-vue\">// 组件displayName.svelte\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&quot;name参数的默认值&quot;</span> <span class=\"hljs-comment\">// 这里就直接表示组件a具有一个name的参数，外部可以传递进来</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n\n// 组件b.svelte\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> DisplayName <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./displayName.svelte&#x27;</span>\n    <span class=\"hljs-keyword\">let</span> myName = <span class=\"hljs-string\">&#x27;cat&#x27;</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">DisplayName</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">{myName}</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">DisplayName</span>&gt;</span>\n\n</code></pre>\n<ol start=\"7\">\n<li><p>if块。初次感受肯定是没有vue方便快捷，但写多几遍之后，发现还是可以接受这样的一个语法糖。注意#号不能遗漏掉。</p>\n<pre><code class=\"language-vue\">{<span class=\"hljs-comment\">#if isTrue}</span>\n    <span class=\"hljs-regexp\">//</span> 执行为isTrue的html\n{:<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> 条件} <span class=\"hljs-regexp\">//</span> 这个是额外可能出现的条件\n{:<span class=\"hljs-keyword\">else</span>}\n    <span class=\"hljs-regexp\">//</span> 执行isTrue为false的html\n{/<span class=\"hljs-keyword\">if</span>}\n</code></pre>\n</li>\n<li><p>循环块。类比vue中的v-for。其中（）内的数值表示为id，可以有效更新dom。</p>\n<pre><code class=\"language-vue\"><span class=\"xml\">let arr = [\n    </span><span class=\"hljs-template-variable\">{\n        id: 1,\n        name: &#x27;cat&#x27;\n    }</span><span class=\"xml\">,\n    </span><span class=\"hljs-template-variable\">{\n        id: 2,\n        name: &#x27;dog&#x27;\n    }</span><span class=\"xml\">\n]\n</span><span class=\"hljs-template-tag\">{#<span class=\"hljs-name\">each</span> arr as item, index(item.id)}</span><span class=\"xml\">\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"hljs-template-variable\">{index}</span><span class=\"xml\">: </span><span class=\"hljs-template-variable\">{item.name}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</span><span class=\"hljs-template-tag\">{/<span class=\"hljs-name\">each</span>}</span><span class=\"xml\">\n// 用上解构，会更加简洁明了\n</span><span class=\"hljs-template-tag\">{#<span class=\"hljs-name\">each</span> arr as {id, name}</span><span class=\"xml\">, index(id)}\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"hljs-template-variable\">{index}</span><span class=\"xml\">: </span><span class=\"hljs-template-variable\">{id}</span><span class=\"xml\"> </span><span class=\"hljs-template-variable\">{name}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n</code></pre>\n</li>\n<li><p>await块。没想到真的有这个东西，可以直接拿来判断一个promise在多个状态下的表现，这可以说不用写那一堆loading了，大致的代码如下：</p>\n<pre><code class=\"language-vue\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">let</span> promise = getDataFromUrl()\n  <span class=\"hljs-keyword\">async</span> getDataFromUrl() </span></span><span class=\"hljs-template-variable\">{}</span><span class=\"xml\">\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n// 直接拿promise就像是一个promise一样在html中await\n</span><span class=\"hljs-template-tag\">{#<span class=\"hljs-name\">await</span> promise}</span><span class=\"xml\">\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>正在请求中...<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</span><span class=\"hljs-template-variable\">{:then res}</span><span class=\"xml\">\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>返回的内容</span><span class=\"hljs-template-variable\">{res}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</span><span class=\"hljs-template-variable\">{:catch error}</span><span class=\"xml\">\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>请求出现异常<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</span><span class=\"hljs-template-tag\">{/<span class=\"hljs-name\">await</span>}</span><span class=\"xml\">\n\n// 抑或者，你不需要展示loading以及catch错误的话，可以直接then出来\n</span><span class=\"hljs-template-tag\">{#<span class=\"hljs-name\">await</span> promise then res}</span><span class=\"xml\">\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>返回的内容</span><span class=\"hljs-template-variable\">{res}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</span><span class=\"hljs-template-tag\">{/<span class=\"hljs-name\">await</span>}</span>\n</code></pre>\n</li>\n<li><p>事件处理。通过on定义符进行事件绑定。</p>\n<pre><code class=\"language-vue\">&lt;<span class=\"hljs-keyword\">button</span> <span class=\"hljs-keyword\">on</span>:click={事件名}&gt;点击&lt;/<span class=\"hljs-keyword\">button</span>&gt;\n<span class=\"hljs-comment\">// on后面接上原生的事件就好了，比如click、mousemove等</span>\n<span class=\"hljs-comment\">// 事件名可以替换为代码块，如</span>\n&lt;<span class=\"hljs-keyword\">button</span> <span class=\"hljs-keyword\">on</span>:click={e =&gt; {<span class=\"hljs-comment\">// 对变量进行操作}&gt;点击&lt;/button&gt;</span>\n</code></pre>\n<p>有些框架由于性能的原因建议不要用行内的方式写事件，尤其是在循环里面。但svelte并没有这个问题，你可以直接用而不用担心那些琐碎，svelte总会做到最好。</p>\n<p>事件修饰符，可以对事件进行几个有用的修饰。以previewDefault举例：</p>\n<pre><code class=\"language-vue\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">on:click</span>|<span class=\"hljs-attr\">preventDefault</span>=<span class=\"hljs-string\">{事件名}</span>&gt;</span>点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</code></pre>\n<ol>\n<li>preventDefault 阻止默认事件。</li>\n<li>stopPropagation 阻止事件冒泡。</li>\n<li>passive 优化对touch、wheel事件的滚动表现。</li>\n<li>capture 在 <em>capture</em> 阶段而不是<em>bubbling</em> 阶段触发事件处理程序。</li>\n<li>once 事件只运行一次就删除绑定。</li>\n<li>self 仅当 event.target 是其本身时才执行。</li>\n</ol>\n<p>以上修饰符可以串联使用。</p>\n</li>\n<li><p>组件通信。老生常谈，业务中遇到的太多了。</p>\n<pre><code class=\"language-vue\"><span class=\"hljs-comment\">// 父组件 parent.svelte</span>\n&lt;script&gt;\n    <span class=\"hljs-keyword\">import</span> child <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./child.svelte&#x27;</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sayHello</span>(<span class=\"hljs-params\">name</span>) </span>{\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Hi, <span class=\"hljs-subst\">${name}</span>`</span>)\n  }\n&lt;/script&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">child</span> <span class=\"hljs-attr\">on:say</span>=<span class=\"hljs-string\">{sayHello}</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">child</span>&gt;</span></span>\n\n<span class=\"hljs-comment\">// 子组件 child.svelte</span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-comment\">// 子组件要调用父组件的事件，需要用到事件派发器</span>\n  <span class=\"hljs-keyword\">import</span> { createEventDispatcher } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;svelte&#x27;</span>\n  <span class=\"hljs-keyword\">const</span> dispatch = createEventDispatcher()\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">sayHello</span>(<span class=\"hljs-params\"></span>) </span>{\n    <span class=\"hljs-comment\">// 这里的话有些类似vue中的$emit</span>\n    dispatch(<span class=\"hljs-string\">&#x27;say&#x27;</span>, {\n      <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;我&#x27;</span>\n    })\n  }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">on:click</span>=<span class=\"hljs-string\">{sayHello}</span>&gt;</span>点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"hljs-comment\">// 如果是dom事件，那么子组件只要不具名，就可以直接调用父组件的事件</span>\n<span class=\"hljs-comment\">// 父组件事件定义</span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">on:click</span>=<span class=\"hljs-string\">{eventName}</span>&gt;</span>点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n<span class=\"hljs-comment\">// 如果子组件想直接调用dom事件eventName，则</span>\n<span class=\"hljs-comment\">// 子组件</span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">on:click</span>&gt;</span>点击<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n</code></pre>\n<p>如果组件嵌套，需要多次转发事件的话，可以把中间的组件都加一个on:eventName，那么事件名为eventName的事件就会一直转发到目标组件上。</p>\n<p><em>2021-06-01 23:20</em></p>\n</li>\n</ol>\n<p>12.双向绑定。和vue原理对比TODO。在svelte中的双向绑定，只需要通过bind修饰就可以。</p>\n<pre><code class=\"language-vue\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">let</span> name = <span class=\"hljs-string\">&#x27;cat&#x27;</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">bind:value</span>=<span class=\"hljs-string\">{name}</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">input</span>&gt;</span>\n</code></pre>\n<p>表单元素都可以通过bind进行双向绑定，比如checkbox等。</p>\n<p>对数组对象，可以直接对值进行循环绑定，这个和vue类似。</p>\n<p>每个块级标签都可以对<code>clientWidth</code>、<code>clientHeight</code>、<code>offsetWidth</code>、<code>offsetHeight</code>进行绑定。但绑定值只是可读，直接赋值不会进行更新。可以用在读取块元素的尺寸后用于展示等业务上。</p>\n<ol start=\"13\">\n<li><p>组件绑定。这个有点意思，我觉得像是vue中的.sync修饰。可以做到在父组件中直接读取子组件export的值。</p>\n</li>\n<li><p>生命周期。类比vue的生命周期，svelte的生命周期钩子还是很容易理解的。</p>\n</li>\n</ol>\n<p>在svelte中，每一个组件都有其完整的生命周期，周期的函数需要从svelte中引入。</p>\n<ul>\n<li><p><code>onMount</code>。使用最多的应该是<code>onMount</code>钩子，它在组件渲染到dom后执行。可以在这个周期内进行数据的请求操作，这是svelte所推荐的，如果把请求操作放到script内则不好，因为如果需要服务端渲染的话，生命周期函数是没法在服务端渲染过程中执行的。</p>\n</li>\n<li><p><code>onDestroy</code>。组件销毁的时候调用，可以对计时器进行清除等操作。文档中有一个有意思的封装，可以把计数器的操作和组件销毁时销毁计时器一起封装。</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 比如封装到util.js中</span>\nimoprt { onDestroy } from &#x27;svelte&#x27;\nexport <span class=\"hljs-keyword\">function</span> on<span class=\"hljs-constructor\">Interval(<span class=\"hljs-params\">callback</span>, <span class=\"hljs-params\">time</span>)</span> {\n  const interval = set<span class=\"hljs-constructor\">Interval(<span class=\"hljs-params\">callback</span>, <span class=\"hljs-params\">time</span>)</span>\n  on<span class=\"hljs-constructor\">Destroy(()</span> =&gt; {\n    clear<span class=\"hljs-constructor\">Interval(<span class=\"hljs-params\">interval</span>)</span>\n  })\n}\n</code></pre>\n<p>那么在组件中就可以直接引入onInterval并调用，那就不需要关切组件销毁的时候有没有把计时器进行销毁。</p>\n<pre><code class=\"language-vue\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n  <span class=\"hljs-keyword\">import</span> </span></span><span class=\"hljs-template-variable\">{ onInterval }</span><span class=\"xml\"><span class=\"javascript\"> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./util.js&#x27;</span>\n  onInterval(<span class=\"hljs-function\">() =&gt;</span> </span></span><span class=\"hljs-template-variable\">{}</span><span class=\"xml\">, 1000)\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n</li>\n<li><p><code>beforeUpdate</code>、<code>afterUpdate</code>。该钩子在DOM渲染完成前执行。场景例如：渲染标签的滚动位置。</p>\n</li>\n<li><p><code>tick</code>。可以随时调用，是一个带有resolve方法的promise，解释是每当组件pendding状态变化就会立即提现到DOM中，类似于vue的<code>$nextTick()</code>?</p>\n</li>\n</ul>\n<ol start=\"15\">\n<li><p>store。svelte自带了壮态管理，由引入自svelte/store的writable定义：</p>\n<p><strong>可写store</strong></p>\n<pre><code class=\"language-javascript\">imoprt { writable } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;svelte/store&#x27;</span>\n\nexport <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">count</span> = writable(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// 默认值为0，这里注意可以使用const进行定义，即便count是一个数值</span>\n</code></pre>\n<p>在组件中，count具备update、set方法，分别表示更新和重置值。</p>\n<p>在store创建后，开启的事件订阅，需要在不使用的时候销毁。我们可以在组件的onDestroy周期中取消订阅，避免内存溢出。</p>\n<pre><code class=\"language-vue\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n    <span class=\"hljs-keyword\">import</span> </span></span><span class=\"hljs-template-variable\">{ onDestroy }</span><span class=\"xml\"><span class=\"javascript\"> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;svelte&#x27;</span>\n  <span class=\"hljs-keyword\">import</span> </span></span><span class=\"hljs-template-variable\">{ count }</span><span class=\"xml\"><span class=\"javascript\"> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./store.js&#x27;</span>\n  \n  <span class=\"hljs-keyword\">let</span> countValue\n  <span class=\"hljs-keyword\">const</span> unsubscribe = count.subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">value</span> =&gt;</span> </span></span><span class=\"hljs-template-variable\">{ // 手动订阅\n    count_value = value\n  }</span><span class=\"xml\"><span class=\"javascript\">)\n  onDestroy(unsubscribe) <span class=\"hljs-comment\">// 在组件销毁的时候取消订阅</span>\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<p>那如果每一个状态都需要这么订阅和销毁的话，就太冗余了，svelte提供一个$符。可以对状态自动进行订阅和取消订阅。yyds。</p>\n<pre><code class=\"language-vue\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scirpt</span>&gt;</span>\n    imoprt </span><span class=\"hljs-template-variable\">{ count }</span><span class=\"xml\"> from &#x27;./store.js&#x27;\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scirpt</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span> </span><span class=\"hljs-template-variable\">{$count}</span><span class=\"xml\"> <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span>\n</code></pre>\n<p><strong>只读store</strong></p>\n<p>只需在定义的时候，由writable改为readable就可以定义一个只读的store。</p>\n<p><strong>防止暴露set、update方法的自定义store</strong></p>\n<pre><code class=\"language-javascript\">import { writable } from <span class=\"hljs-string\">&#x27;svelte/store&#x27;</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createCount</span>(<span class=\"hljs-params\"></span>) </span>{\n  const { subscribe, set, update } = writable(<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-keyword\">return</span> {\n    subscribe,\n    <span class=\"hljs-attr\">increment</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> update(<span class=\"hljs-function\"><span class=\"hljs-params\">n</span> =&gt;</span> n + <span class=\"hljs-number\">1</span>),\n    <span class=\"hljs-attr\">decrement</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> update(<span class=\"hljs-function\"><span class=\"hljs-params\">n</span> =&gt;</span> n - <span class=\"hljs-number\">1</span>),\n    <span class=\"hljs-attr\">reset</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> set(<span class=\"hljs-number\">0</span>)\n  }\n}\n</code></pre>\n</li>\n<li><p>class指令。在svelte中动态设置class或者说其余的dom属性，会和vue有一些不一样。</p>\n<pre><code class=\"language-vue\">&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-keyword\">class</span>=<span class=\"hljs-string\">&quot;{isTrue ? &#x27;true-class&#x27; : &#x27;false-class&#x27;}&quot;</span>&gt;\n  name\n&lt;/<span class=\"hljs-keyword\">div</span>&gt;\n&lt;<span class=\"hljs-keyword\">div</span> <span class=\"hljs-keyword\">class</span>:selected=<span class=\"hljs-string\">&quot;{isTrue}&quot;</span>&gt; <span class=\"hljs-comment\">// 之后留意如何设置camel-case的class名</span>\n  name\n&lt;/<span class=\"hljs-keyword\">div</span>&gt;\n</code></pre>\n</li>\n<li><p>组件插槽，和vue的思想一样，这里看文档注意多个插槽怎么具名。</p>\n<pre><code class=\"language-vue\">// 例如slot.svelte\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">slot</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;slot-a&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">slot</span>&gt;</span>\n\n// 调用的组件\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Slot</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">slot</span>=<span class=\"hljs-string\">&quot;slot-a&quot;</span>&gt;</span>\n    这里是一个具名插槽\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">Slot</span>&gt;</span>\n</code></pre>\n</li>\n</ol>\n<p>18.context API。通过context api，可以跨越组件进行通信。具备setContext和getContext两个api。如果在一个组件中调用了setContext(key, context)，那么，在所有该子组件中都可以调用该context。</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 父组件中</span>\nset<span class=\"hljs-constructor\">Context(<span class=\"hljs-params\">key</span>, <span class=\"hljs-params\">context</span>)</span>\n<span class=\"hljs-comment\">// 任意的子组件中</span>\nconst context = get<span class=\"hljs-constructor\">Context(<span class=\"hljs-params\">key</span>)</span>\n</code></pre>\n<ol start=\"19\">\n<li><p>特殊标签。svelte具备一些特殊的标签。</p>\n<ul>\n<li><p>svelte:self。允许组件递归的去包含自己本身。</p>\n</li>\n<li><p>svelte:component。动态组件，与vue类似的用法，通过传入this的组件名，动态挂在组件。</p>\n<pre><code class=\"language-vue\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">svelte:component</span> <span class=\"hljs-attr\">this</span>=<span class=\"hljs-string\">{compnentName}</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">svelte:component</span>&gt;</span>\n</code></pre>\n</li>\n<li><p>svelte:window。把它当作是一个window对象，可以在该标签上进行事件的监听等操作。</p>\n</li>\n<li><p>svelte:body。和window的标签一样，可以在document.body上添加事件监听。</p>\n</li>\n<li><p>svelte:head。允许你在页面的<head>标签内插入内容。</p>\n<pre><code class=\"language-html\"><span class=\"hljs-section\">&lt;svelte:head&gt;</span>\n  <span class=\"hljs-section\">&lt;link&gt;</span><span class=\"hljs-section\">&lt;/link&gt;</span>\n<span class=\"hljs-section\">&lt;/svelte:head&gt;</span>\n</code></pre>\n<p>需要注意的是，在服务端渲染下，这个标签的内容将会单独返回到html中。</p>\n</li>\n</ul>\n</li>\n</ol>\n"},{"title":"预备回归写博客啦","slug":"2021_04_ready-back","description":"回归博客，整理项目代码结构","keywords":"sapper，blog，return，回归，整理","labels":[],"date":"2021-04-24","path":"2021/04/ready-back.md","html":"<p>日子趋于平稳，技术栈也比较稳定，外加自己有一些些懒惰，所以博客停更蛮久了。在github查看了这个项目，发现还有几个人star了，所以我决定需要好好整理一下这个项目。</p>\n<h2 id=\"计划\">计划</h2>\n<p>更新博客内容次于整理sapper-blog这个项目。看了下是去年写的代码，问题主要存在有：</p>\n<ol>\n<li>项目结构混论。</li>\n<li>代码布局和提示性差。</li>\n<li>生成的静态内容样式差。</li>\n<li>存在一些不必要的内容。</li>\n<li>编写体验不够完善。</li>\n<li>。。。。。。</li>\n</ol>\n<p>后续主要的计划有：</p>\n<ol>\n<li>好好认真了解和熟悉svelte以及sapper的语法。</li>\n<li>整理项目结构和代码。</li>\n<li>移除ts支持。</li>\n<li>优化静态博客样式。</li>\n<li>优化博客编写的体验，现在有些一头雾水。</li>\n</ol>\n<h2 id=\"整理内容\">整理内容</h2>\n<p>在优化项目的过程中，整理一下相关知识点的代码，如果有必要的内容，我会整理到博客之中。</p>\n"},{"title":"苹果新手机发布会","slug":"2020_10_apple","description":"围观10月14日苹果发布会，我对此有什么看法。","keywords":"Apple，iphone 12，homepod","labels":[],"date":"2020-10-14","path":"2020/10/apple.md","html":"<p>好久没更新博客内容了。懒了些，加之最近公司项目迭代很多，虽然可以把控但要写的代码还是挺多的。  </p>\n<p>今天凌晨苹果开了一个线上的发布会，我特意晚一些睡觉，在1点的时候看了会直播，当时有个小疑问：为啥B站要屏蔽up主的苹果发布会转播呢？因为屏蔽了，加上内容和wb上讨论的几乎无差，所以我就关闭手机乖乖睡觉去了【实在是困】。</p>\n<h2 id=\"新产品的看法\">新产品的看法</h2>\n<p>iphone系列。由于我没有换机的需求，对于新的手机，第一我觉得外观虽然延续了4s那一代，但我觉得配合全面屏的iphone有不错的视觉体验。第二是12是走量，颜色多，但就个人而言，我会选择尺寸较小的mini。当然，如果对拍照需求大的，直接上pro。</p>\n<p>homepod。发布会首先发布的就是homepod，个人很喜欢，已经考虑以后会在房间设备和家里添加多个homepod。外观喜欢，小巧玲珑。放家里感觉挺好看。【吃灰神器】</p>\n<h2 id=\"吐槽\">吐槽</h2>\n<ol>\n<li>没有双卡。</li>\n<li>为了低碳和环保，苹果决定iphone13不再附赠手机。</li>\n<li>个人不喜oled屏幕，lcd真香。</li>\n<li>5g貌似国行有阉割。</li>\n</ol>\n"},{"title":"safari出现未设置title属性却显示ttile弹窗的问题","slug":"2020_07_text-ellipsis-title","description":"在safari浏览器下，出现dom未设置title属性，但hover过去会显示一个title的问题。","keywords":"css, text ellipsis, title popover, no title attribute，safari","labels":["前端"],"date":"2020-07-06","path":"2020/07/text-ellipsis-title.md","html":"<p>在safari浏览器下，出现dom未设置title属性，但hover过去会显示一个title的问题。如图：</p>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/86565425-634bc400-bf9a-11ea-8daf-76cba18e2936.jpg\" alt=\"Xnip2020-07-06_14-08-29\" ></p>\n<p>一开始一直往title属性上找问题，但dom的属性结构光溜溜的，并没有任何title有关的属性。这个问题在chrome和firefox都没有，只有在safari上出现。</p>\n<h2 id=\"问题所在\">问题所在</h2>\n<p>经过一顿排查，发现是css设置为文本超出省略显示后才会有这个问题。</p>\n<p>我们常用到文本超出省略的设置，如：</p>\n<pre><code class=\"language-css\"><span class=\"hljs-selector-class\">.text-ellipsis</span> {\n    <span class=\"hljs-attribute\">overflow</span>: hidden;\n  <span class=\"hljs-attribute\">text-overflow</span>: ellipsis;\n  <span class=\"hljs-attribute\">word-break</span>: keep-all;\n  <span class=\"hljs-attribute\">white-space</span>: nowrap;\n}\n</code></pre>\n<h2 id=\"解决办法\">解决办法</h2>\n<p>在<code>text-ellipsis</code>包裹的元素中添加一个空的block元素。如：</p>\n<pre><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;text-ellipsis ...&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">span</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">span</span>&gt;</span>\n    this is a long text!!!!!!!!\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"css\">\n<span class=\"hljs-selector-class\">.text-ellipsis</span> {\n    <span class=\"hljs-attribute\">overflow</span>: hidden;\n    <span class=\"hljs-attribute\">text-overflow</span>: ellipsis;\n    <span class=\"hljs-attribute\">word-break</span>;\n    <span class=\"hljs-attribute\">white-space</span>: nowrap;\n}\n<span class=\"hljs-selector-class\">.text-ellipsis</span> <span class=\"hljs-selector-tag\">span</span> {\n    <span class=\"hljs-attribute\">display</span>: block;\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n</code></pre>\n"},{"title":"最近安装宽带的问题","slug":"2020_07_boardband","description":"在外漂泊，定居之后的宽带怎么处理？经过一小阵子的了解，觉得开通宽带虽然简单，但利益还是有好多。","keywords":"宽带，租房，光纤，小区","labels":["随想"],"date":"2020-07-04","path":"2020/07/boardband.md","html":"<p>上一个租客留给我大概有3个月的免费宽带【白嫖】。入住新地已经过去好几个月，前天起床发现WIFI无法上网，小爱同学也没有了声音。我也趁着这次宽带安装的机会，了解下一些有关租房网络的实践。</p>\n<h2 id=\"能不能用4g代替宽带？\">能不能用4G代替宽带？</h2>\n<p>4g有非常好的便携性，不需要安装，不需要人工。直接买4g卡以及4g移动路由器插上就可以直接上网。在2020年，我第一时间就想到这个方案，因为我目前用的是联通卡，带有一些app免流的功能，一个月下来费用基本不会超过30元。况且呆在家的时间很少，大部分在家的时间都在睡觉，而在上班的地方有WIFI。</p>\n<p>另外的一些原因：</p>\n<ol>\n<li>不玩游戏，也就是不需要很低的延迟。</li>\n<li>房子不会很大，如果4g信号不好，再不济也可以通过桥接方式扩大信号。</li>\n<li>没有麻烦的服务，开通后自由使用，不用有退宽带的问题。</li>\n</ol>\n<p>那4g流量卡代替宽带是不是就非常完美了呢？</p>\n<p>😯，找了相关的资料，发现并不是这样。</p>\n<p> <strong>其实4g卡配4g路由是可以达到在租房内上网的条件的</strong>。但问题就出在流量上。如果是所谓的物联网卡，很容易出现跑路而不能用的问题。当然更大的问题是限速，达到某个流量值之后会出现令人恶心的限速。而我个人的需求，很大可能会有看剧看电影，下载体积大的安装包，比如xCode就有5g以上。所以我最后慢慢放弃这个方案，乖乖的去新报装宽带。</p>\n<h2 id=\"宽带\">宽带</h2>\n<p>通过网上和手机wx公众号的一些运营商的咨询，发现三大运营商在100M的宽带费用上都普遍较高。而对于这些宽带提供商，在新报装的时候都会有让我难以理解的上门安装费和调试费。我所在小区内已经有可以直接连接上网的端口，甚至上家租客已留下一些上网的设备，也就是说，只需要关联一个账号，将上网的端口和我本地的端口能关联就好了。这看起来简直就完全不需要人工，如果需要，我想也是基本的在电脑上动动配置就好了。</p>\n<p><strong>但看到各种宽带的套餐上，全都包含了比较高的宽带安装和调试费。</strong></p>\n<p>我觉得难以理解，但综合更方面的因素之后，还是选择宽带的报装，😠。</p>\n"},{"title":"Visual Studio Code快速上下滚动光标","slug":"2020_06_vscode-up-down-quickly","description":"默认上下按键滚动光标是在太慢，有方法可以加快滚动速度。","keywords":"vs code, scroll,speed up, up,down,cursor","labels":["工具"],"date":"2020-06-30","path":"2020/06/vscode-up-down-quickly.md","html":"<p>设置光标快速滚动，可以在少动鼠标的情况下快速滚动到目标代码处，结合常用的快捷键，可以提高编码效率。</p>\n<h2 id=\"设置\">设置</h2>\n<p>在vscode，打开设置-键盘快捷方式，点击下图打开<a target='_blank'  href=\"https://code.visualstudio.com/docs/getstarted/keybindings#_advanced-customization\">keybindings.json</a>。</p>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://i.loli.net/2020/06/30/5IA78WnLfSpmeJP.jpg\" alt=\"Xnip2020-06-30_17-21-04.jpg\" ></p>\n<p>在json底部添加：</p>\n<pre><code class=\"language-json\">  {\n    <span class=\"hljs-string\">&quot;key&quot;</span>: <span class=\"hljs-string\">&quot;cmd+up&quot;</span>,\n    <span class=\"hljs-string\">&quot;command&quot;</span>: <span class=\"hljs-string\">&quot;cursorMove&quot;</span>,\n    <span class=\"hljs-string\">&quot;args&quot;</span>: {\n      <span class=\"hljs-string\">&quot;to&quot;</span>: <span class=\"hljs-string\">&quot;up&quot;</span>,\n      <span class=\"hljs-string\">&quot;by&quot;</span>: <span class=\"hljs-string\">&quot;line&quot;</span>,\n      <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-number\">3</span>\n    },\n    <span class=\"hljs-string\">&quot;when&quot;</span>: <span class=\"hljs-string\">&quot;editorTextFocus&quot;</span>\n  },\n  {\n    <span class=\"hljs-string\">&quot;key&quot;</span>: <span class=\"hljs-string\">&quot;cmd+down&quot;</span>,\n    <span class=\"hljs-string\">&quot;command&quot;</span>: <span class=\"hljs-string\">&quot;cursorMove&quot;</span>,\n    <span class=\"hljs-string\">&quot;args&quot;</span>: {\n      <span class=\"hljs-string\">&quot;to&quot;</span>: <span class=\"hljs-string\">&quot;down&quot;</span>,\n      <span class=\"hljs-string\">&quot;by&quot;</span>: <span class=\"hljs-string\">&quot;line&quot;</span>,\n      <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-number\">3</span>\n    },\n    <span class=\"hljs-string\">&quot;when&quot;</span>: <span class=\"hljs-string\">&quot;editorTextFocus&quot;</span>\n  }\n</code></pre>\n<p>可以将cmd更改为未占用或者舒服的按键。</p>\n<p>可以将value更改为自己舒适的一次按键滚动行数。</p>\n<p>找了好久的办法，就想实现快速滚动，因为平时如果键盘和鼠标切换多了，总有种<strong>代码输出伤害溢出大</strong>的感觉。</p>\n"},{"title":"博客评论更改为valine并增加评论推送","slug":"2020_06_valine-and-notifications","description":"评论模块由gitalk转为valine，通过techulus的push进行评论推送","keywords":"sapper,blog,techulus push,valine,comments","labels":["前端"],"date":"2020-06-29","path":"2020/06/valine-and-notifications.md","html":"<p>通过一点时间的使用，发现gitalk可以解决静态博客评论问题，是挺方便的，但综合考虑下，存在以下两个缺点：</p>\n<ol>\n<li>需要github账号登录。</li>\n<li>访问非常慢。</li>\n</ol>\n<p>有意间，发现一个评论插件很适合静态博客植入：<a target='_blank'  href=\"https://valine.js.org/\">Valine</a>。</p>\n<p>新样式</p>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://i.loli.net/2020/06/29/RiSBpcyAQD1kXCN.jpg\" alt=\"style\" ></p>\n<p>新评论模块默认很清新，和我当前的样式较为符合，只做了一点点的样式覆盖。</p>\n<pre><code class=\"language-css\"><span class=\"hljs-comment\">/* valine 样式覆盖 */</span>\n<span class=\"hljs-selector-class\">.v</span><span class=\"hljs-selector-attr\">[data-class=v]</span> <span class=\"hljs-selector-class\">.vwrap</span> {\n    <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid rgba(<span class=\"hljs-number\">255</span>, <span class=\"hljs-number\">62</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.1</span>) <span class=\"hljs-meta\">!important</span>;\n}\n<span class=\"hljs-selector-class\">.v</span><span class=\"hljs-selector-attr\">[data-class=v]</span> <span class=\"hljs-selector-class\">.vwrap</span> <span class=\"hljs-selector-class\">.vheader</span> <span class=\"hljs-selector-class\">.vinput</span> {\n    <span class=\"hljs-attribute\">border-bottom</span>: none <span class=\"hljs-meta\">!important</span>;\n}\n<span class=\"hljs-selector-class\">.v</span><span class=\"hljs-selector-attr\">[data-class=v]</span> <span class=\"hljs-selector-class\">.txt-right</span> {\n    <span class=\"hljs-attribute\">display</span>: none <span class=\"hljs-meta\">!important</span>;\n}\n</code></pre>\n<h2 id=\"推送\">推送</h2>\n<p>在valine的文档中，有提到可以用一个扩展的valine-admin以实现评论通知功能。我在leancloud尝试了发现比较麻烦。外加之前使用GitHub Actions用到了一个推送服务实现了在action成功之后推送部署成功的通知到手机上。那是不是可以通过下面的思路去实现评论推送呢？</p>\n<blockquote>\n<p><a target='_blank'  href=\"https://push.techulus.com/\">PUSH注册</a>注册后使用免费的plan，可以每月100条推送限额。要推送到手机，只需要调用提供的接口还有下载一个手机APP就好了。</p>\n</blockquote>\n<p>要知道，做到推送到手机，只需要POST下面的接口：</p>\n<pre><code class=\"language-bash\">https:<span class=\"hljs-regexp\">//</span>push.techulus.com<span class=\"hljs-regexp\">/api/</span>v1<span class=\"hljs-regexp\">/notify/</span>{YOU API KEY}?title=Push by Techulus&amp;body=This is your first push notification\n</code></pre>\n<ol>\n<li>在评论接口POST请求之后，在lean端通过类似拦截/触发的方法调用推送接口。</li>\n<li>在网页端拦截POST请求，在评论发出之后，在调用推送接口。</li>\n</ol>\n<p>在查看对应文档之后，第一种方式我找不到可行的入口。我想确定数据库入库的逻辑在哪处理的也找不到，所以采用第二种方法。</p>\n<h2 id=\"拦截评论请求\">拦截评论请求</h2>\n<ol>\n<li>博客引入ajax-hook全局拦截请求</li>\n</ol>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;https://unpkg.com/ajax-hook@2.0.3/dist/ajaxhook.min.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<ol start=\"2\">\n<li><p>在ajax-hook实例上，处理onRequest钩子。</p>\n<pre><code class=\"language-javascript\">ah.proxy({\n         <span class=\"hljs-regexp\">//</span>请求发起前进入\n         onRequest: (config, handler) =&gt; {\n             <span class=\"hljs-keyword\">if</span> (config.url.includes(<span class=\"hljs-string\">&#x27;classes/Comment&#x27;</span>) &amp;&amp; config.method === <span class=\"hljs-string\">&#x27;POST&#x27;</span>) {\n                 console.log(<span class=\"hljs-string\">&#x27;请求发起前&#x27;</span>, config.body)\n                 fetch(\n                     `https:<span class=\"hljs-regexp\">//</span>push.techulus.com<span class=\"hljs-regexp\">/api/</span>v1<span class=\"hljs-regexp\">/notify/</span><span class=\"hljs-variable\">${YOU API KEY}</span>?title=<span class=\"hljs-variable\">${location.pathname || &#x27;文章&#x27;}</span>有新回复&amp;body=<span class=\"hljs-variable\">${config.body.substr(12, 30)}</span>`,\n                     {\n                         method: <span class=\"hljs-string\">&#x27;POST&#x27;</span>,\n                         mode: <span class=\"hljs-string\">&#x27;cors&#x27;</span>,\n                         headers: new Headers({\n                             <span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>: <span class=\"hljs-string\">&#x27;application/json&#x27;</span>\n                         })\n                     }\n                 )\n             }\n             handler.<span class=\"hljs-keyword\">next</span>(config);\n         },\n         <span class=\"hljs-regexp\">//</span>请求发生错误时进入，比如超时；注意，不包括http状态码错误，如<span class=\"hljs-number\">404</span>仍然会认为请求成功\n         onError: (err, handler) =&gt; {\n                 handler.<span class=\"hljs-keyword\">next</span>(err)\n         },\n         <span class=\"hljs-regexp\">//</span>请求成功后进入\n         onResponse: (response, handler) =&gt; {\n                 handler.<span class=\"hljs-keyword\">next</span>(response)\n         }\n     })\n</code></pre>\n<p>更多关于ajax-hook的文档，参阅：<a target='_blank'  href=\"https://github.com/wendux/Ajax-hook\">ajax-hook</a>    </p>\n</li>\n</ol>\n<h2 id=\"缺点提示\">缺点提示</h2>\n<p>第一种方式可以很好的保护推送的API KEY，因为有限额，暴露后可以随意调用。第二种比较简单易行。不过，反正push服务免费的话，也不会有损失。如果push服务付费就不要用第二种方法了。</p>\n<p>完成以上操作就可以收到评论推送啦，还是很方便的。如果有更好的免费push服务提供的，可以评论留言，我会很快看到的。</p>\n"},{"title":"用firebase给静态博客页面增加点赞功能","slug":"2020_06_firebase","description":"用firebase给静态博客页面增加点赞功能","keywords":"firebase,like","labels":["前端"],"date":"2020-06-28","path":"2020/06/firebase.md","html":"<p>想给博客增加一个点赞功能。最后，看起来就是这样：</p>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://i.loli.net/2020/06/28/Ej9in7gr5uNHIJO.jpg\" alt=\"like\" ></p>\n<p>实现这个功能要考虑几个问题：</p>\n<ol>\n<li>没有服务器，接口怎么编写部署？</li>\n<li>博客没有登录，数据库设计的时候怎么识别用户唯一性。</li>\n</ol>\n<h2 id=\"firebase\">Firebase</h2>\n<p>对于firebase的介绍，最好是直接进入<a target='_blank'  href=\"https://firebase.google.com\">主站</a>开通spark版尝试。</p>\n<p>使用firebase，就可以很好的解决第一个问题。spark方案提供免费的空间支持，对于博客这种量级小，交互少的页面来说再适合不过了。</p>\n<p>如果用过tx云的云开发，就可以知道，其实概念有些相似，甚至在云函数的编写上也有几分相似。</p>\n<h2 id=\"fingerprintjs2\">fingerprintjs2</h2>\n<p>利用<a target='_blank'  href=\"https://github.com/fingerprintjs/fingerprintjs2\">fingerprintjs2</a>，可以通过user agent等信息生成用户唯一的一个ID，虽然不能100%保证用户唯一性，但对于无需登录的博客而言，已经足够了。\n生成指纹的主要用法：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-attribute\">Fingerprint2</span>.x<span class=\"hljs-number\">64</span>hash<span class=\"hljs-number\">128</span>(values.join(&#x27;&#x27;), <span class=\"hljs-number\">31</span>)\n</code></pre>\n<h2 id=\"过程\">过程</h2>\n<p>整个过程，时间大部分花在云函数执行数据库操作语法上。以下前提是开通了firebase的spark方案，开通方式直接明了就不赘述啦。</p>\n<h3 id=\"控制台\">控制台</h3>\n<p>需要在控制台创建你的一个项目，创建好项目之后再执行下面的步骤。</p>\n<h3 id=\"函数（functions）编写\">函数（functions）编写</h3>\n<p>相关代码可以查看：<a target='_blank'  href=\"https://github.com/GzhiYi/blog-like/blob/master/functions/index.js\">blog-like</a></p>\n<ol>\n<li>安装Firebase CLI工具以初始化函数仓库。</li>\n</ol>\n<pre><code class=\"language-bash\">npm <span class=\"hljs-keyword\">install</span> -g firebase-tools\n</code></pre>\n<ol start=\"2\">\n<li>登录</li>\n</ol>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">firebase login</span>\n</code></pre>\n<ol start=\"3\">\n<li>创建一个空目录，然后初始化这个目录，例如目录名为blog-like</li>\n</ol>\n<pre><code class=\"language-bash\">mkdir blog-<span class=\"hljs-meta\">like</span> <span class=\"hljs-variable\">&amp;&amp;</span> cd blog-<span class=\"hljs-meta\">like</span> <span class=\"hljs-variable\">&amp;&amp;</span> firebase init\n</code></pre>\n<p>执行init命令后会提示选择新建项目的一些规则。（以下是规则过程）</p>\n<p><code>q: Which Firebase CLI features do you want to set up for this folder? Press Space to select features, then Enter to confirm your choices.</code>\n<code>a: 选择Firestore: Deploy rules and create indexes for Firestore以及Functions: Configure and deploy Cloud Functions</code>  </p>\n<p><code>q: Please select an option:</code>\n<code>a: Use an existing project，随后选择在控制台创建的项目。</code></p>\n<p>随后几个按enter就好了。</p>\n<ol start=\"4\">\n<li>函数编写。</li>\n</ol>\n<p>需要两个接口，一个是新增点赞接口，路由为：<code>/newLike</code>，一个是获取点赞数据的接口，路由为：<code>/getLikes</code>。</p>\n<ul>\n<li>newLike。先判断该用户是否已经点过赞。需要存储的数据：文章标题、点赞时间、用户指纹。</li>\n<li>getLikes。先获取该文章点赞总数，在判断用户是否已经点过赞。</li>\n</ul>\n<p>有了以下基本代码：</p>\n<p>点赞数据表：</p>\n<pre><code class=\"language-json\">{\n    <span class=\"hljs-attribute\">id:</span><span class=\"hljs-string\"> 用户指纹，\n    likeTime</span>：点赞时间，\n    postTitle：文章标题\n}\n</code></pre>\n<p>newLike，创建点赞数据：</p>\n<pre><code class=\"language-javascript\">db<span class=\"hljs-built_in\">.collection</span>(<span class=\"hljs-string\">&#x27;like&#x27;</span>)\n  .<span class=\"hljs-keyword\">where</span>(<span class=\"hljs-string\">&quot;postTitle&quot;</span>, <span class=\"hljs-string\">&quot;==&quot;</span>, request.body.title)\n  .get()\n  .<span class=\"hljs-keyword\">then</span>(res =&gt; {\n  <span class=\"hljs-keyword\">let</span> isLike =<span class=\"hljs-built_in\"> false</span>\n  <span class=\"hljs-keyword\">try</span> {\n    // 判断是否已经点赞过\n    res.forEach<span class=\"hljs-built_in\">(doc</span> =&gt; {\n      <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">(doc</span><span class=\"hljs-built_in\">.id</span> === request.body<span class=\"hljs-built_in\">.id</span> &amp;&amp; !isLike) {\n        isLike =<span class=\"hljs-built_in\"> true</span>\n      }\n    })\n    <span class=\"hljs-keyword\">if</span> (!isLike) {\n      <span class=\"hljs-keyword\">let</span> docRef = db<span class=\"hljs-built_in\">.collection</span>(<span class=\"hljs-string\">&#x27;like&#x27;</span>)<span class=\"hljs-built_in\">.doc</span>(params<span class=\"hljs-built_in\">.id</span>);\n      docRef.set({\n        postTitle: params.title,\n        likeTime: new Date().toLocaleString()\n      });\n      response.send({\n        data: <span class=\"hljs-string\">&#x27;like success!&#x27;</span>,\n        code: <span class=\"hljs-number\">0</span>\n      })\n    } <span class=\"hljs-keyword\">else</span> {\n      response.send({\n        data: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n        message: <span class=\"hljs-string\">&#x27;like 过啦&#x27;</span>,\n        code: <span class=\"hljs-number\">1</span>\n      })\n    }\n  } <span class=\"hljs-keyword\">catch</span> <span class=\"hljs-built_in\">(error</span>) {\n    console.log(<span class=\"hljs-string\">&#x27;error&#x27;</span>,<span class=\"hljs-built_in\"> error</span>)\n  }\n})\n</code></pre>\n<p>getLikes，获取点赞数据：</p>\n<pre><code class=\"language-javascript\">db<span class=\"hljs-built_in\">.collection</span>(<span class=\"hljs-string\">&#x27;like&#x27;</span>)\n  .<span class=\"hljs-keyword\">where</span>(<span class=\"hljs-string\">&quot;postTitle&quot;</span>, <span class=\"hljs-string\">&quot;==&quot;</span>, title)\n  .get()\n  .<span class=\"hljs-keyword\">then</span>(res =&gt; {\n  <span class=\"hljs-keyword\">let</span> isLike =<span class=\"hljs-built_in\"> false</span>\n  <span class=\"hljs-keyword\">try</span> {\n    res.forEach<span class=\"hljs-built_in\">(doc</span> =&gt; {\n      <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">(doc</span><span class=\"hljs-built_in\">.id</span> ===<span class=\"hljs-built_in\"> id</span> &amp;&amp; !isLike) {\n        isLike =<span class=\"hljs-built_in\"> true</span>\n      }\n    })\n  } <span class=\"hljs-keyword\">catch</span> <span class=\"hljs-built_in\">(error</span>) {\n    console.log(<span class=\"hljs-string\">&#x27;error&#x27;</span>,<span class=\"hljs-built_in\"> error</span>)\n  }\n  response.send({\n    data: res.size,\n    isLike,\n    message: <span class=\"hljs-string\">&#x27;oooooooook&#x27;</span>,\n    code: <span class=\"hljs-number\">0</span>\n  })\n})\n  .<span class=\"hljs-keyword\">catch</span><span class=\"hljs-built_in\">(error</span> =&gt; {\n  response.send({\n    data:<span class=\"hljs-built_in\"> error</span>,\n    message: request.body,\n    code: <span class=\"hljs-number\">1</span>\n  })\n})\n</code></pre>\n<p>在函数编写之后，执行命令就可以部署到云端啦。</p>\n<pre><code class=\"language-bash\">firebase <span class=\"hljs-keyword\">deploy</span> <span class=\"hljs-params\">--only</span> functions\n</code></pre>\n<h2 id=\"用户端\">用户端</h2>\n<p>在博客页面上生成用户唯一ID后用fetch请求点赞接口就可以了。</p>\n<p>另外，跨域问题需要函数端用上cors处理。详细的都可以在<a target='_blank'  href=\"https://github.com/GzhiYi/blog-like\">仓库</a>看到。</p>\n<h2 id=\"体验\">体验</h2>\n<p>最后说一下体验。整个开发过程比较愉快，花了点点时间查阅数据库操作语法。上线尝试访问，发现google的果然访问好慢！</p>\n<p>你可以点击下面clap按钮试试，如果没有，说明网络问题，unreachable。</p>\n"},{"title":"2020年苹果开发者大会","slug":"2020_06_apple-wwdc-2020","description":"2020 Apple Worldwide Developers Conference","keywords":"apple,2020,wwdc","labels":["随笔"],"date":"2020-06-23","path":"2020/06/apple-wwdc-2020.md","html":"<p>昨晚苹果线上直播了2020年开发者大会。本次大会给了不少的东西出来。其中最引瞩目的就是宣布自研Mac ARM芯片，从Intel中跳出来。</p>\n<p>这是苹果想统一多平台下的一个大棋。在会之前就有不少的人分析arm架构的处理器会给市场带来什么影响。用户无需考虑太多，而开发者倒会更多的考虑开发兼容性的问题。</p>\n<h2 id=\"苹果生态\">苹果生态</h2>\n<p>毫无疑问，苹果在生态上走的越来越靠拢，强化多平台优秀的体验拉拢了越来越多的用户。我个人觉得iOS很流畅，能稳定的运行不会忽然卡顿就已经很满足了。但也非常不喜欢苹果的一些缺失的功能。拿着超前的体验做着安卓好几年前就有的功能，不知道iOS开发的执行力是不是不够，但个别地方的体验真的不尽人意。短信不能未读提示，电量不足20%还强制弹窗提示...有好多地方在产品的设计上就有问题。</p>\n<p>后面接触了macOS，我常将它比作是ui更精致，系统更稳定的linux。开发体验非常好，从此告别了windows。windows在开发过程总会遇到不明不白的卡顿问题，terminal也总是让人觉得帧数很低不顺畅。还有一个很重要的优点就是macOS没有广告弹窗，这点就不得不吐槽windows下国产应用肆意妄为弹窗、捆绑了。未来会一直用macOS开发，总结一个词就是相见恨晚。</p>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://i.loli.net/2020/06/23/Agv9hHwZI4eMyqT.jpg\" alt=\"007S8ZIlgy1gg24hxohtfj31c00u07wn.jpg\" ></p>\n<p>新的macOS ui有了更新，图标改为了圆角矩形，和ipadOS、iOS越来越相似。个人觉得改动并不会丑，大概率又会是真香体验。</p>\n"},{"title":"使用github actions自动编译部署sapper-blog","slug":"2020_06_sapper-github-actions","description":"使用github actions打包部署sapper项目并部署到github pages。","keywords":"github actions,sapper,github pages","labels":["前端"],"date":"2020-06-22","path":"2020/06/sapper-github-actions.md","html":"<p>之前构建好了的<a target='_blank'  href=\"/blog/2020-06_build-blog\">博客</a>，通过编写一个脚本实现本地自动化部署。脚本实现的功能就是在本地处理项目的打包并将静态文件推送到远端的<code>gh-pages</code>分支以实现静态文件部署。在了解github actions之后，决定增加一个自动化打包部署的workflow。这样就可以将编译打包的操作完全放置在”云端“。</p>\n<h2 id=\"编写workflow配置文件\">编写workflow配置文件</h2>\n<p>在项目根目录创建<code>.github/workflows/main.yml</code></p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span> <span class=\"hljs-string\">GitHub</span> <span class=\"hljs-string\">Pages</span>\n\n<span class=\"hljs-attr\">on:</span>\n  <span class=\"hljs-attr\">push:</span>\n      <span class=\"hljs-comment\"># push钩子监听的分支，为编译打包的分支</span>\n    <span class=\"hljs-attr\">branches:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">feat/dev</span>\n\n<span class=\"hljs-comment\"># 任务</span>\n<span class=\"hljs-attr\">jobs:</span>\n  <span class=\"hljs-attr\">build-and-deploy:</span>\n    <span class=\"hljs-comment\"># 服务器环境：最新版 Ubuntu</span>\n    <span class=\"hljs-attr\">runs-on:</span> <span class=\"hljs-string\">ubuntu-latest</span>\n    <span class=\"hljs-attr\">steps:</span>\n      <span class=\"hljs-comment\"># 拉取代码</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Checkout</span>\n        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">actions/checkout@v2</span>\n        <span class=\"hljs-attr\">with:</span>\n          <span class=\"hljs-attr\">persist-credentials:</span> <span class=\"hljs-literal\">false</span>\n\n      <span class=\"hljs-comment\"># 生成静态文件</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Build</span>\n        <span class=\"hljs-attr\">run:</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">install</span> <span class=\"hljs-string\">&amp;&amp;</span> <span class=\"hljs-string\">npm</span> <span class=\"hljs-string\">run</span> <span class=\"hljs-string\">export</span> <span class=\"hljs-string\">&amp;&amp;</span> <span class=\"hljs-string\">cp</span> <span class=\"hljs-string\">-i</span> <span class=\"hljs-string\">CNAME</span> <span class=\"hljs-string\">__sapper__/export</span>\n\n      <span class=\"hljs-comment\"># 部署到 GitHub Pages</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">Deploy</span>\n        <span class=\"hljs-attr\">uses:</span> <span class=\"hljs-string\">JamesIves/github-pages-deploy-action@releases/v3</span>\n        <span class=\"hljs-attr\">with:</span>\n          <span class=\"hljs-attr\">ACCESS_TOKEN:</span> <span class=\"hljs-string\">${{</span> <span class=\"hljs-string\">secrets.GH_PAGES</span> <span class=\"hljs-string\">}}</span>\n          <span class=\"hljs-attr\">BRANCH:</span> <span class=\"hljs-string\">gh-pages</span>\n          <span class=\"hljs-attr\">FOLDER:</span> <span class=\"hljs-string\">__sapper__/export</span>\n</code></pre>\n<p>上面配置有个别要注意的点：</p>\n<ol>\n<li><p>branches需要设置为要处理的分支。</p>\n</li>\n<li><p>with/ACCESS_TOKEN为github生成的token。</p>\n<p>生成步骤：</p>\n<p><a target='_blank'  href=\"https://github.com/settings/tokens\">github右上角的Settings-Developer settings-Personal access tokens</a> 点击<code>Generate new token</code>，为了和配置文件对应，token的note需要填写为GH_PAGES，然后勾选scope为repo。</p>\n<p>在博客的仓库的setting设置secret。</p>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://i.loli.net/2020/06/22/jurxoLcUY7p5C8a.jpg\" alt=\"Xnip2020-06-22_14-12-10.jpg\" ></p>\n</li>\n<li><p>with/FOLDER为sapper导出export的静态文件目录。</p>\n</li>\n</ol>\n<p>以上完成之后，将代码push到远端仓库，就可以在Actions看到名字为<code>Deploy Github Pages</code>的workflow。</p>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://i.loli.net/2020/06/22/bCxitLWKVlgHD8P.jpg\" alt=\"Xnip2020-06-22_14-15-32.jpg\" ></p>\n<h2 id=\"体会\">体会</h2>\n<p>Github Actions比在公司使用gitlab cicd快了不少，体验非常不错。在写完博客之后，只需要做的，只有将更新的内容push到github就可以了。</p>\n"},{"title":"日环食","slug":"2020_06_eclipse","description":"日环食，10年一遇，还有自己的一点小思考。","keywords":"日环食","labels":["随笔"],"date":"2020-06-21","path":"2020/06/eclipse.md","html":"<p>或许是不留意，像日环食、日全食这样难得一见的新闻像是突然冒出来一样。今天遇上了10年一遇的日环食。</p>\n<p>当然是不能用眼睛直视啦，不过我在的屋子刚好下午是看不到阳光，外加上兴趣也不是十分大（没有工具，手机也拍不到好，外面又很热很热），就没有特意跑到楼下去看了。倒是朋友圈和微博都有非常多的直播，看他们发的，其实也就够了。新闻也提到了可以用小孔成像原理，就是拿一个带小孔的“东西”放在阳光下就可以看到日食的样子。恰巧有人路过拍下下面有意思的画面。</p>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://i.loli.net/2020/06/21/3y8KMzdDhmQWBtq.jpg\" alt=\"IMG_6668.JPG\" ></p>\n<p>也不是我现场看到，但如果这是日环食通过小孔成像体验的模样，就颇为奇妙了，奇妙的不仅仅是这一自然现象，还有的是大千世界无与伦比的恰巧带来奇妙的画面。</p>\n<h2 id=\"小思考\">小思考</h2>\n<p>自己也常常浮想联翩。就拿今天的日环食，我会想为啥星球都是如此的圆；为什么会有那么巧的情况，让太阳被某个星球所刚好阻挡住光线。《星际穿越》是我最喜欢的电影，对于浩瀚太空的探索，显得我们那么渺小，就像男主结尾疑惑是谁把空间放在那的，我也在想，所有的一切都是自然发生的吗？还是有更高的物质将我们赋予生命、时间、还有空间？恐怕人类从开始到结束，都不会知道。走出浮想，想想今天也是天气很好的一天，我总可以好好享受自然带来的乐趣，觉得人类到底也是幸运的。</p>\n"},{"title":"用sapper构建一个博客","slug":"2020_06_build-blog","description":"用sapper构建一个博客，相关技术：svelte、sapper、tailwindcss、typescript。编写markdown后一键部署到github pages。","keywords":"sapper，博客，svelte，tailwindcss，typescript，github pages，markdown","labels":["前端","技术"],"date":"2020-06-20","path":"2020/06/build-blog.md","html":"<p>发现自己好久没有写博客了。之前在github开了一个仓库，在仓库的<a target='_blank'  href=\"https://github.com/GzhiYi/blog/issues\">issue区</a>写一些内容。issue区体验挺好的，可以refer上项目代码，也可以追加评论。但我想自己写一个博客，不需要很多花里胡哨的功能，只对内容专注，极大的好处是，可以随心所欲的编写自己喜欢的页面样式。刚好最近有接触了下<a target='_blank'  href=\"https://svelte.dev/\">svelte</a>，就顺带的用<a target='_blank'  href=\"https://sapper.svelte.dev/\">sapper</a>写一个静态页面。</p>\n<p>实现需要用到的知识点/技术：</p>\n<ol>\n<li>svelte</li>\n<li>sapper</li>\n<li>tailwindcss</li>\n<li>typescript</li>\n</ol>\n<p>后面两点非必须，可以根据自己需要进行增减。</p>\n<h2 id=\"思路\">思路</h2>\n<p>整体的思路比较简单。</p>\n<p>sapper支持export出静态文件，我只需要将静态文件部署到一个静态站点，首选的就是github pages。sapper导出export有一个好处：</p>\n<blockquote>\n<p>Static doesn&#39;t mean non-interactive — your Svelte components work exactly as they do normally, and you still get all the benefits of client-side routing and prefetching.</p>\n</blockquote>\n<p>sapper默认的template就是一个blog，这不是刚好可以拿来起手嘛！但默认的template的 blog内容是固定的数据，大致内容是一个js文件，export一个blog的array。</p>\n<pre><code class=\"language-javascript\">export const [\n  {\n    title: &#x27;<span class=\"hljs-number\">2020-06</span>/build-blog.md&#x27;,\n    slug: &#x27;<span class=\"hljs-number\">2020-06</span>_build-blog&#x27;, <span class=\"hljs-comment\">// 生成的路由路径</span>\n    html: &#x27;&lt;h1 id=\\&quot;用sapper构建一个博客\\&quot;&gt;用sapper构建一个博客&lt;/h1&gt;&#x27;\n  }\n]\n</code></pre>\n<p>在sapper export之后，可以在<code>__sapper__/export/blog</code>看到生成html静态文件。也就意味着最后需要部署到github pages的目录，就是<code>__sapper__</code>目录啦。</p>\n<p><strong>可如果要写博客，那肯定也优先选择Markdown。</strong></p>\n<p>所以需要解决的也就是将Markdown文件转为上面提到的js文件。</p>\n<h2 id=\"将markdown转为js文件\">将Markdown转为js文件</h2>\n<p>需要用到<a target='_blank'  href=\"https://github.com/markedjs/marked\">Markedjs</a>。</p>\n<p>使用也是简单粗暴：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> marked = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;marked&#x27;</span>)\nmarked.setOptions({\n  <span class=\"hljs-attr\">renderer</span>: <span class=\"hljs-keyword\">new</span> marked.Renderer(),\n  <span class=\"hljs-attr\">highlight</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">code, language</span>) </span>{\n    <span class=\"hljs-keyword\">const</span> hljs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;highlight.js&#x27;</span>)\n    <span class=\"hljs-keyword\">const</span> validLanguage = hljs.getLanguage(language) ? language : <span class=\"hljs-string\">&#x27;plaintext&#x27;</span>\n    <span class=\"hljs-keyword\">return</span> hljs.highlight(validLanguage, code).value\n  },\n  <span class=\"hljs-comment\">// ...(more options)</span>\n});\nmarked(markdownString)\n</code></pre>\n<p>例如markdownString为：</p>\n<pre><code><span class=\"hljs-strong\">*hello world*</span>\n</code></pre>\n<p>将会被转为：</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">em</span>&gt;</span>hello world<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">em</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n</code></pre>\n<p>知道用法之后，只需要通过fs文件操作，将目标的Markdown文件全部push进一个数组，最后将数组写入一个js文件。</p>\n<h2 id=\"读取markdown并写入文件\">读取Markdown并写入文件</h2>\n<p>node对操作文件提供了<code>readir</code>、<code>readFile</code>、<code>writeFile</code>等函数。</p>\n<p>其中核心的处理逻辑如下：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 获取所有文件</span>\n<span class=\"hljs-keyword\">const</span> getAllFiles = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">dirPath, arrayOfFiles</span>) </span>{\n    files = fs.readdirSync(dirPath)\n    arrayOfFiles = arrayOfFiles || []\n    files.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">file</span>) </span>{\n        <span class=\"hljs-keyword\">if</span> (fs.statSync(dirPath + <span class=\"hljs-string\">&quot;/&quot;</span> + file).isDirectory()) {\n            arrayOfFiles = getAllFiles(dirPath + <span class=\"hljs-string\">&quot;/&quot;</span> + file, arrayOfFiles)\n        } <span class=\"hljs-keyword\">else</span> {\n            arrayOfFiles.push(path.join(dirPath, <span class=\"hljs-string\">&quot;/&quot;</span>, file))\n        }\n    })\n    <span class=\"hljs-keyword\">return</span> arrayOfFiles\n}\n<span class=\"hljs-comment\">// 将markdown转为js文件</span>\n<span class=\"hljs-keyword\">const</span> compile = <span class=\"hljs-function\">() =&gt;</span> {\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-keyword\">const</span> dirs = getAllFiles(<span class=\"hljs-string\">&#x27;./&#x27;</span>) <span class=\"hljs-comment\">// 读取所有文件</span>\n        <span class=\"hljs-keyword\">const</span> inPosts = [] <span class=\"hljs-comment\">// 文章数组</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> fileName <span class=\"hljs-keyword\">of</span> dirs) {\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-regexp\">/.md/</span>.test(fileName)) {\n                <span class=\"hljs-keyword\">const</span> fileData = fs.readFileSync(<span class=\"hljs-string\">`./<span class=\"hljs-subst\">${fileName}</span>`</span>, <span class=\"hljs-string\">&#x27;utf-8&#x27;</span>) <span class=\"hljs-comment\">// markdown内容</span>\n                <span class=\"hljs-keyword\">const</span> fmData = fm(fileData) <span class=\"hljs-comment\">// 此处可以忽略fm（fm是处理markdown front matter的，可有可无）</span>\n                <span class=\"hljs-keyword\">const</span> rmSuffix = fileName.split(<span class=\"hljs-string\">&#x27;.&#x27;</span>)[<span class=\"hljs-number\">0</span>] <span class=\"hljs-comment\">// 移除文件名后缀</span>\n                inPosts.push({\n                    <span class=\"hljs-attr\">title</span>: fileName,\n                    <span class=\"hljs-attr\">path</span>: rmSuffix,\n                    <span class=\"hljs-attr\">slug</span>: rmSuffix.replace(<span class=\"hljs-string\">&#x27;/&#x27;</span>, <span class=\"hljs-string\">&#x27;_&#x27;</span>),\n                    <span class=\"hljs-attr\">html</span>: marked(fmData.body),\n                    fmData\n                })\n            }\n        }\n        inPosts.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">post</span> =&gt;</span> {\n            post.html = post.html.replace(<span class=\"hljs-regexp\">/^\\t{3}/gm</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>);\n        });\n        <span class=\"hljs-keyword\">const</span> outPutContent = <span class=\"hljs-string\">`export default <span class=\"hljs-subst\">${<span class=\"hljs-built_in\">JSON</span>.stringify(inPosts)}</span>`</span>\n        fs.writeFile(<span class=\"hljs-string\">&#x27;../routes/blog/_posts.js&#x27;</span>, outPutContent, <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> {\n            <span class=\"hljs-keyword\">if</span> (err) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;生成post失败&#x27;</span>, err)\n            <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;已生成_posts.js&#x27;</span>)\n        })\n    } <span class=\"hljs-keyword\">catch</span> (error) {\n        <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&#x27;error&#x27;</span>, error)\n    }\n}\n<span class=\"hljs-keyword\">const</span> watcher = chokidar.watch(<span class=\"hljs-string\">&#x27;./&#x27;</span>)\nwatcher\n    .on(<span class=\"hljs-string\">&#x27;all&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> {\n        compile()\n    })\n</code></pre>\n<h2 id=\"部署到github-pages\">部署到github pages</h2>\n<p>对于sapper，执行export命令生成静态文件。</p>\n<pre><code class=\"language-bash\">npm run <span class=\"hljs-keyword\">export</span>\n</code></pre>\n<p>将<code>__sapper__/export</code>推送到仓库的gh-pages分支。</p>\n<pre><code class=\"language-bash\">git subtree <span class=\"hljs-built_in\">push</span> --<span class=\"hljs-built_in\">prefix</span> __sapper__/export <span class=\"hljs-built_in\">origin</span> gh-pages\n</code></pre>\n<p>最后在仓库设置出将gh-pages分支设置为部署分支就好了。</p>\n<p>以上完成了从写Markdown到可以看到文章，后续页面的编写就可以随心所欲啦！</p>\n"},{"title":"Element-ui table组件表头sticky","slug":"2020_05_element-ui-table-header-sticky","description":"不用js处理，css实现element-ui表头sticky。","keywords":"element-ui,table,header,表头,sticky,position,overflow hidden","labels":["前端","Element"],"date":"2020-05-29","path":"2020/05/element-ui-table-header-sticky.md","html":"<p>element组件表头未支持sticky相关api。可以通过如下css处理：</p>\n<pre><code class=\"language-css\">// 表头sticky\n.el-table__footer-<span class=\"hljs-keyword\">wrapper</span>,\n.el-table__header-<span class=\"hljs-keyword\">wrapper</span> {\n  position: sticky;\n  top: <span class=\"hljs-number\">48</span>px;\n  overflow: <span class=\"hljs-keyword\">inherit</span> !important;\n  z-<span class=\"hljs-keyword\">index</span>: <span class=\"hljs-number\">99</span>;\n}\n.el-<span class=\"hljs-keyword\">table</span><span class=\"hljs-comment\">--small {</span>\n  overflow: <span class=\"hljs-keyword\">inherit</span>;\n}\n</code></pre>\n<p>说明：</p>\n<p><code>position: sticky</code>如果没有效果，检查：</p>\n<ol>\n<li><code>top</code>、<code>right</code>、<code>left</code>或者<code>bottom</code>属性是否有设置。</li>\n<li>在table组件中设置层级，以免被遮挡。</li>\n<li>sticky对象的祖先元素不能设置<code>overflow: hidden;</code></li>\n</ol>\n"},{"title":"Docker安装easymock","slug":"2020_01_docker-easymock","description":"为了方便本地mock接口，需要在本地用docker跑一个easy-mock服务。第一时间想到docker运行，方便管理和使用。基本上是非常简单就可以跑起来的。所以在这记录一下安装easy-mock的步骤，也为了下次更快的安装。","keywords":"docker,esaymock,api","labels":["前端"],"date":"2020-01-20","path":"2020/01/docker-easymock.md","html":"<p>为了方便本地mock接口，需要在本地用docker跑一个easy-mock服务。第一时间想到docker运行，方便管理和使用。基本上是非常简单就可以跑起来的。所以在这记录一下安装easy-mock的步骤，也为了下次更快的安装。</p>\n<blockquote>\n<p>假设在目录<code>/Users/{{用户目录名}}/easymock</code>存放easy-mock配置。\n当然需要先安装好docker啦，不再赘述。</p>\n</blockquote>\n<h2 id=\"docker-compose文件\">Docker compose文件</h2>\n<p>x在easymock目录下新建一个docker-compose.yml文件，内容如下：</p>\n<pre><code class=\"language-yml\"><span class=\"hljs-attr\">version:</span> <span class=\"hljs-string\">&#x27;3&#x27;</span>\n\n<span class=\"hljs-attr\">services:</span>\n  <span class=\"hljs-attr\">mongodb:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">mongo:3.4.1</span>\n    <span class=\"hljs-attr\">volumes:</span>\n      <span class=\"hljs-comment\"># ./data/db 数据库文件存放地址，根据需要修改为本地地址</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&#x27;./data/db:/Users/<span class=\"hljs-template-variable\">{{用户目录名}}</span>/easymock/data/db&#x27;</span>\n    <span class=\"hljs-attr\">networks:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">easy-mock</span>\n    <span class=\"hljs-attr\">restart:</span> <span class=\"hljs-string\">always</span>\n\n  <span class=\"hljs-attr\">redis:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">redis:4.0.6</span>\n    <span class=\"hljs-attr\">command:</span> <span class=\"hljs-string\">redis-server</span> <span class=\"hljs-string\">--appendonly</span> <span class=\"hljs-literal\">yes</span>\n    <span class=\"hljs-attr\">volumes:</span>\n      <span class=\"hljs-comment\"># ./data/redis redis 数据文件存放地址，根据需要修改为本地地址</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&#x27;./data/redis:/Users/<span class=\"hljs-template-variable\">{{用户目录名}}</span>/easymock/data&#x27;</span>\n    <span class=\"hljs-attr\">networks:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">easy-mock</span>\n    <span class=\"hljs-attr\">restart:</span> <span class=\"hljs-string\">always</span>\n\n  <span class=\"hljs-attr\">web:</span>\n    <span class=\"hljs-attr\">image:</span> <span class=\"hljs-string\">easymock/easymock:1.6.0</span>\n    <span class=\"hljs-attr\">command:</span> <span class=\"hljs-string\">/bin/bash</span> <span class=\"hljs-string\">-c</span> <span class=\"hljs-string\">&quot;npm start&quot;</span>\n    <span class=\"hljs-attr\">ports:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-number\">7300</span><span class=\"hljs-string\">:7300</span>\n    <span class=\"hljs-attr\">volumes:</span>\n      <span class=\"hljs-comment\"># 日志地址，根据需要修改为本地地址</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&#x27;./logs:/Users/<span class=\"hljs-template-variable\">{{用户目录名}}</span>/easymock/easy-mock/logs&#x27;</span>\n      <span class=\"hljs-comment\"># 配置地址，请使用本地配置地址替换</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&#x27;./production.json:/Users/<span class=\"hljs-template-variable\">{{用户目录名}}</span>/easymock/easy-mock/config&#x27;</span>\n    <span class=\"hljs-attr\">networks:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">easy-mock</span>\n    <span class=\"hljs-attr\">restart:</span> <span class=\"hljs-string\">always</span>\n\n<span class=\"hljs-attr\">networks:</span>\n  <span class=\"hljs-attr\">easy-mock:</span>\n</code></pre>\n<h2 id=\"运行\">运行</h2>\n<p><code>docker-compose up -d</code>即可运行。</p>\n<pre><code class=\"language-bash\">easymock_redis_1 <span class=\"hljs-keyword\">is</span> up-<span class=\"hljs-keyword\">to</span>-<span class=\"hljs-built_in\">date</span>\neasymock_mongodb_1 <span class=\"hljs-keyword\">is</span> up-<span class=\"hljs-keyword\">to</span>-<span class=\"hljs-built_in\">date</span>\neasymock_web_1 <span class=\"hljs-keyword\">is</span> up-<span class=\"hljs-keyword\">to</span>-<span class=\"hljs-built_in\">date</span>\n</code></pre>\n<p>后打开<code>localhost:7300</code></p>\n"},{"title":"Docker部署nuxtjs应用","slug":"2019_12_docker-nuxtjs","description":"有个主页的项目需要用到ssr。所以选择nuxtjs进行主页开发。关于nextjs的使用可以到官方文档进行查看。这里主要是记录一下docker部署nuxtjs应用的一些小事情。","keywords":"docker,nuxtjs,ssr","labels":["前端"],"date":"2019-12-25","path":"2019/12/docker-nuxtjs.md","html":"<p>有个主页的项目需要用到ssr。所以选择nuxtjs进行主页开发。关于nextjs的使用可以到官方文档进行查看。这里主要是记录一下docker部署nuxtjs应用的一些小事情。</p>\n<h2 id=\"dockerfile\">Dockerfile</h2>\n<p>通过dockerfile可以build一个docker镜像。dockerfile内容如下：</p>\n<pre><code class=\"language-dockerfile\"><span class=\"hljs-keyword\">FROM</span> node:11.13.0-alpine\n\n<span class=\"hljs-comment\"># create destination directory</span>\n<span class=\"hljs-builtin-name\">RUN</span> mkdir -p /app\nWORKDIR /app\n\n<span class=\"hljs-comment\"># copy the app, note .dockerignore</span>\nCOPY . /app\n<span class=\"hljs-builtin-name\">RUN</span> npm install\n\n<span class=\"hljs-comment\"># build necessary, even if no static files are needed,</span>\n<span class=\"hljs-comment\"># since it builds the server as well</span>\n<span class=\"hljs-builtin-name\">RUN</span> npm <span class=\"hljs-builtin-name\">run</span> build\n\n<span class=\"hljs-comment\"># expose 3000 on container</span>\nEXPOSE 3000\n\n<span class=\"hljs-comment\"># set app serving to permissive / assigned</span>\nENV <span class=\"hljs-attribute\">NUXT_HOST</span>=0.0.0.0\n<span class=\"hljs-comment\"># set app port</span>\nENV <span class=\"hljs-attribute\">NUXT_PORT</span>=3000\n\n<span class=\"hljs-comment\"># start the app</span>\nCMD [ <span class=\"hljs-string\">&quot;npm&quot;</span>, <span class=\"hljs-string\">&quot;start&quot;</span> ]\n</code></pre>\n<p>注意：</p>\n<ol>\n<li>部署 Nuxt.js 服务端渲染的应用不能直接使用 nuxt 命令，而应该先进行编译构建，然后再启动 Nuxt 服务。</li>\n<li>在build之前，需要ignore以下三个规则文件（手动创建.dockerignore文件）：</li>\n</ol>\n<pre><code><span class=\"hljs-attribute\">node_modules</span>\nnpm-<span class=\"hljs-literal\">debug</span>*\n.nuxt\n</code></pre>\n<p>否则会出现镜像build失败的情况。</p>\n<p>运行命令：docker run -it -d -p 3000:3000 gzhiyi/nuxt-homepage  后面为镜像build后的名称，注意按实际情况进行更改。</p>\n<h2 id=\"nginx配置\">nginx配置</h2>\n<p>Docker运行node服务，如果需要外部访问的话，需要nginx反向代理。具体配置：</p>\n<pre><code class=\"language-nginx\"><span class=\"hljs-section\">server</span> {\n    <span class=\"hljs-attribute\">listen</span> <span class=\"hljs-number\">80</span>;\n    <span class=\"hljs-attribute\">server_name</span> *your servername*;\n    <span class=\"hljs-attribute\">location</span> / {\n        <span class=\"hljs-attribute\">proxy_pass</span> http://localhost:3000;\n        <span class=\"hljs-attribute\">proxy_http_version</span> <span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-attribute\">proxy_set_header</span> Upgrade $http_upgrade;\n        <span class=\"hljs-attribute\">proxy_set_header</span> Connection <span class=\"hljs-string\">&#x27;upgrade&#x27;</span>;\n        <span class=\"hljs-attribute\">proxy_set_header</span> Host $host;\n        <span class=\"hljs-attribute\">proxy_cache_bypass</span> $http_upgrade;\n    }\n}\n</code></pre>\n<h2 id=\"访问\">访问</h2>\n<p>需要配置host才能访问，如下：</p>\n<pre><code class=\"language-hosts\"><span class=\"hljs-comment\">*your serverip* *your servername*</span>\n</code></pre>\n"},{"title":"Http缓存","slug":"2019_11_http-cache","description":"Http缓存","keywords":"http,缓存","labels":["学习"],"date":"2019-11-28","path":"2019/11/http-cache.md","html":"<h2 id=\"缓存相关头\">缓存相关头</h2>\n<h3 id=\"响应头\">响应头</h3>\n<ul>\n<li>Expire。资源过期时间。</li>\n<li>Cache-Control。缓存控制字段，精确控制缓存策略。</li>\n<li>Last-Modified。资源最近修改时间。</li>\n<li>Etag。资源标识。</li>\n</ul>\n<h3 id=\"请求头\">请求头</h3>\n<ul>\n<li>Cache-Control。缓存控制字段，精确控制缓存策略。</li>\n<li>If-Modified-Since。资源最新修改时间。</li>\n<li>If-None-Match。缓存资源标识。</li>\n</ul>\n<h3 id=\"字段匹配\">字段匹配</h3>\n<p>If-Modified-Since和Last-Modified\nEtag和If-None-Match</p>\n<h2 id=\"浏览器和服务器约定资源过期时间\">浏览器和服务器约定资源过期时间</h2>\n<p>服务器和浏览器之间约定文件的过期时间，控制的字段为：Expires。在这个时间未到之前，浏览器对同一个文件不会向服务器发起请求。</p>\n<p><strong>缺点：</strong>Expire到期后，如果文件未进行过改动，浏览器还是会向服务器请求读取文件。</p>\n<h2 id=\"服务器告诉浏览器资源上次的修改时间（解决上面的问题）\">服务器告诉浏览器资源上次的修改时间（解决上面的问题）</h2>\n<p>服务器返回文件的时候，在响应头上增加一个最近修改时间（Last-Modified）。浏览器在Expires时间到之后，会向服务器发起文件请求，这时带上一个最近修改时间（If-Modified-Since = Last-Modified）。服务器在接受到请求之后，会拿这个时间和服务器上目标文件的上一次修改时间做对比：</p>\n<ul>\n<li>相等。进行304跳转，不要读取服务器文件了，读取缓存就行了。</li>\n<li>不相等。读取服务器上的文件。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ol>\n<li>Expires过期时间浏览器断可以修改，这样会导致缓存不准确。</li>\n<li>Last-Modified过期时间只能精确到秒。（一秒内可能多次改动，这样会造成两个可能的问题：文件一秒内改动多次，但还是通知浏览器读缓存。如果文件修改了，但内容不变，那就会去读服务器文件了。）</li>\n</ol>\n<h2 id=\"增加相对时间控制，引入cache-control\">增加相对时间控制，引入Cache-Control</h2>\n<p>服务器在返回资源给浏览器的时候，会增加一个相对时间：Cache-Control：max-age=1000s。这个的意思是告诉浏览器，1000s内使用浏览器缓存的文件。</p>\n<p><strong>优先级：</strong> \nCache-Control优先于Expires。有Cache-Control就以Cache-Control为准。</p>\n<h2 id=\"继续升级缓存机制\">继续升级缓存机制</h2>\n<p>带上Etag-可以理解为文件的唯一Id，由服务器返回到浏览器上。\n在有效期过后，带上一个等同于Etag值的If-None-Match请求头，比较后处理是否读取文件。</p>\n<h2 id=\"最后是我前端的一个技巧啦\">最后是我前端的一个技巧啦</h2>\n<p>由于上面那么多的缓存判断条件，都不能满足一个情况，既浏览器永远无法主动知道服务器的文件已经更新。那好：静态资源在请求链接上更新就行了。</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;http://test.com/a.【hash值】.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n"},{"title":"JS引入资源的一点总结","slug":"2019_09_js-asset-import","description":"很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。","keywords":"javascript,script,阻塞渲染,defer,async,动态引入","labels":["前端"],"date":"2019-09-28","path":"2019/09/js-asset-import.md","html":"<h2 id=\"js引入的时候放在哪比较好呢？\">JS引入的时候放在哪比较好呢？</h2>\n<p>很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。</p>\n<h2 id=\"浏览器渲染\">浏览器渲染</h2>\n<p>在知道放在哪最好之前，需要知道下浏览器渲染的过程。有以下的步骤：</p>\n<ul>\n<li>处理文档中的标签并构建DOM（Document Object Model）树。</li>\n<li>处理文档中的css并构建CSSOM（CSS Object Model）树。</li>\n<li>合并DOM和CSSOM为一个渲染树。</li>\n<li>处理渲染树没一个节点的布局。</li>\n<li>最后将没一个节点渲染（绘制）到浏览器上。</li>\n</ul>\n<h3 id=\"阻塞渲染：css和javascript\">阻塞渲染：CSS和JavaScript</h3>\n<p>浏览器资源阻塞是一个常见的问题。要知道，资源在大多数浏览器上都是并行加载的，这种情况下，当Html文档被javascript阻塞时，Html文档会终止构建，但仍会<code>识别阻塞脚本后面的资源，进行预加载</code>。有以下要点需要注意：</p>\n<ul>\n<li>css加载不会阻塞dom树解析，但会阻塞dom树渲染。</li>\n<li>浏览器dom构建会在遇到script标签的时候暂停，直到script内的脚本执行完毕。</li>\n<li>CSSOM在构建的时候，JavaScript的执行会暂停，直到CSSOM准备就绪。</li>\n</ul>\n<p>以上正好说明了，我该把js脚本放在哪😄。我们就得出这样的原则以加快文档构建渲染：</p>\n<ol>\n<li>CSS优先渲染。将css放在JavaScript资源之上，也就是普遍的放在 &lt; head &gt; 标签内。</li>\n<li>为减少script脚本对dom构建的影响，应该把script尽可能的放到最后（文档底部）。</li>\n</ol>\n<h2 id=\"defer和async\">defer和async</h2>\n<p>script标签的这两个属性，均是为解决上面问题的。defer和async的使用有所不同。\n<code>defer</code>：DOM元素的加载和脚本的 ** 加载 ** 异步执行。但是脚本的执行需要在所有dom元素解析完成之后，在<code>DOMContentLoaded</code>事件触发之前执行。\n<code>async</code>：DOM元素的加载和脚本的加载 ** 以及执行 ** 异步执行。</p>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/65817605-0ae1dc00-e23c-11e9-890b-e70207d371b6.jpeg\" alt=\"284aec5bb7f16b3ef4e7482110c5ddbb_articlex\" ></p>\n<ul>\n<li>无async和defer的时候，dom渲染被脚本<del>加载以及执行</del>所中断。</li>\n<li>defer的时候，dom渲染未被阻塞，但脚本执行将会到最后。这个特性可以对需求有所利用。</li>\n<li>async的时候，dom渲染和脚本加载和执行异步。</li>\n</ul>\n<h2 id=\"有时候要用到动态引入？\">有时候要用到动态引入？</h2>\n<p>  统计脚本，广告脚本这类第三方嵌入脚本会在文档底部引入脚本文件。但都是以js生成script标签的形式进行动态引入。\n  先来看下百度统计脚本是怎么引入的：</p>\n<pre><code class=\"language-javascript\">(<span class=\"hljs-name\">function</span>() {\n  var hm = document.createElement(<span class=\"hljs-string\">&quot;script&quot;</span>)<span class=\"hljs-comment\">;</span>\n  hm.src = <span class=\"hljs-string\">&quot;https://hm.baidu.com/hm.js?10dbf7bc9ad86276329db7b&quot;</span><span class=\"hljs-comment\">;</span>\n  var s = document.getElementsByTagName(<span class=\"hljs-string\">&quot;script&quot;</span>)[<span class=\"hljs-number\">0</span>]<span class=\"hljs-comment\">;</span>\n  s.parentNode.insertBefore(<span class=\"hljs-name\">hm</span>, s)<span class=\"hljs-comment\">;</span>\n})()<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>这就是动态创建script标签进行引入的方式。那么为什么要这样引入而不是直接:</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;source_url&quot;</span> <span class=\"hljs-attr\">async</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>  ** 其实，这既不是自执行函数的问题，也不是阻塞渲染的问题。是为了防止用户把脚本放置在文档不规范的地方导致文档被阻塞，并不是所有的脚本嵌入用户都知道这个脚本应该嵌入在哪的。而这样动态引入就可以避免这样的问题。**</p>\n"},{"title":"CodeReview","slug":"2019_09_codereview","description":"公司能有CodeReview的实践是非常好的。它最终的作用是促进工程师日常代码交流和提升工程师的代码能力。","keywords":"代码,codeReview","labels":["学习"],"date":"2019-09-17","path":"2019/09/codereview.md","html":"<blockquote>\n<p>There are about 15-20 common mistakes made by programmers.\nA checklist is a useful means of ensuring that common mistakes are identified.</p>\n</blockquote>\n<p>公司能有CodeReview的实践是非常好的。它最终的作用是促进工程师日常代码交流和提升工程师的代码能力。</p>\n<h2 id=\"明确代码规范\">明确代码规范</h2>\n<p>无论前端还是后端，代码规范是很重要的。不应该把过多的CodeReview时间放在诸如代码空格、缩进等问题，这都是可以通过代码规范去约束的。各个开发人员都要尽力去写出符合公司代码规范的代码，减少CodeReview时间。</p>\n<h2 id=\"codereview-检查项\">CodeReview 检查项</h2>\n<p>有一个简单明确的检查项可以快速对代码进行检查，不用担心遗漏某些必要的项。以下的列表提供建议，可以按公司内要求进行优化添加等。</p>\n<h3 id=\"一般\">一般</h3>\n<ul>\n<li>代码是否符合预期的功能，逻辑是否正确。</li>\n<li>所写的代码是否容易理解。</li>\n<li>代码是否符合规定的编码规范。</li>\n<li>是否有冗余或者重复编写的代码。</li>\n<li>是否尽可能的模块化/组件化。</li>\n<li>全局变量是否全局定义（可以快速修改不必多处查找遗漏）。</li>\n<li>是否留下注释的代码（视情况保留，一般不要存在好些）。</li>\n<li>循环是否正确设置了结束条件。</li>\n<li>代码设置的变量命名是否符合语义，易于理解。</li>\n</ul>\n<h3 id=\"性能上\">性能上</h3>\n<ul>\n<li>是否还有更好的能提升既有性能的有效方法。</li>\n<li>是否有内置函数或者成熟的库/组件能替换已有代码。</li>\n<li>是否已移除掉日志和debug代码。</li>\n</ul>\n<h3 id=\"安全上\">安全上</h3>\n<ul>\n<li>输入类型的代码是否检查了类型、长度、提交格式等，后台是否对输入进行编码（encode）。（防xss）</li>\n<li>使用的第三方库有无错误异常捕获处理。</li>\n<li>容易出错的地方是否进行异常捕获处理。</li>\n<li>代码是否对变量做了空值判断处理。</li>\n</ul>\n<h3 id=\"解释说明上\">解释说明上</h3>\n<ul>\n<li>代码的作用是否有注释留下描述。</li>\n<li>所有函数都做了注释吗？</li>\n<li>有没对所有代码异常和边缘情况做好判断处理。</li>\n<li>引入的第三方库/组件是否做了必要的用途和引入说明。</li>\n<li>有没有不完整的代码？如果有，那代码可不可以删除或者标记TODO等？</li>\n</ul>\n<h3 id=\"reviewer--author\">Reviewer &amp;&amp; Author</h3>\n<p>这部分原文在：<a target='_blank'  href=\"https://phauer.com/2018/code-review-guidelines/\">戳</a></p>\n<ul>\n<li><strong>用I-Messages</strong></li>\n</ul>\n<blockquote>\n<p>You are not your code.</p>\n</blockquote>\n<p>要知道 <code>You !== Your Code</code>。给代码review错误不是对人review错误，不要把人自身价值和人写的代码连接起来。每个人都是团队中有价值的一部分。<br>在Author和Reviewer之间应该交换业务最好的实践、经验、一些踩坑点还有一些提示。<br>Reviewer在代码反馈上，有一个小规则我觉得挺有意思的：用I-Messages代替I-Messages。</p>\n<p>错误: “<strong>你</strong>写的这段代码存在黑魔法。”</p>\n<p>正确: “这段代码<strong>我</strong>不是很理解哦。”</p>\n<ul>\n<li><strong>讨论对象是代码不是人呐</strong></li>\n</ul>\n<p>只讨论代码可以增加review反馈的可接受度。</p>\n<p>错误: “<strong>你</strong>写的这代码请求了多次接口，这会影响性能。”</p>\n<p>正确: “<strong>这段代码</strong>触发多次请求了，应该会影响性能。”</p>\n<ul>\n<li> <strong>提问题</strong></li>\n</ul>\n<p>好的方式提问题，让人更好的接受。</p>\n<p>错误: “这变量就应该命名为UserId。”</p>\n<p>正确: “如果这变量命名为UserId是不是好理解多了？”</p>\n"},{"title":"分离小程序环境","slug":"2019_09_mp-env-seperate","description":"官方文档很模糊，搜索到了几条关于小程序环境分离的问题，大部分吐槽官方怎么没有一个好的办法分离开发和生产环境。","keywords":"小程序,环境,分离,云开发","labels":["小程序"],"date":"2019-09-08","path":"2019/09/mp-env-seperate.md","html":"<p>官方文档很模糊，搜索到了几条关于小程序环境分离的问题，大部分吐槽官方怎么没有一个好的办法分离开发和生产环境。</p>\n<h2 id=\"分离方式\">分离方式</h2>\n<ol>\n<li>云函数在调用的时候指定环境，依据云函数所在的环境进行动态设置。</li>\n</ol>\n<pre><code class=\"language-javascript\">const wxContext = cloud<span class=\"hljs-selector-class\">.getWXContext</span>()\n  cloud<span class=\"hljs-selector-class\">.updateConfig</span>({\n    env: wxContext<span class=\"hljs-selector-class\">.ENV</span>\n  })\n  <span class=\"hljs-comment\">// 初始化数据库</span>\n  const db = cloud<span class=\"hljs-selector-class\">.database</span>({\n    env: wxContext<span class=\"hljs-selector-class\">.ENV</span>\n  })\n</code></pre>\n<ol start=\"2\">\n<li>小程序端起到起立环境的主要作用。在appjs中。</li>\n</ol>\n<pre><code class=\"language-javascript\">     wx.cloud.init({\n        traceUser: true,\n        env: <span class=\"hljs-string\">&#x27;release-wifo3&#x27;</span>, <span class=\"hljs-regexp\">//</span> 测试环境\n        <span class=\"hljs-regexp\">//</span> env: <span class=\"hljs-string\">&#x27;dandan-zdm86&#x27;</span> <span class=\"hljs-regexp\">//</span> 正式环境\n      })\n</code></pre>\n<p>预览小程序的时候开启测试环境的env，在部署上线发布的时候再切换为正式环境。</p>\n"},{"title":"我想要小程序过审","slug":"2019_08_mp-pass","description":"小程序审核是很多小程序开发者的痛。怎么让小程序审核通过，这里有一个小技巧。","keywords":"mp,小程序,审核","labels":["小程序"],"date":"2019-08-23","path":"2019/08/mp-pass.md","html":"<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"http://tva1.sinaimg.cn/large/007X8olVly1g69pnw5ai1j30mu05cmxx.jpg\" alt=\"cover\" >\n小程序审核就是一个痛。资质、内容没问题的自然感受不到这样的痛苦。</p>\n<p>尤其是个人小程序，不给你过，因为你小程序有UGC；不给你过，因为你诱导用户分享...</p>\n<p>如果类目多还好，个人小程序就那几个能用（感兴趣）的类目，还能怎么办。反正上线过多次小程序，也尝试过很多次审核不通过，对于怎么避开审核组哥哥姐姐的法眼，我有一个代码级绕过的方法。</p>\n<h2 id=\"什么内容导致审核不过\">什么内容导致审核不过</h2>\n<p>要十分清楚什么内容导致小程序没法审核通过。审核不过会简单把驳回原因返回，无外乎是资质、内容之类的问题。有时候觉得描述的模凌两可，我的小程序没有这些违规的，怎么审核还是不过呢！不怕，多试几次之后，很有可能审核组会给一张审核不过的“证据图”。一般是小程序的截图。</p>\n<h2 id=\"怎么避开\">怎么避开</h2>\n<p>知道什么原因后，就想办法绕开审核。希望你的小程序不是很违规，只想上线满足自己那种程度，不要干坏事！ </p>\n<p>我自己总结了两种办法，两种办法的核心都是：<code>不要在审核员在审核期间看到不该看到的内容</code>。</p>\n<ol>\n<li>使用延迟显示。</li>\n</ol>\n<p>定义一个时间戳，你的内容将在时间戳到达后显示出来。基本的代码可以如下：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 判断是否在审核期间</span>\n<span class=\"hljs-keyword\">const</span> nowTime = <span class=\"hljs-built_in\">Date</span>.parse(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>())\n<span class=\"hljs-keyword\">if</span> (nowTime &lt; <span class=\"hljs-number\">1565078400000</span>) { <span class=\"hljs-comment\">// 2019-08-06 16:00:00</span>\n  <span class=\"hljs-built_in\">this</span>.globalData.isEscape = <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// true 的时候就放开内容</span>\n}\n</code></pre>\n<p>这样就可以屏蔽掉并保证在isEscape为false的时候不显示违规内容。当然这么做还是有缺点的：你不能保证你的小程序审核时候处于审核期，有可能审核周期很长，那怎么办？</p>\n<ol start=\"2\">\n<li>使用接口控制显示。</li>\n</ol>\n<p>接口这个总该稳了吧？</p>\n<pre><code class=\"language-javascript\">wx<span class=\"hljs-selector-class\">.request</span>({\n  url: <span class=\"hljs-string\">&#x27;##&#x27;</span>,\n  method: <span class=\"hljs-string\">&#x27;GET&#x27;</span>,\n  success(res) {\n    getApp()<span class=\"hljs-selector-class\">.globalData</span><span class=\"hljs-selector-class\">.isEscape</span> = res<span class=\"hljs-selector-class\">.data</span><span class=\"hljs-selector-class\">.isEscape</span>\n  }\n})\n</code></pre>\n<p>这其实也不是很好，毕竟接口存在延迟。多少会有。尤其是在云开发的免费配额上，这基本是会影响体验。判断究竟用那种方法，取决于你小程序上线的周期安排等。</p>\n<h2 id=\"提示\">提示</h2>\n<p>小程序审核应该能绕过页面逻辑直接打开全部pages定义的页面的，所以要针对这个做一些跳转屏蔽处理。</p>\n"},{"title":"小程序egg后台简要文档","slug":"2019_06_mp-egg","description":"如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。","keywords":"mp,小程序,eggjs,微信开发后台","labels":["小程序"],"date":"2019-06-06","path":"2019/06/mp-egg.md","html":"<p>如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。</p>\n<p>如果未接触过node编写接口，首先还是需要基本过一下<a target='_blank'  href=\"https://eggjs.org/zh-cn/intro/\">egg官方文档</a>，至少得把快速入门看完。</p>\n<p>不会从头开始把每一步都详细写下来，只针对微信对接的一些处理列出来。</p>\n<h2 id=\"数据库\">数据库</h2>\n<p>使用mongo，示例通过<a target='_blank'  href=\"https://github.com/eggjs/egg-mongoose\">egg-mongoose</a>进行连接处理。</p>\n<p>安装插件后，在<code>/config/plugin.js</code>进行基本配置：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-attr\">mongoose:</span> {\n  <span class=\"hljs-attr\">enable:</span> <span class=\"hljs-literal\">true</span>,\n  <span class=\"hljs-attr\">package:</span> <span class=\"hljs-string\">&#x27;egg-mongoose&#x27;</span>\n}\n</code></pre>\n<p>在<code>/config/config.default.js</code>文件中配置mongodb的连接（保证本地测试环境数据库连接好）：</p>\n<pre><code class=\"language-javascript\">// connect mongo\n  config.mongoose = {\n    clien<span class=\"hljs-variable\">t:</span> {\n      ur<span class=\"hljs-variable\">l:</span> <span class=\"hljs-string\">&#x27;mongodb://127.0.0.1/fulishe&#x27;</span>,\n      option<span class=\"hljs-variable\">s:</span> {},\n    }\n  }\n</code></pre>\n<p>在<code>/app/models</code>文件夹编写相关的model，在程序运行时会自动在mongo上创建对应的表。也可以优先创建好数据库和表设计等。</p>\n<h2 id=\"编写接口\">编写接口</h2>\n<p>在<code>controller</code>写主要的业务逻辑，接受接口请求参数并返回。\n对于入参，需要进行验证的可以做验证处理，需要处理返回结果，即使请求出错也不要返回非200的状态码。\n可以将处理结果设置为一个函数，如：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// data: 返回给前端的数据，code: 状态，1为成功，0为失败，message：状态信息</span>\n<span class=\"hljs-symbol\">formatResponse:</span> <span class=\"hljs-meta\">function</span> (<span class=\"hljs-meta\">data</span>, <span class=\"hljs-meta\">code</span>, message) {\n  return {\n    <span class=\"hljs-meta\">code</span>,\n    <span class=\"hljs-meta\">data</span>,\n    message\n  }\n}\n</code></pre>\n<p>!&gt; 为避免出现出现问题而导致程序中断，最好在每一个容易出现问题的地方进行<code>try catch</code>将异常抛出并返回到前端。</p>\n<p>在<code>service</code>编写数据库操作函数等，通过在<code>controller</code>进行调用，统一管理数据库数据进出。\n注意在数据新增的时候需要进行<code>save</code>操作：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> addUser = await <span class=\"hljs-keyword\">this</span>.ctx.model.Users(<span class=\"hljs-keyword\">data</span>)\naddUser.save() <span class=\"hljs-comment\">// 不要遗漏</span>\n</code></pre>\n<p>相关的增删改查操作，需要直接点的可以看仓库<code>app/service</code>下的写法。</p>\n<h2 id=\"小程序接口相关\">小程序接口相关</h2>\n<p>以下是eggjs对小程序包括获取openId、获取unionId、获取手机号码、判断用户是否关注公众号、客服信息发送进行编写说明。<br>如果某个对象不知道是什么，一般都是可以根据名字找到对于的js文件或者通过npm引入，不再表述引入什么了。</p>\n<h3 id=\"获取openid\">获取openId</h3>\n<p>参数说明：</p>\n<ul>\n<li>APPID： 小程序的appId</li>\n<li>SECRET： 小程序的secret，跟appId在同一个地方能找到</li>\n<li>CODE：小程序在前端通过wx.login()获取的jscode</li>\n</ul>\n<pre><code class=\"language-javascript\">const openIdRes = await rp(`https:<span class=\"hljs-regexp\">//</span>api.weixin.qq.com<span class=\"hljs-regexp\">/sns/</span>jscode2session?appid=<span class=\"hljs-variable\">${APPID}</span>&amp;secret=<span class=\"hljs-variable\">${SECRET}</span>&amp;js_code=<span class=\"hljs-variable\">${CODE}</span>&amp;grant_type=authorization_code`)\nconst openId = JSON.parse(openIdRes).openId <span class=\"hljs-regexp\">//</span> 在处理错误判断后，返回的数据是json字符串，需要转化\n</code></pre>\n<h3 id=\"获取unionid\">获取unionId</h3>\n<p>unionId，属于微信端通用的账号唯一标识，举个例子就是同一个微信号，唯一对应一个unionId。而在每一个小程序上，用户openId都不一样。可以用于判断在小程序上的用户是否关注公众号等。</p>\n<p>在第一个获取<code>openId</code>的时候，会返回<code>openId</code>以及<code>session_key</code>，通过小程序前端传过来的<code>encryptedData</code>以及<code>iv</code>就可以拿到<code>unionId</code>。</p>\n<p>参数说明：</p>\n<ul>\n<li>APPID： 小程序的appId</li>\n<li>sessionKey：获取openId的时候，一并返回了sessionKey</li>\n<li>encryptedData：小程序在前端通过获取用户信息返回</li>\n<li>iv：小程序在前端通过获取用户信息返回</li>\n</ul>\n<pre><code class=\"language-javascript\">const pc = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">WXBizDataCrypt(APPID, <span class=\"hljs-params\">sessionKey</span>)</span>\nconst data = pc.decrypt<span class=\"hljs-constructor\">Data(<span class=\"hljs-params\">encryptedData</span>, <span class=\"hljs-params\">iv</span>)</span>\nconst unionId = data.unionId\n</code></pre>\n<h3 id=\"获取手机号码\">获取手机号码</h3>\n<p>获取手机号码的步骤跟获取unionId一样。</p>\n<p>只需要注意的是，<code>encryptedData</code>、<code>iv</code>是在小程序端通过<code>getPhoneNumber</code>获取。</p>\n<h3 id=\"判断用户是否关注公众号\">判断用户是否关注公众号</h3>\n<p>这里单独在小程序后台无法判断。需要在对于的公众号后台提供一个接口用于判断该unionId是否已经关注了公众号。</p>\n<h3 id=\"客服信息发送\">客服信息发送</h3>\n<p>在小程序开发设置中配置消息推送。</p>\n<p>配置参考： </p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>值</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>URL(服务器地址)</td>\n<td>https://<em>.</em>.com/message/check</td>\n<td>微信那边与你服务器通信的接口</td>\n</tr>\n<tr>\n<td>Token(令牌)</td>\n<td>isToken</td>\n<td>自定义</td>\n</tr>\n<tr>\n<td>EncodingAESKey(消息加密密钥)</td>\n<td>******</td>\n<td>填写那可以自动生成</td>\n</tr>\n<tr>\n<td>消息加密方式</td>\n<td>兼容模式</td>\n<td>涉及信息安全</td>\n</tr>\n<tr>\n<td>数据格式</td>\n<td>JSON</td>\n<td>一般是这个吧</td>\n</tr>\n</tbody></table>\n<p>在<code>controller</code>层编写一个<code>get</code>接口，对应<code>/message/check</code>，用以给微信进行服务器验证。\n完整验证函数接口可如下：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-title\">index</span>(<span class=\"hljs-params\"></span>)</span> {\n  <span class=\"hljs-keyword\">const</span> { ctx } = <span class=\"hljs-keyword\">this</span>\n  <span class=\"hljs-comment\">// 1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr</span>\n  <span class=\"hljs-keyword\">const</span> {\n    signature,\n    timestamp,\n    nonce,\n    echostr\n  } = ctx.query\n\n  <span class=\"hljs-comment\">// 2.将token、timestamp、nonce三个参数进行字典序排序</span>\n  <span class=\"hljs-keyword\">let</span> array = [<span class=\"hljs-string\">&#x27;线上配置的令牌&#x27;</span>, timestamp, nonce]\n  array.sort() <span class=\"hljs-comment\">// JavaScript sort函数就是字典序排序的</span>\n\n  <span class=\"hljs-comment\">// 3.将三个参数字符串拼接成一个字符串进行sha1加密</span>\n  <span class=\"hljs-keyword\">const</span> tempStr = array.<span class=\"hljs-keyword\">join</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>)\n  <span class=\"hljs-keyword\">const</span> hashCode = crypto.createHash(<span class=\"hljs-string\">&#x27;sha1&#x27;</span>) <span class=\"hljs-comment\">//创建加密类型</span>\n  <span class=\"hljs-keyword\">const</span> resultCode = hashCode.update(tempStr, <span class=\"hljs-string\">&#x27;utf8&#x27;</span>).digest(<span class=\"hljs-string\">&#x27;hex&#x27;</span>)\n\n  <span class=\"hljs-comment\">// 4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</span>\n  <span class=\"hljs-keyword\">if</span> (resultCode === signature) {\n    ctx.body = echostr\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 非微信服务器请求</span>\n    ctx.body = format.formatResponse({\n      resultCode,\n      req: ctx.query\n    }, <span class=\"hljs-number\">0</span>, <span class=\"hljs-string\">&#x27;验证失败1&#x27;</span>)\n  }\n}\n</code></pre>\n<p>自动回复操作：\n在<code>controller</code>层编写一个<code>post</code>接口，对应<code>/message/check</code>，用于自动回复。\n完整处理自动回复接口：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-title\">handle</span>(<span class=\"hljs-params\"></span>)</span> {\n  <span class=\"hljs-keyword\">const</span> { ctx } = <span class=\"hljs-built_in\">this</span>\n  <span class=\"hljs-keyword\">const</span> { FromUserName, MsgType, Content } = ctx.request.body <span class=\"hljs-comment\">// 这是从微信转发过来的用户发送的信息参数</span>\n  <span class=\"hljs-keyword\">const</span> { openid } = ctx.query\n  <span class=\"hljs-comment\">// 获取accessToken</span>\n  <span class=\"hljs-keyword\">const</span> tokenRes = <span class=\"hljs-keyword\">await</span> rp(<span class=\"hljs-string\">`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=<span class=\"hljs-subst\">${CONST.appId}</span>&amp;secret=<span class=\"hljs-subst\">${CONST.secret}</span>`</span>)\n  <span class=\"hljs-keyword\">if</span> (!(<span class=\"hljs-string\">&#x27;errcode&#x27;</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">JSON</span>.parse(tokenRes))) {\n    <span class=\"hljs-keyword\">if</span> (MsgType === <span class=\"hljs-string\">&#x27;text&#x27;</span>) {\n      <span class=\"hljs-keyword\">const</span> postData = {\n        <span class=\"hljs-attr\">touser</span>: openid,\n        <span class=\"hljs-attr\">msgtype</span>: <span class=\"hljs-string\">&quot;link&quot;</span>,\n        <span class=\"hljs-attr\">link</span>: {\n          <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;链接标题&#x27;</span>,\n          <span class=\"hljs-attr\">description</span>: <span class=\"hljs-string\">&#x27;链接描述&#x27;</span>,\n          <span class=\"hljs-attr\">url</span>: <span class=\"hljs-string\">&#x27;链接&#x27;</span>,\n          <span class=\"hljs-attr\">thumb_url</span>: <span class=\"hljs-string\">&#x27;链接封面图&#x27;</span>\n        }\n      }\n      <span class=\"hljs-keyword\">const</span> sendRes = <span class=\"hljs-keyword\">await</span> rp({\n        <span class=\"hljs-attr\">uri</span>: <span class=\"hljs-string\">`https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=<span class=\"hljs-subst\">${<span class=\"hljs-built_in\">JSON</span>.parse(tokenRes).access_token}</span>`</span>,\n        <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&#x27;post&#x27;</span>,\n        <span class=\"hljs-attr\">body</span>: postData,\n        <span class=\"hljs-attr\">json</span>: <span class=\"hljs-literal\">true</span>\n      })\n    }\n  }\n  ctx.body = <span class=\"hljs-string\">&#x27;success&#x27;</span>\n}\n</code></pre>\n<p>!&gt; 注意：需要在自动回复的最后返回<code>success</code>，否则会在聊天窗口看到提示：<code>该小程序提供的服务出现故障，请稍后再试</code></p>\n"},{"title":"修改浏览器回退历史","slug":"2019_04_history-api","description":"有个需求，需要修改短链跳转到落地页后，在落地页返回的历史记录。避免出现跳转到落地页后返回还是出现短链中转的问题。","keywords":"浏览器,回退历史，history api,pushState,replaceState","labels":["前端"],"date":"2019-04-12","path":"2019/04/history-api.md","html":"<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/56006752-c05db900-5d08-11e9-94c3-61938d3f2eeb.png\" alt=\"无标题绘图\" ></p>\n<p>有个需求，需要修改短链跳转到落地页后，在落地页返回的历史记录。避免出现跳转到落地页后返回还是出现短链中转的问题。</p>\n<p>要求：</p>\n<ol>\n<li>无法控制落地页的所有代码。</li>\n<li>回退页面可在短链内进行定义。 </li>\n</ol>\n<h3 id=\"history-api\">History Api</h3>\n<p>history api提供浏览器修改历史记录功能。简单罗列下api的一些使用。</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-regexp\">//</span> 返回上一个历史记录\nwindow.history.back()\nwindow.history.go(-<span class=\"hljs-number\">1</span>)\n\n<span class=\"hljs-regexp\">//</span> 前进一个历史记录\nwindow.history.forward()\nwindow.history.go(<span class=\"hljs-number\">1</span>)\n\n<span class=\"hljs-regexp\">//</span> 添加或者替换历史记录条目，注意这【并不会刷新页面】。\nhistory.pushState(state, title, url);\n<span class=\"hljs-regexp\">//</span> state：网址相关的状态Object，在popstate事件触发时，会在回调函数中接收到这个对象。不需要的话可以设为null。\n<span class=\"hljs-regexp\">//</span> title：新页面的title属性，填null。\n<span class=\"hljs-regexp\">//</span> url：新的页面地址，必须必须和上一个页面处于同域，否则抛出异常。\n\n<span class=\"hljs-regexp\">//</span> 替换当前的历史记录，注意这【并不会刷新页面】。\nhistory.replaceState(state, title, url);\n<span class=\"hljs-regexp\">//</span> 参数同上。\n</code></pre>\n<h3 id=\"实现的思考\">实现的思考</h3>\n<ol>\n<li><p>第一次尝试。既然要实现在落地页返回的历史，可不可以在短链中转页上监听一下上一页面的url，当然在跳转到落地页之前可以在落地页的url上带上参数，可以在短链中转页上通过是否带这个参数进行判断。放弃，理由是麻烦而且不稳定，可能出现难以预料的问题。</p>\n</li>\n<li><p>第二次尝试。使用历史记录api修改历史记录。要修改的页面是短链中转页的历史记录，需要替换【当前】短链中转页的历史，使得跳转到落地页到上一个历史是短链所配置到页面。</p>\n</li>\n</ol>\n<p>需要注意到是，历史记录不能replace或者push不同域的url。所以需要通过一个queryString进行判断。所以做法是：</p>\n<pre><code class=\"language-javascript\">window.onload = <span class=\"hljs-keyword\">function</span><span class=\"hljs-literal\">()</span> {\n      <span class=\"hljs-keyword\">if</span> (get<span class=\"hljs-constructor\">Param(&#x27;<span class=\"hljs-params\">backUrl</span>&#x27;, <span class=\"hljs-params\">location</span>.<span class=\"hljs-params\">href</span>)</span>) {\n        console.log(&#x27;进入跳转到预定回退页&#x27;)\n        location.replace(get<span class=\"hljs-constructor\">Param(&#x27;<span class=\"hljs-params\">backUrl</span>&#x27;, <span class=\"hljs-params\">location</span>.<span class=\"hljs-params\">href</span>)</span>)\n      } <span class=\"hljs-keyword\">else</span> {\n        console.log(&#x27;进入跳转到落地页并改写历史&#x27;)\n        history.replace<span class=\"hljs-constructor\">State(<span class=\"hljs-params\">null</span>, <span class=\"hljs-params\">null</span>,  <span class=\"hljs-string\">&quot;[域名、处理返回逻辑页面]?backUrl=https://www.baidu.com&quot;</span>)</span>\n        document.get<span class=\"hljs-constructor\">ElementById(&#x27;<span class=\"hljs-params\">jump</span>-<span class=\"hljs-params\">id</span>&#x27;)</span>.click<span class=\"hljs-literal\">()</span> <span class=\"hljs-comment\">// 跳转到落地页</span>\n      }\n    }\n<span class=\"hljs-comment\">// getParam是获取链接qs参数的函数。</span>\n</code></pre>\n"},{"title":"项目突然跑不起来","slug":"2019_04_project-down","description":"项目突然跑不起来","keywords":"node,dev,network,shadowsocks","labels":["前端"],"date":"2019-03-08","path":"2019/04/project-down.md","html":"<h2 id=\"突遇node建本地开发服务的项目跑不起来\">突遇node建本地开发服务的项目跑不起来</h2>\n<p>今天早上来上班，发现平时跑的一个项目突然跑不了。症状如下：</p>\n<ol>\n<li>command无任何异常。</li>\n<li>autoOpenBrowser正常，打开浏览器后一直转加载。</li>\n<li>console无任何报错。</li>\n<li>network仅有一个document处理一直pending的状态。</li>\n<li>理应不是端口问题，如果端口被占用会自动选一个的。</li>\n</ol>\n<h2 id=\"找问题\">找问题</h2>\n<ol>\n<li>查看本机ip变了没有？</li>\n<li>这个项目不行，再跑一个其他的同类项目，还是有这个问题？</li>\n<li>重启个电脑试一下吧？</li>\n<li>最后，问题是：<code>shadowsocks开了全局代理忘了关</code>。\n<img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/55298682-903d2d00-5461-11e9-8c7f-6cdb66b0dea2.png\" alt=\"WX20190401-093546\" ></li>\n</ol>\n"},{"title":"黑苹果计划","slug":"2019_03_hackintosh","description":"小米笔记本 13.3 指纹版 i5 7200U；目标系统：macOS High Sierra 10.13","keywords":"hackintosh,xiaomi,sierra 10.13,i5 7200U,13.3,macos","labels":["折腾"],"date":"2019-03-08","path":"2019/03/hackintosh.md","html":"<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/53999869-1a0a1b00-4180-11e9-8c8b-8b564e12ff99.jpg\" alt=\"macos-high-sierra\" >\n<strong>看到米本现在黑苹果貌似可以挺稳定的工作，所以想折腾的心就沸腾起来了。也为了方便前端开发！</strong></p>\n<h2 id=\"机器\">机器</h2>\n<p>小米笔记本 13.3 指纹版 i5 7200U；目标系统：macOS High Sierra 10.13</p>\n<h2 id=\"前期工作\">前期工作</h2>\n<p>由于原本在windows上进行开发，还有之前装过windows和mint的双系统，所以现在的状态是GNU 启动。前期有很多的工作要做，是否要重新格盘安装也是未知数。现在前期工作的基本流程是：移除linux分区，移除GNU引导启动，进行备份工作。以上有风险的是：</p>\n<ol>\n<li>完全移除linux，稍有不慎可能就启动不了两个系统了。自己在处理这部分的知识不是很足，所以谨慎为妙。</li>\n<li>备份工作使用移动硬盘进行备份，主要是工作文档的备份。下面会罗列在windows上进行备份的一些软件链接和配置等。</li>\n</ol>\n<h2 id=\"windows软件配置列表\">windows软件配置列表</h2>\n<ul>\n<li><a target='_blank'  href=\"https://www.google.com/chrome/\">Google Chrome</a></li>\n<li>Adobe Photoshop CS6</li>\n<li><a target='_blank'  href=\"https://www.axure.com/\">Axure RP8</a></li>\n<li><a target='_blank'  href=\"https://cn.bandisoft.com/bandizip/\">Bandizip</a></li>\n<li><a target='_blank'  href=\"https://conemu.github.io/\">ConEmu</a></li>\n<li><a target='_blank'  href=\"https://www.foxmail.com/\">Foxmail</a></li>\n<li>Git version</li>\n<li>Go programming</li>\n<li>KMPlayer</li>\n<li>Logitech 游戏软件</li>\n<li>Microsoft Office Professional Plus 2013</li>\n<li>Microsoft Visual Studio Code </li>\n<li>Mozilla Firefox</li>\n<li>Node.js</li>\n<li>PostgreSQL 11</li>\n<li>PremiumSoft Navicat Premium</li>\n<li>Fiddler</li>\n<li>PuTTY</li>\n<li>PxCook</li>\n<li>Python 3.7.0</li>\n<li>Ruby</li>\n<li>TIM</li>\n<li>TortoiseSVN</li>\n<li>WinHTTrack Website Copier</li>\n<li>XMind</li>\n<li>Yarn</li>\n<li>火绒安全软件</li>\n<li>企业微信</li>\n<li>贴吧、网易云音乐、微信</li>\n<li>微信web开发者工具</li>\n<li>迅雷极速版</li>\n<li>Shadowsocks</li>\n</ul>\n<h2 id=\"主要进行开发配置备份\">主要进行开发配置备份</h2>\n<p><strong>Chrome</strong>:保证所有内容同步到谷歌服务器。\n<strong>Logitech 游戏软件</strong>:关闭鼠标背光，灯光设置-关闭标识。\n<strong>Microsoft Visual Studio Code</strong>:确保配置Settings Sync，保存gist以及token。\n<strong>PuTTY</strong>: IP:144.34.221.194 Port:28333 Connection type: SSH</p>\n<h2 id=\"进度\">进度</h2>\n<p><a target='_blank'  href=\"https://blog.str-mo.com/tech/217/\">教程链接</a></p>\n<ul>\n<li>数据备份------ 0%</li>\n<li>安装准备 ------ 10%，已刻录mac os镜像</li>\n<li>原系统处理 ------ 0%</li>\n</ul>\n<h2 id=\"关于espefi分区的扩容\">关于esp(EFI)分区的扩容</h2>\n<p>如果是win10和黑果双系统的话，需要保证安装黑果的硬盘内的esp分区大小不小于200M。而win10一般都是100M，所以就必须要进行esp扩容，否则没法对硬盘进行抹除操作。对于这部分，我昨天查了不少的资料，属于点门外汉吧。经过测试，一般的做法是：</p>\n<ol>\n<li>在windows下，打开DiskGenius。在windows自带的磁盘管理上，分出一个未分配的磁盘空间，大小够200M即可（压缩卷）。在未分配的磁盘上新建一个esp分区（右键未分配的分区，点击新建分区，后选EFI那个选项），大小为未分配磁盘空间的大小，保存。</li>\n<li>在DiskGenius下，浏览原esp分区的文件，将原来的文件复制到桌面，再从桌面复制到新的esp分区上。然后删除原来的100M的esp分区，保存，重启还是可以进入windows的。<br>到此，esp分区扩容就完成了。接着按教程走就行。</li>\n</ol>\n<h2 id=\"镜像说明\">镜像说明</h2>\n<p>字节莫的镜像存在无法选择Apple安装的问题，在黑果小兵的博客上找到这个镜像的发布说明。<a target='_blank'  href=\"https://blog.daliansky.net/macOS-High-Sierra-10.13.6-17G65-Release-Version-with-Clover-4596-original-mirror.html\">镜像地址</a>。\n里面有对这个问题进行说明：  </p>\n<blockquote>\n<p>重要提示：由于CLOVER新版的缘故，原来的HD3000/HD4000的配置文件不支持新版，会造成进CLOVER后卡住的情况，请降低CLOVER版本，或者直接删除掉所有的HD3000/HD4000开头的配置文件；</p>\n</blockquote>\n<p>按照上面引用的做法，就不用字节莫的efi文件了，直接用原来的efi然后删除上面的配置文件。删除文件的方法不用说了吧。接着重启就可以选择苹果进入安装了。</p>\n<h2 id=\"替换驱动\">替换驱动</h2>\n<p>在mac系统内操作，用访达打开字节莫或者其他好的EFI，依次找路径：EFI-CLOVER-kexts-other文件夹，里面有很多驱动。</p>\n<ol>\n<li>触摸板驱动：<code>ApplePS2SmartTouchPad.kext</code>。效果：触摸板ok。  </li>\n</ol>\n<p>将驱动拖动到Kext Utility，不要拖几次，一次就行，只是有其他加载工作在，等到第二次输入密码的时候就是安装的时候。<br>安装后重启驱动效果就有了。</p>\n<p>我试了两个ALC的驱动都不能驱动声音。。如果有知道的可以提一下。\n亮度也不敢弄，怕显卡驱动不好开不到机，目前配置好了很多开发工具，不大敢冒险了。<br>目前亮度的调节是用App Store里面的<code>Brightness slider</code>进行调节。治标不治本！</p>\n<ol start=\"2\">\n<li>声卡解决：\n下载下面这个声卡驱动。按上面一楼的安装方法，完成后重启就行。\n链接: <a target='_blank'  href=\"https://pan.baidu.com/s/1pkaaUN3hCbxJhkVhX4kn9w\">https://pan.baidu.com/s/1pkaaUN3hCbxJhkVhX4kn9w</a> 提取码: kiur </li>\n<li>其他：<br>如果发现耳机杂音，可以在设置-输出-将平衡拖动到最左或者最右即可。</li>\n</ol>\n"},{"title":"新的一年，加油","slug":"2019_02_new-year","description":"新的一年，加油","keywords":"new year,新的一年","labels":["随笔"],"date":"2019-02-10","path":"2019/02/new-year.md","html":"<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://media.socastsrm.com/wordpress/wp-content/blogs.dir/348/files/2019/01/crop635w_college-scholarships-2019-edition.jpg\" alt=\"cover\" ></p>\n<p>过去2018年，是自己进步非常大的一年。进了新的公司，认识一批新的同事。在众多的业务中能得到不少的帮助。自己也趁机学习和实践了很多的开发技术，最多而且最有印象的就是小程序的开发了。上一年的进步离不开自己对开源和技术的热爱，以及同事之间的帮助，当然很重要的是有不错的感情寄托。</p>\n<p>在慢慢的进步中，来到了2019年，我的本命年。</p>\n<p>很不幸，遇到了比较大的打击，导致心态崩溃了吧😭。</p>\n<p>往后的生活工作还是需要自己好好把握好好争取，有些事情需要自己去挖掘去熟悉，这样才会成长起来。很重要的一部分就是需要自己的自律，外加就是有计划的生活了。</p>\n<p>我在知乎上也写了一些关于自己在2019上的学习计划，其中TS和Flutter是自己需要好好学习的，尤其是TS需要跟着Vue 3.0的发布而运用到项目中。对于偏后端的应用上，会主动的学习Egg.js，最好是能找机会能在项目中应用上。</p>\n<p>开年的打击还是会伴着我一段比较长的时间，但生活还得继续，自己的坚持还要持续下去，无论多难，身边总会有朋友，家人的鼓励支持，这将是我2019年甚至是往后很重要的支柱了。</p>\n<p>2019年，给猪年的自己，加一份油😁。</p>\n"},{"title":"chrome出现Caution provisional headers are shown的问题","slug":"2019_01_chrome-provisional-header","description":"chrome出现Caution provisional headers are shown的问题","keywords":"chrome,caution,provisional,headers are shown","labels":["前端"],"date":"2019-01-07","path":"2019/01/chrome-provisional-header.md","html":"<p>开发的一个项目出现一个Caution：</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">Caution provisional headers are shown</span>\n</code></pre>\n<p>注：这个提示出现在chrome开发者工具的每一个接口请求上。这也只是个警告，还要理它干啥？先看看Google“热搜”的第一个解答：\n<a target='_blank'  href=\"https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger\">“CAUTION: provisional headers are shown” in Chrome debugger</a>\n“请求被阻塞，东西发不出去，自然没有东西回来”<br>在答者那的例子他说是被adblock拦截了。</p>\n<h2 id=\"问题\">问题</h2>\n<p>在项目上线的这段时间内，前期由于使用的少，并未将问题暴露出来，后面使用的人数多了之后，就会出现一个高概率的事情：\n<strong>个别接口请求一直处于pending状态，数据无法回流</strong><br>这个问题比较严重，后面一直在找解决方案。我的思路历程是：</p>\n<ol>\n<li>一开始发现这个问题的时候，有些不可思议，第一次遇到，如果这是一个普遍的问题，为啥又只会出现在个别接口（非固定的个别接口）？</li>\n<li>调试工具出现<code>provisional headers are shown</code>的警告，瞄准这个警告入手。找到了大量相关的问题描述和方法，在前端这边的处理都未解决。在拦截器修改头，在<code>net-internals</code>抓起日志等就差在每个请求后加上时间戳了（怀疑是前端缓存cache出现异常）。</li>\n<li>开始怀疑是后端的问题。与后端商量后，在日志打印那发现每一个请求返回都在几毫秒内。当然这个好像没有什么参考性，因为前端貌似这边请求并未成功发出。</li>\n<li>发现除chrome默认模式外，其它浏览器比如firefox、Edge都没这个问题。甚至在chrome无痕模式也没有这个问题。这时候觉得解决问题比找到原因更重要了（因为已经上线了）。</li>\n<li>经过后端前端的协调与商量，发现这大概率是因为前后端跨域而出现的问题。</li>\n</ol>\n<h2 id=\"解决\">解决</h2>\n<p><strong>设置请求接口与静态文件处于同源状态（需要nginx配置），警告消失，经过一段时间观察，问题解决。</strong></p>\n"},{"title":"koa异步写文件遇到的小问题","slug":"2018_12_koa-async","description":"最近用koa写个微信小程序二维码生成接口，出现了一个小坑：由于小程序二维码生成接口返回的是二进制流，需要通过fs操作生成图片返回给前端下载。期间反复出现下载文件大小为0（零 / 大小未知）的情况。","keywords":"koa,async,file","labels":["前端"],"date":"2018-12-13","path":"2018/12/koa-async.md","html":"<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://github.com/koajs/koa/raw/master/docs/logo.png\" alt=\"koa\" >\n最近用koa写个微信小程序二维码生成接口，出现了一个小坑：由于小程序二维码生成接口返回的是二进制流，需要通过fs操作生成图片返回给前端下载。期间反复出现下载文件大小为0（零 / 大小未知）的情况。  </p>\n<p><strong>主要生成二维码代码如下</strong></p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 其余代码省略</span>\n<span class=\"hljs-keyword\">const</span> writeS = fs.createWriteStream(<span class=\"hljs-string\">&#x27;qrcode.png&#x27;</span>)\n<span class=\"hljs-keyword\">await</span> request(<span class=\"hljs-comment\">{\n  uri: `https://api.weixin.qq.com/wxa/getwxacode?access_token=${token}</span>`,\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">method</span>:</span> <span class=\"hljs-string\">&#x27;post&#x27;</span>,\n  body: data,\n  json: <span class=\"hljs-keyword\">true</span>\n}).pipe(writeS)\n<span class=\"hljs-comment\">// 其余代码省略</span>\n</code></pre>\n<p>需要有个先后顺序问题，必须先等到文件写完后才能进行图片下载接口调用。处理方法是在前端调用生成二维码的接口，而接口的操作需要有个等待过程，即要在<code>createWriteStream</code>结束后<strong>生成二维码接口</strong>才返回数据。  </p>\n<p>前端在接收到<strong>生成二维码接口</strong>返回数据后才调用下载二维码接口。  </p>\n<p>koa端等待写文件结束后返回，这里koa要用promise在callback后触发返回数据：</p>\n<pre><code class=\"language-javascript\"> ctx.body = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">(resolve, reject)</span> =&gt;</span> {\n    writeS.<span class=\"hljs-literal\">on</span>(<span class=\"hljs-string\">&#x27;finish&#x27;</span>, function () {\n      resolve({\n        code: <span class=\"hljs-number\">1</span>\n      })\n    })\n  })\n</code></pre>\n<p>前端监听操作：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-title\">if</span> (res.<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span>.code === 1) {\n  <span class=\"hljs-title\">window</span>.<span class=\"hljs-title\">open</span>(&#x27;图片下载地址&#x27;)\n}</span>\n</code></pre>\n<p>具体接口代码（<a target='_blank'  href=\"https://github.com/GzhiYi/wxqrcode-generater/blob/master/index.js\">查看</a>）</p>\n"},{"title":"ES6 Module语法小结","slug":"2018_12_es6-module","description":"ES6 Module语法小结","keywords":"es6,ES6,module","labels":["前端"],"date":"2018-12-12","path":"2018/12/es6-module.md","html":"<h2 id=\"export\"><code>export</code></h2>\n<ol>\n<li>输出变量。</li>\n</ol>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">name</span> = <span class=\"hljs-string\">&#x27;GzhiYi&#x27;</span>;\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> job = <span class=\"hljs-string\">&#x27;Frontend&#x27;</span>;\n</code></pre>\n<p>以上可简写（荐）：</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">name</span> = <span class=\"hljs-string\">&#x27;GzhiYi&#x27;</span>;\n<span class=\"hljs-keyword\">const</span> job = <span class=\"hljs-string\">&#x27;Frontend&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-comment\">{ name, job }</span>;\n</code></pre>\n<ol start=\"2\">\n<li>输出函数或者类<code>class</code>。</li>\n</ol>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">exportMe</span> (<span class=\"hljs-params\"></span>) </span>{}\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">exportMeToo</span> </span>{}\n</code></pre>\n<ol start=\"3\">\n<li>关键字<code>as</code>重命名输出。</li>\n</ol>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">&#x27;GzhiYi&#x27;</span>;\n<span class=\"hljs-keyword\">const</span> job = <span class=\"hljs-string\">&#x27;Frontend&#x27;</span>;\n\n<span class=\"hljs-keyword\">export</span> {\n   name <span class=\"hljs-keyword\">as</span> changeName,\n   job <span class=\"hljs-keyword\">as</span> changeJob  \n};\n</code></pre>\n<h2 id=\"import\"><code>import</code></h2>\n<ol>\n<li>导入<code>export</code>输出的接口。</li>\n</ol>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-type\">name</span>, job } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;filePath&#x27;</span>;\n// <span class=\"hljs-keyword\">import</span> 进来的变量均是readOnly，也不建议改写引入的其它类型数据。\n</code></pre>\n<ol start=\"2\">\n<li>关键字<code>as</code>重命名输入。</li>\n</ol>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-type\">name</span> <span class=\"hljs-keyword\">as</span> changName } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;filePath&#x27;</span>;\n</code></pre>\n<h2 id=\"整体引入\">整体引入</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 假设demo.js文件有如下内容</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">funA</span> (<span class=\"hljs-params\"></span>) </span>{}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">funB</span> (<span class=\"hljs-params\"></span>) </span>{}\n\n<span class=\"hljs-keyword\">export</span> { funA, funB };\n\n<span class=\"hljs-comment\">// 平常加载</span>\n<span class=\"hljs-keyword\">import</span> { funA, funB } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./demo&#x27;</span>;\n\n<span class=\"hljs-comment\">// 整体引入</span>\n<span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> allFun <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./demo&#x27;</span>;\nallFun.funA();\nallFun.funB();\n</code></pre>\n<h2 id=\"export-defalut-指定默认输出\"><code>export defalut</code> 指定默认输出</h2>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// demo.js</span>\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{};\n\n<span class=\"hljs-comment\">// 引入</span>\n<span class=\"hljs-keyword\">import</span> funName <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;demo&#x27;</span>; \n<span class=\"hljs-comment\">// 不需要知道封装demo.js包含的函数名，import后无需接大括号，因为默认输出的只有一个。</span>\n</code></pre>\n"},{"title":"git在工作中的一些用处","slug":"2018_11_git-usage-in-work","description":"git内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。","keywords":"git,工作中,用处,git工作流,分支,git rebase,git merge","labels":["学习"],"date":"2018-11-28","path":"2018/11/git-usage-in-work.md","html":"<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.vrm.cn/2018/11/26/banner.png\" alt=\"banner\" ></p>\n<p>本周四分享会主题：__git在工作中的一些用处__。  </p>\n<p>git内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。<strong>基本的概念不会多说</strong>，都能在入门教程那些学习到。接下来会说下git在工作中比较常用的功能，会发现，其实git能做的事情还是非常多的。</p>\n<h3 id=\"git在开发中常用的命令\">git在开发中常用的命令</h3>\n<p><strong>编辑和代码提交</strong></p>\n<pre><code class=\"language-bash\"><span class=\"hljs-meta\"># 为git初始化一个代码库</span>\ngit init\n\n<span class=\"hljs-meta\"># 将目录的所有文件提交到暂存区</span>\ngit add .\n\n<span class=\"hljs-meta\"># 提交暂存区到代码仓库区，并添加提交信息</span>\ngit commit -m <span class=\"hljs-string\">&quot;commit message&quot;</span>\n</code></pre>\n<p><strong>分支处理</strong></p>\n<pre><code class=\"language-bash\">\n<span class=\"hljs-comment\"># 列出本地所有的分支</span>\ngit <span class=\"hljs-keyword\">branch\n</span>\n<span class=\"hljs-comment\"># 列出远程仓库的所有分支</span>\ngit <span class=\"hljs-keyword\">branch </span>-r\n\n<span class=\"hljs-comment\"># 列出仓库的所有分支（包含远端和本地分支）</span>\ngit <span class=\"hljs-keyword\">branch </span>-a\n\n<span class=\"hljs-comment\"># 切换到指定分支，并更新工作区</span>\ngit checkout [<span class=\"hljs-keyword\">branchName]\n</span>\n<span class=\"hljs-comment\"># 新建一个分支并切换到该分支</span>\ngit checkout -<span class=\"hljs-keyword\">b </span>[<span class=\"hljs-keyword\">branchName]\n</span>\n<span class=\"hljs-comment\"># 删除一个分支</span>\ngit <span class=\"hljs-keyword\">branch </span>-d [<span class=\"hljs-keyword\">branchName]\n</span>\n<span class=\"hljs-comment\"># 强制删除一个分支</span>\ngit <span class=\"hljs-keyword\">branch </span>-D [<span class=\"hljs-keyword\">branchName]</span>\n</code></pre>\n<p><strong>查看状态信息</strong></p>\n<pre><code class=\"language-bash\"><span class=\"hljs-meta\"># 查看变更的文件，可多用这个命令查看当前文件改动状态</span>\ngit status\n\n<span class=\"hljs-meta\"># 查看当前分支提交历史，可以得到加密的commit_id</span>\ngit log\n\n<span class=\"hljs-meta\"># 查看暂存区和工作区的对比</span>\ngit diff\n</code></pre>\n<p><strong>同步远程仓库</strong></p>\n<pre><code class=\"language-bash\"><span class=\"hljs-meta\"># 同步远程仓库的所有更新</span>\ngit fetch [remote]\n\n<span class=\"hljs-meta\"># 显示所有远程仓库</span>\ngit remote -v\n\n<span class=\"hljs-meta\"># 增加一个新的远程仓库，并定义一个远程仓库名，shortName常用origin，当然可自定义</span>\ngit remote add [shortName] url\n\n<span class=\"hljs-meta\"># 拉取远端分支，并与本地分支合并</span>\ngit pull [remote] [branchName]\n\n<span class=\"hljs-meta\"># 上传本地分支到远端</span>\ngit push [remote] [branchName]\n</code></pre>\n<p><strong>撤销操作</strong></p>\n<pre><code class=\"language-bash\"><span class=\"hljs-meta\"># 恢复暂存区的指定文件到工作区</span>\ngit checkout [file]\n\n<span class=\"hljs-meta\"># 恢复暂存区的所有文件到工作区</span>\ngit checkout .\n</code></pre>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/49006081-37a00f80-f1a3-11e8-982e-c02cd71c1495.png\" alt=\"image\" ></p>\n<p>git工作中常用命令基本可以上图概括。</p>\n<hr>\n<p><strong>其它常用的命令</strong>\n单独拿出来说是因为平常知道用的可能不会很多，但实际用起来会非常有用。</p>\n<ol>\n<li><code>git stash</code></li>\n</ol>\n<p>当你在工作的时候，累计了比较多的改动，但是突然间需要临时切换到其它分支工作，可是又不好把中途工作的内容提交，那怎么办？这时候git stash就有用了。</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-meta\"># 查看文件变更状态</span>\ngit status\n\n<span class=\"hljs-meta\"># 储藏变更，这时候会提示已储藏变更</span>\ngit stash\n\n<span class=\"hljs-meta\"># 当在其它分支工作完回到原来分支的时候，可以查看储藏列表</span>\ngit stash list\n\n<span class=\"hljs-meta\"># 恢复储藏，这时候文件变更就回来了，listNum为列表序号</span>\ngit stash apply stash@{listNum}\n</code></pre>\n<ol start=\"2\">\n<li><code>git rebase</code></li>\n</ol>\n<p>一般我们完成代码后，需要将分支的改动进行整合，会用到合并（merge）操作，但这不是唯一的方式，Rebase就是其中的代替方式。<br>先来说说merge。我们在需要合并的时候，会有如下的两种基本情况： </p>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.vrm.cn/2018/11/27/starting-situation-fast-forward.gif\" alt=\"情况1\" >\n其中一个分支没有新的改动，而另一个分支却有改动。这个时候进行整合的话，git仅仅只是添加所有改动的分支的新提交即可。</p>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.vrm.cn/2018/11/27/starting-situation-merge-commit.gif\" alt=\"情况2\" >\n第二种就是我们开发过程经常遇到的情况，两个分支都有不同的开发轨迹。为了完成合并，git会创建一个新的提交来涵括它们之间的差异，这就是整合提交。</p>\n<p>有人不喜欢这个合并的方式，希望项目有一个单一的开发轨迹，在流程上是一条直线，不希望在开发历史记录上看到被分成过多个分支。这时候就可以用到rebase操作了。</p>\n<p>我们还是看第一个例子：</p>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.vrm.cn/2018/11/27/starting-situation-fast-forward.gif\" alt=\"情况1\" >\n如果我们想合并分支B到A分支上，可以用到下面这个命令：</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-attribute\">git rebase branchB</span>\n</code></pre>\n<p>git会进行这样的操作：<br>“撤销”所有分支A上与分支B开发分叉后的更改，这并不是真的checkout掉更改，后面还会用到。\n<img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.vrm.cn/2018/11/27/rebase-step-1.gif\" alt=\"rebase1\" ></p>\n<p>然后它将整合分支B上的提交到A上，这要看，分支A和分支B就会像一条线一样。\n<img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.vrm.cn/2018/11/27/rebase-step-2.gif\" alt=\"rebase2\" ></p>\n<p>最后，在分支A上的那些新的提交会被重新应用回来。\n<img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.vrm.cn/2018/11/27/rebase-step-3.gif\" alt=\"rebase3\" ></p>\n<ol start=\"3\">\n<li><code>git reset</code>和<code>git revert</code></li>\n</ol>\n<p>开发期间难免会有提交出错代码的情况，如何进行版本回退呢？git reset命令就派上用场了.  </p>\n<ul>\n<li>git reset 为重置提交，可以将版本回退到某一个commit记录上。git reset 命令后面是需要加2种参数的：–-hard 和 –-soft。这条命令默认情况下是 -–soft。<br><strong>区别：</strong></li>\n</ul>\n<p>默认参数 -soft,所有commit的修改都会退回到git暂存区。\n参数--hard，所有commit的修改直接丢弃，小心用。</p>\n<pre><code class=\"language-bash\">git <span class=\"hljs-built_in\">reset</span> --hard commit_id\ngit <span class=\"hljs-built_in\">push</span> <span class=\"hljs-built_in\">origin</span> [branchName] --force\n</code></pre>\n<p>当然如果--hard错了，也还有救，<code>git reflog</code>命令记录你的所有git操作，能获取到原有的移除掉的commit_id。</p>\n<ul>\n<li>git revert 为还原提交，可以将某个commit还原然后创建一个新的还原commit。字面意思已经很好理解了。比如：</li>\n</ul>\n<pre><code class=\"language-bash\"><span class=\"hljs-comment\"># 某个commit的文件a增加两行文字</span>\n\n<span class=\"hljs-attribute\">git</span> revert commit_id\n\n<span class=\"hljs-comment\"># 执行该命令后，还原了这个commit文件a的更改，新增一个revert的commit，更改为增加的两行文字被移除。</span>\n</code></pre>\n<h3 id=\"git工作流\">git工作流</h3>\n<p>这里只说下最广泛应用的git工作流，也就是git flow。<br>在开发的初期，我们定两个分支：</p>\n<ul>\n<li><strong>主分支master</strong></li>\n<li><strong>开发分支develop</strong></li>\n</ul>\n<p>规定，master分支为版本发布的分支，提供上线的版本。develop分支为日常开发分支，存放最新的开发版本。一般的develop分支会切出如下的三个短期分支：</p>\n<ol>\n<li>功能分支（feature）</li>\n<li>修bug分支（hotfix或者fix）</li>\n<li>预发布分支（release）</li>\n</ol>\n<p><strong>还有其它工作流？</strong></p>\n<p>当然有！下面就继续说一个挺不错的工作流：  </p>\n<blockquote>\n<p>功能分支工作流  </p>\n</blockquote>\n<p>这个工作流的核心思路是所有的功能开发都应该独立一个分支，而主分支一样是master。这样的隔离开发不会扰乱主分支上的代码，也能保证主分支的代码准确无误。</p>\n<p>这种方式让pull request变得更加有效果。过多的就不解释，通过一个例子看看这个工作流到底是如何工作的。</p>\n<p><strong>小红开始开发一个新功能</strong><br>理所当然，从master切出一个独立功能分支：</p>\n<pre><code class=\"language-bash\">git checkout -b <span class=\"hljs-built_in\">feature</span>-<span class=\"hljs-built_in\">new</span> master\n</code></pre>\n<p>持续打码，中途完成部分:</p>\n<pre><code class=\"language-bash\">git status\ngit <span class=\"hljs-built_in\">add</span> [<span class=\"hljs-built_in\">file</span>]\ngit commit -m <span class=\"hljs-string\">&#x27;xxx&#x27;</span>\n</code></pre>\n<p><strong>中午去吃个饭</strong><br>在吃午饭前，小红把自己的功能分支推到了远端仓库。好习惯，多学习。</p>\n<pre><code class=\"language-bash\">git <span class=\"hljs-built_in\">push</span> <span class=\"hljs-built_in\">origin</span> <span class=\"hljs-built_in\">feature</span>-<span class=\"hljs-built_in\">new</span>\n</code></pre>\n<p><strong>小红完成开发</strong>\n在合并之前，小红保证远端仓库有自己功能分支的最新代码。</p>\n<pre><code class=\"language-bash\">git <span class=\"hljs-built_in\">push</span> <span class=\"hljs-built_in\">origin</span> <span class=\"hljs-built_in\">feature</span>-<span class=\"hljs-built_in\">new</span>\n</code></pre>\n<p>接下来，可以发起一个合并请求，在github或者gitlab都有快捷的合并请求操作。合并功能分支feature-new到master。发起后，团队都可以收到合并请求的通知。</p>\n<p>这时候团队可以code review，有问题就可以继续提示小红去修正。</p>\n<p>修正后小红可以持续推代码到功能分支，commit记录也会一并出现在pull request处。</p>\n<p><strong>小红发布功能</strong><br>经过紧张的讨论修改，终于完成功能开发，要发布功能：</p>\n<pre><code class=\"language-bash\">git checkout master\ngit pull\ngit pull <span class=\"hljs-built_in\">origin</span> <span class=\"hljs-built_in\">feature</span>-<span class=\"hljs-built_in\">new</span>\ngit <span class=\"hljs-built_in\">push</span>\n</code></pre>\n<p>完毕。</p>\n<h3 id=\"还能怎么发挥git作用？\">还能怎么发挥git作用？</h3>\n<p><strong>webhooks</strong></p>\n<p>根据github的介绍，webhooks可以通过使用github的事件被触发时通过http post的形式调用服务器上的接口，服务器接受到推送事件之后就可以执行构建，更新项目代码，进而部署生产服务器等等。</p>\n<blockquote>\n<p>这一切能限制的只有你的想象力。</p>\n</blockquote>\n<p>一般而言，比如说我部署一个node程序到服务器上需要怎么操作？</p>\n<ol>\n<li><p>本地代码开发完毕，准备上线，上传本地代码到git远端仓库。</p>\n</li>\n<li><p>ssh连接远程服务器，登录管理员账号密码后进入命令行界面。</p>\n</li>\n<li><p>进入项目目录，拉取最新提交的代码。</p>\n</li>\n<li><p>执行部署操作。</p>\n</li>\n<li><p>需要代码更新，重复此操作。</p>\n</li>\n</ol>\n<p><strong>而我通过webhooks之后，这些操作得到很大的简化。</strong></p>\n<ol>\n<li>配置webhooks的push事件，因为我要在本地push代码后执行后续操作。</li>\n</ol>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/49086433-78755280-f28f-11e8-98ee-a1279e427c8e.png\" alt=\"image\" ></p>\n<ol start=\"2\">\n<li>在服务器上编写一个自动部署脚本，这里举个简单的脚本<code>deploy.sh</code>。</li>\n</ol>\n<pre><code class=\"language-bash\"><span class=\"hljs-comment\">#！/bin/bash</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;enter project&#x27;</span>\n<span class=\"hljs-built_in\">cd</span> [your project dir]\n\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;pull code&#x27;</span>\ngit pull origin master\n\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;deploy&#x27;</span>\npm2 start deploy.js\npm2 logs deploy\n\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&#x27;deploy finished&#x27;</span>\n</code></pre>\n<ol start=\"3\">\n<li>用node写一个监听接口，不一定要node，只要能跑出个接口能监听到事件即可。需要提到：</li>\n</ol>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> createHandler = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;node-github-webhook&#x27;</span>)\n<span class=\"hljs-keyword\">const</span> config = {\n  <span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;/hook&#x27;</span>,\n  <span class=\"hljs-attr\">secret</span>: <span class=\"hljs-string\">&#x27;your srcret&#x27;</span>\n}\n<span class=\"hljs-keyword\">const</span> handler = createHandler(config)\n...\n\nhandler.on(<span class=\"hljs-string\">&#x27;push&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">event</span>) </span>{\n  execFunc(<span class=\"hljs-string\">&#x27;sh ./deploy.sh&#x27;</span>)\n})\n</code></pre>\n<p>这里的path和secret都需要在github webhooks那边对应配置上。</p>\n<ol start=\"4\">\n<li>完成之后，一旦代码提交到master的话，就会触发事件，然后自动执行后续操作。</li>\n</ol>\n<h3 id=\"git工具推荐\">git工具推荐</h3>\n<p>有几个个人认为不错的git工具或者项目可以提高git的使用。</p>\n<ol>\n<li><a target='_blank'  href=\"https://github.com/github/gitignore\">gitignore</a>。在项目根目录新建一个<code>.gitignore</code>文件，将不需要提交到git上的文件路径添加到这个文件。在这个项目中可以快速找到自己所属项目的通用gitignore文件</li>\n</ol>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.vrm.cn/2018/11/27/微信截图_20181127222540.png\" alt=\"gitignore\" ></p>\n<ol start=\"2\">\n<li>[<code>VS Code</code>] gitignore。可以右键将文件夹或者文件添加到.gitignore文件中。</li>\n</ol>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.vrm.cn/2018/11/27/微信截图_20181127222733.png\" alt=\"gitignore\" ></p>\n<ol start=\"3\">\n<li>[<code>VS Code</code>] GitLens。可以让每一行代码都显示历史记录等。</li>\n</ol>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.vrm.cn/2018/11/27/微信截图_20181127223043.png\" alt=\"Gitlens\" ></p>\n<ol start=\"4\">\n<li>[<code>Chrome</code>] octotree。浏览github上的代码更加轻松便捷。</li>\n</ol>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.vrm.cn/2018/11/27/微信截图_20181127223252.png\" alt=\"octotree\" ></p>\n<ol start=\"5\">\n<li>Sourcetree。git图形界面工具，讲了那么多命令应该可以不用图形界面了吧😀。\n<img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.vrm.cn/2018/11/28/微信截图_20181128215137.png\" alt=\"sourcetree\" ></li>\n</ol>\n<h3 id=\"最后\">最后</h3>\n<p>分享内容大概如此了，欢迎补充，也希望内容有些帮助。😄</p>\n<blockquote>\n<p>参考\n<a target='_blank'  href=\"https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/rebase\">Rebase 代替合并 </a>\n<a target='_blank'  href=\"http://www.ruanyifeng.com/blog/2015/12/git-workflow.html\">git 工作流-阮老师的</a>\n<a target='_blank'  href=\"https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md\">git 工作流</a></p>\n</blockquote>\n"},{"title":"七牛回收测试域名后，下载图片","slug":"2018_11_qiniu-download-pic","description":"月中就收到了七牛测试域名被回收的邮件。没多瞥几眼，直接拖到了过期时间，错过了下载图片的时间。","keywords":"七牛,qiniu,下载,图片,域名回收,windows","labels":["前端"],"date":"2018-11-22","path":"2018/11/qiniu-download-pic.md","html":"<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/48887594-d3134680-ee6a-11e8-9721-b46722c63f88.png\" alt=\"_20181122152425\" ></p>\n<h2 id=\"测试域名回收\">测试域名回收</h2>\n<p>月中就收到了七牛测试域名被回收的邮件。没多瞥几眼，直接拖到了过期时间，错过了下载图片的时间。</p>\n<p>现在考虑不用hexo那个github pages了，转移到github issue区进行记录。博客嘛，不搞花里胡巧了，issue几乎满足所有要求。对于图片挂了这回事，还是要处理的，所以找了下补救措施，也在这记录下。</p>\n<h2 id=\"主要步骤（系统环境windows）\">主要步骤（系统环境Windows）</h2>\n<ol>\n<li>在对象存储处，新建一个新的存储空间，假设名为<code>backup</code>，过期的空间名为<code>images</code>。注意存储区域选择和原有过期空间一致。</li>\n<li>下载<a target='_blank'  href=\"https://github.com/qiniu/qshell\">qshell</a>。下载解压后应该包含以下几端的qshell文件（以下载回来的文件为主）。\n<img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/48888437-aa408080-ee6d-11e8-8a4b-ab02b58a6f7d.png\" alt=\"image\" ></li>\n<li>根据对于系统选择对应的qshell文件。注意windows不要双击打开，应该在该目录处打开shell脚本，输入文件名代替qshell命令。</li>\n</ol>\n<p>查看qshell版本检查qshell是否可用：\n<img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/48888591-2f2b9a00-ee6e-11e8-8732-14a97de2baac.png\" alt=\"image\" ></p>\n<ol start=\"4\">\n<li><p>按以下命令格式配置七牛账号信息，注意命令包含AK（access_key）、SK（secret_key）以及账户名（注册邮箱）。</p>\n<pre><code class=\"language-bash\">qshell_windows_x64.exe account AK SK <span class=\"hljs-keyword\">NAME</span>\n</code></pre>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/48888794-c133a280-ee6e-11e8-9edb-db6b3db9188c.png\" alt=\"image\" >\n<a target='_blank'  href=\"https://github.com/qiniu/qshell/blob/master/docs/account.md\">命令account参考</a></p>\n</li>\n<li><p>导出图片信息列表到txt文件。</p>\n<pre><code class=\"language-bash\">qshell_wi<span class=\"hljs-symbol\">ndows_x64</span>.exe -v  listbucket images -o tocopy.txt\n</code></pre>\n<p><a target='_blank'  href=\"https://github.com/qiniu/qshell/blob/master/docs/listbucket.md\">命令listbucket参考</a>\n完成后，tocopy.txt就包含了原有过期空间images的所有文件信息。</p>\n</li>\n<li><p>只保留tocopy.txt每行内的文件名，其余的去掉。</p>\n</li>\n<li><p>使用batchcopy命令迁移。</p>\n<pre><code class=\"language-bash\">qshell_windows_x64.exe -v  <span class=\"hljs-keyword\">batchcopy </span>images <span class=\"hljs-keyword\">backup </span>-i tocopy.txt\n</code></pre>\n<p><a target='_blank'  href=\"https://github.com/qiniu/qshell/blob/master/docs/batchcopy.md\">命令batchcopy参考</a>\n自此，空间文件迁移成功，可以到新空间查看图片或者下载图片了。</p>\n</li>\n</ol>\n"},{"title":"用小程序做个动态倒计时","slug":"2018_10_mp-countdown","description":"最近由于业务需要，需要做一个倒计时的小插件，想想自己在很久以前用JavaScript写过，操作dom，很快就可以修改对应的数字了。现在换到小程序后，主要的还是去更改data的值，进而修改对应的图片。","keywords":"小程序,倒计时,编写","labels":["小程序"],"date":"2018-10-15","path":"2018/10/mp-countdown.md","html":"<h3 id=\"写在前\">写在前</h3>\n<p>最近由于业务需要，需要做一个倒计时的小插件，想想自己在很久以前用JavaScript写过，操作dom，很快就可以修改对应的数字了。现在换到小程序后，主要的还是去更改data的值，进而修改对应的图片。  </p>\n<!--more-->\n\n<h3 id=\"效果\">效果</h3>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.vrm.cn/2018/11/22/微信截图_20181122151328.png\" alt=\"counter\" >\n具体：  </p>\n<ul>\n<li>精度为天时分秒</li>\n<li>初始时间可以从接口获取</li>\n</ul>\n<h3 id=\"代码\">代码</h3>\n<pre><code class=\"language-html\"><span class=\"xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">view</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;counter&quot;</span>&gt;</span>\n    距离活动结束仅剩\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">image</span> <span class=\"hljs-attr\">bindload</span>=<span class=\"hljs-string\">&quot;showPicture&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;clock&quot;</span> <span class=\"hljs-attr\">mode</span>=<span class=\"hljs-string\">&quot;widthFix&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../../src/images/clock/num</span></span></span><span class=\"hljs-template-variable\">{{<span class=\"hljs-name\">count.dayBegin</span>}}</span><span class=\"xml\"><span class=\"hljs-tag\"><span class=\"hljs-string\">.png&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">image</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">image</span> <span class=\"hljs-attr\">bindload</span>=<span class=\"hljs-string\">&quot;showPicture&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;clock&quot;</span> <span class=\"hljs-attr\">mode</span>=<span class=\"hljs-string\">&quot;widthFix&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../../src/images/clock/num</span></span></span><span class=\"hljs-template-variable\">{{<span class=\"hljs-name\">count.dayEnd</span>}}</span><span class=\"xml\"><span class=\"hljs-tag\"><span class=\"hljs-string\">.png&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">image</span>&gt;</span>\n    天\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">image</span> <span class=\"hljs-attr\">bindload</span>=<span class=\"hljs-string\">&quot;showPicture&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;clock&quot;</span> <span class=\"hljs-attr\">mode</span>=<span class=\"hljs-string\">&quot;widthFix&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../../src/images/clock/num</span></span></span><span class=\"hljs-template-variable\">{{<span class=\"hljs-name\">count.hourBegin</span>}}</span><span class=\"xml\"><span class=\"hljs-tag\"><span class=\"hljs-string\">.png&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">image</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">image</span> <span class=\"hljs-attr\">bindload</span>=<span class=\"hljs-string\">&quot;showPicture&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;clock&quot;</span> <span class=\"hljs-attr\">mode</span>=<span class=\"hljs-string\">&quot;widthFix&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../../src/images/clock/num</span></span></span><span class=\"hljs-template-variable\">{{<span class=\"hljs-name\">count.hourEnd</span>}}</span><span class=\"xml\"><span class=\"hljs-tag\"><span class=\"hljs-string\">.png&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">image</span>&gt;</span>\n    时\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">image</span> <span class=\"hljs-attr\">bindload</span>=<span class=\"hljs-string\">&quot;showPicture&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;clock&quot;</span> <span class=\"hljs-attr\">mode</span>=<span class=\"hljs-string\">&quot;widthFix&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../../src/images/clock/num</span></span></span><span class=\"hljs-template-variable\">{{<span class=\"hljs-name\">count.minuteBegin</span>}}</span><span class=\"xml\"><span class=\"hljs-tag\"><span class=\"hljs-string\">.png&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">image</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">image</span> <span class=\"hljs-attr\">bindload</span>=<span class=\"hljs-string\">&quot;showPicture&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;clock&quot;</span> <span class=\"hljs-attr\">mode</span>=<span class=\"hljs-string\">&quot;widthFix&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../../src/images/clock/num</span></span></span><span class=\"hljs-template-variable\">{{<span class=\"hljs-name\">count.minuteEnd</span>}}</span><span class=\"xml\"><span class=\"hljs-tag\"><span class=\"hljs-string\">.png&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">image</span>&gt;</span>\n    分\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">image</span> <span class=\"hljs-attr\">bindload</span>=<span class=\"hljs-string\">&quot;showPicture&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;clock&quot;</span> <span class=\"hljs-attr\">mode</span>=<span class=\"hljs-string\">&quot;widthFix&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../../src/images/clock/num</span></span></span><span class=\"hljs-template-variable\">{{<span class=\"hljs-name\">count.secondBegin</span>}}</span><span class=\"xml\"><span class=\"hljs-tag\"><span class=\"hljs-string\">.png&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">image</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">image</span> <span class=\"hljs-attr\">bindload</span>=<span class=\"hljs-string\">&quot;showPicture&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;clock&quot;</span> <span class=\"hljs-attr\">mode</span>=<span class=\"hljs-string\">&quot;widthFix&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;../../src/images/clock/num</span></span></span><span class=\"hljs-template-variable\">{{<span class=\"hljs-name\">count.secondEnd</span>}}</span><span class=\"xml\"><span class=\"hljs-tag\"><span class=\"hljs-string\">.png&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">image</span>&gt;</span>\n    秒\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">view</span>&gt;</span></span>\n</code></pre>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 初始值</span>\n<span class=\"hljs-attr\">timer</span>: <span class=\"hljs-literal\">null</span>,\n<span class=\"hljs-attr\">data</span>: {\n  <span class=\"hljs-attr\">count</span>: {\n    <span class=\"hljs-attr\">expireDate</span>: <span class=\"hljs-number\">172800</span>, <span class=\"hljs-comment\">// s</span>\n    <span class=\"hljs-attr\">dayBegin</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">dayEnd</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">hourBegin</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">hourEnd</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">minuteBegin</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">minuteEnd</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">secondBegin</span>: <span class=\"hljs-number\">0</span>,\n    <span class=\"hljs-attr\">secondEnd</span>: <span class=\"hljs-number\">0</span>\n  }\n}\n\n<span class=\"hljs-comment\">// 接口回调处</span>\n<span class=\"hljs-keyword\">let</span> { count } = <span class=\"hljs-built_in\">this</span>.data\ndelele count[<span class=\"hljs-string\">`expireDate`</span>] <span class=\"hljs-comment\">// 删除原count中的expireDate</span>\n<span class=\"hljs-built_in\">this</span>.setData({\n  ...count,\n  <span class=\"hljs-attr\">expireDate</span>: newExpireDate\n})\n<span class=\"hljs-built_in\">this</span>.timer = <span class=\"hljs-built_in\">setInterval</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> expireDate = <span class=\"hljs-built_in\">this</span>.data.count.expireDate - <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-built_in\">this</span>.setData({\n    <span class=\"hljs-attr\">count</span>: {\n      <span class=\"hljs-attr\">dayBegin</span>: <span class=\"hljs-built_in\">this</span>.convertTime(expireDate)[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>],\n      <span class=\"hljs-attr\">dayEnd</span>: <span class=\"hljs-built_in\">this</span>.convertTime(expireDate)[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">1</span>],\n      <span class=\"hljs-attr\">hourBegin</span>: <span class=\"hljs-built_in\">this</span>.convertTime(expireDate)[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">0</span>],\n      <span class=\"hljs-attr\">hourEnd</span>: <span class=\"hljs-built_in\">this</span>.convertTime(expireDate)[<span class=\"hljs-number\">1</span>][<span class=\"hljs-number\">1</span>],\n      <span class=\"hljs-attr\">minuteBegin</span>: <span class=\"hljs-built_in\">this</span>.convertTime(expireDate)[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">0</span>],\n      <span class=\"hljs-attr\">minuteEnd</span>: <span class=\"hljs-built_in\">this</span>.convertTime(expireDate)[<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">1</span>],\n      <span class=\"hljs-attr\">secondBegin</span>: <span class=\"hljs-built_in\">this</span>.convertTime(expireDate)[<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">0</span>],\n      <span class=\"hljs-attr\">secondEnd</span>: <span class=\"hljs-built_in\">this</span>.convertTime(expireDate)[<span class=\"hljs-number\">3</span>][<span class=\"hljs-number\">1</span>],\n      expireDate,\n    }\n  })\n}, <span class=\"hljs-number\">1000</span>)\n\n<span class=\"hljs-comment\">/**\n * 时间转化函数，时间戳入参为秒\n*/</span>\n<span class=\"hljs-attr\">convertTime</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">sec</span>) </span>{\n  <span class=\"hljs-keyword\">let</span> time\n  <span class=\"hljs-keyword\">if</span> (sec &gt; -<span class=\"hljs-number\">1</span>) {\n    <span class=\"hljs-keyword\">let</span> hour = <span class=\"hljs-built_in\">Math</span>.floor(sec / <span class=\"hljs-number\">3600</span>)\n    <span class=\"hljs-keyword\">let</span> min = <span class=\"hljs-built_in\">Math</span>.floor(sec / <span class=\"hljs-number\">60</span>) % <span class=\"hljs-number\">60</span>\n    <span class=\"hljs-keyword\">let</span> second = sec % <span class=\"hljs-number\">60</span>\n    <span class=\"hljs-keyword\">let</span> day = <span class=\"hljs-built_in\">parseInt</span>(hour / <span class=\"hljs-number\">24</span>)\n    hour = hour - <span class=\"hljs-number\">24</span> * day\n    hour = hour &lt; <span class=\"hljs-number\">10</span> ? <span class=\"hljs-string\">`0<span class=\"hljs-subst\">${hour}</span>`</span> : hour\n    time = day &lt; <span class=\"hljs-number\">10</span> ? <span class=\"hljs-string\">`0<span class=\"hljs-subst\">${day}</span>:<span class=\"hljs-subst\">${hour}</span>:`</span>: <span class=\"hljs-string\">`<span class=\"hljs-subst\">${day}</span>:<span class=\"hljs-subst\">${hour}</span>:`</span>\n    <span class=\"hljs-keyword\">if</span> (min &lt; <span class=\"hljs-number\">10</span>) {\n      time += <span class=\"hljs-string\">&quot;0&quot;</span>\n    }\n    time += min + <span class=\"hljs-string\">&quot;:&quot;</span>;\n    <span class=\"hljs-keyword\">if</span> (second &lt; <span class=\"hljs-number\">10</span>) {\n      time += <span class=\"hljs-string\">&quot;0&quot;</span>\n    }\n    time += second\n    <span class=\"hljs-keyword\">return</span> time.split(<span class=\"hljs-string\">&#x27;:&#x27;</span>) <span class=\"hljs-comment\">// 返回一个包含天时分秒的数组</span>\n  }\n}\n<span class=\"hljs-comment\">// 最后不要忘记在周期销毁处清空计时器</span>\n<span class=\"hljs-attr\">onUnload</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-built_in\">clearInterval</span>(<span class=\"hljs-built_in\">this</span>.timer)\n}\n</code></pre>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">// 时间转 **前的函数</span>\n  getDateDiff: <span class=\"hljs-keyword\">function</span>(dateTimeStamp){\n    <span class=\"hljs-keyword\">let</span> result = &#x27;&#x27;\n    <span class=\"hljs-keyword\">let</span> minute = <span class=\"hljs-number\">1000</span><span class=\"hljs-operator\"> * </span><span class=\"hljs-number\">60</span>\n    <span class=\"hljs-keyword\">let</span> hour = minute<span class=\"hljs-operator\"> * </span><span class=\"hljs-number\">60</span>\n    <span class=\"hljs-keyword\">let</span> day = hour<span class=\"hljs-operator\"> * </span><span class=\"hljs-number\">24</span>\n    <span class=\"hljs-keyword\">let</span> halfamonth = day<span class=\"hljs-operator\"> * </span><span class=\"hljs-number\">15</span>\n    <span class=\"hljs-keyword\">let</span> month = day<span class=\"hljs-operator\"> * </span><span class=\"hljs-number\">30</span>\n    <span class=\"hljs-keyword\">let</span> now = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Date()</span>.get<span class=\"hljs-constructor\">Time()</span>\n    <span class=\"hljs-keyword\">let</span> diffValue = now - dateTimeStamp\n    <span class=\"hljs-keyword\">if</span>(diffValue &lt; <span class=\"hljs-number\">0</span>) { return; }\n    <span class=\"hljs-keyword\">let</span> monthC = diffValue<span class=\"hljs-operator\"> / </span>month\n      <span class=\"hljs-keyword\">let</span> weekC = diffValue<span class=\"hljs-operator\"> / </span>(<span class=\"hljs-number\">7</span><span class=\"hljs-operator\"> * </span>day)\n      <span class=\"hljs-keyword\">let</span> dayC = diffValue<span class=\"hljs-operator\"> / </span>day\n      <span class=\"hljs-keyword\">let</span> hourC = diffValue<span class=\"hljs-operator\"> / </span>hour\n      <span class=\"hljs-keyword\">let</span> minC = diffValue<span class=\"hljs-operator\"> / </span>minute\n      <span class=\"hljs-keyword\">if</span>(monthC&gt;= <span class=\"hljs-number\">1</span>){\n    result = <span class=\"hljs-string\">&quot;&quot;</span> + parse<span class=\"hljs-constructor\">Int(<span class=\"hljs-params\">monthC</span>)</span> + <span class=\"hljs-string\">&quot;月前&quot;</span>\n    }\n      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (weekC &gt;= <span class=\"hljs-number\">1</span>) {\n      result = <span class=\"hljs-string\">&quot;&quot;</span> + parse<span class=\"hljs-constructor\">Int(<span class=\"hljs-params\">weekC</span>)</span> + <span class=\"hljs-string\">&quot;周前&quot;</span>\n    }\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (dayC &gt;= <span class=\"hljs-number\">1</span>) {\n      result = <span class=\"hljs-string\">&quot;&quot;</span> + parse<span class=\"hljs-constructor\">Int(<span class=\"hljs-params\">dayC</span>)</span> + <span class=\"hljs-string\">&quot;天前&quot;</span>\n    }\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (hourC &gt;= <span class=\"hljs-number\">1</span>) {\n      result = <span class=\"hljs-string\">&quot;&quot;</span> + parse<span class=\"hljs-constructor\">Int(<span class=\"hljs-params\">hourC</span>)</span> + <span class=\"hljs-string\">&quot;小时前&quot;</span>\n    }\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (minC &gt;= <span class=\"hljs-number\">1</span>) {\n      result = <span class=\"hljs-string\">&quot;&quot;</span> + parse<span class=\"hljs-constructor\">Int(<span class=\"hljs-params\">minC</span>)</span> + <span class=\"hljs-string\">&quot;分钟前&quot;</span>\n    } <span class=\"hljs-keyword\">else</span>\n      result = <span class=\"hljs-string\">&quot;刚刚&quot;</span>\n    return result\n  },\n</code></pre>\n<h3 id=\"最后\">最后</h3>\n<p>相关思路适用于所有mvvm框架。</p>\n"},{"title":"不知不觉一个月了","slug":"2018_10_month-pass","description":"很忙。最近在业务上花的时间很多，公司内有一批业务陆陆续续到来，只好花了时间去做好来。也就大半个月的时间吧，有了很多的事情，我也没有常来这里看看，所以就遗忘了。心想也是，在Google、Baidu都很难搜索到我的帖子所以不管了吧。当作自己的一个小地方得了。","keywords":"不知不觉一个月了","labels":["随笔"],"date":"2018-10-15","path":"2018/10/month-pass.md","html":"<h3 id=\"上一篇发布于2018-08-20\">上一篇发布于2018-08-20</h3>\n<p>很忙。最近在业务上花的时间很多，公司内有一批业务陆陆续续到来，只好花了时间去做好来。也就大半个月的时间吧，有了很多的事情，我也没有常来这里看看，所以就遗忘了。\n心想也是，在Google、Baidu都很难搜索到我的帖子所以不管了吧。当作自己的一个小地方得了。</p>\n<h3 id=\"技术栈\">技术栈</h3>\n<p>说一下最近在前端的实践：Jquery Vue 小程序之间来回切换，自身所负责的前端项目大概有3~4个，逐渐的对这样的开发情况熟悉起来了。最近小程序开放了云开发后台，非常\n感兴趣，在打开vscode去实践的时候，猛然发现博客没写好久了，所以就上来写两句。待会就去实践云开发啦。<br><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.vrm.cn/2018/11/22/微信截图_20180913213730.png\" alt=\"微信截图_20180913213730\" ></p>\n<h3 id=\"infinite\">Infinite</h3>\n<p>未来会更好，专注前端开发。多接触好的技术，创造无限。\n<img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.vrm.cn/2018/11/22/微信图片_20180913213837.jpg\" alt=\"微信图片_20180913213837\" ></p>\n"},{"title":"一次h5开发踩坑记录","slug":"2018_10_h5-step","description":"这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。","keywords":"h5,踩坑,vue,vux","labels":["前端"],"date":"2018-10-15","path":"2018/10/h5-step.md","html":"<h3 id=\"时间\">时间</h3>\n<p>这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。</p>\n<h3 id=\"使用框架\">使用框架</h3>\n<p>原本想直接了当用jQuery，毕竟用jQuery开发是真的快而且紧急情况可控。缺点是写起来会比较乱，维护也比较麻烦。但最后还是放弃，想尝试新的技术。最后试用了几套框架|库后，决定使用vux进行编写。</p>\n<!--more-->\n<h3 id=\"vux\">Vux</h3>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/48887191-5af85100-ee69-11e8-84e9-fc534223e75b.png\" alt=\"tim 20181015093748\" ></p>\n<p>使用原因：  </p>\n<ol>\n<li>使用vue-cli构建，几乎不用配置其余东西，内建命令让开发和打包生产版十分便捷。</li>\n<li>vux有大量组件而且github上有非常多的issue记录，遇到问题可以快速定位解决。</li>\n<li>vue生态给力，写起来舒舒服服。</li>\n</ol>\n<h3 id=\"主要坑\">主要坑</h3>\n<p>由于第一次用vux写h5，难免会遇到不少问题，不仅是框架本身的问题，还有其他业务上需要攻克的问题。就记录下踩过的坑：</p>\n<ul>\n<li>background-image在部署的时候路径不对。</li>\n</ul>\n<p>修改vue-cli的build文件夹下的utils.js为如下：\n<img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/48887225-7b281000-ee69-11e8-85a0-6e465667d9c4.png\" alt=\"util\" ></p>\n<p>这样在 CSS 中：background-image: url(&quot;./assets/bg.jpg&quot;)，不管是在开发环境下还是在生产环境下，背景图都可以读出来</p>\n<ul>\n<li>怎么生成图片并在微信端支持长按保存图片？  </li>\n</ul>\n<p>以前也做过类似的，但没做过微信支持长按保存图片的。首先当然是要用到将html转为canvas然后再考虑转为图片。</p>\n<ol>\n<li>库：<a target='_blank'  href=\"https://html2canvas.hertzen.com/documentation\">html2canvas</a></li>\n<li>用法非常简单，指定挂载的元素进行转化。</li>\n</ol>\n<pre><code class=\"language-javascript\">html2canvas(<span class=\"hljs-built_in\">document</span>.body).then(<span class=\"hljs-function\">(<span class=\"hljs-params\">canvas</span>) =&gt;</span> {\n    <span class=\"hljs-built_in\">console</span>.log(canvas);    <span class=\"hljs-comment\">// 这个是生成的canvas</span>\n    <span class=\"hljs-keyword\">const</span> base64Code = canvas.toDataURL(<span class=\"hljs-string\">&quot;image/png&quot;</span>);    <span class=\"hljs-comment\">//将生成的canvas通过api`toDataURL`转为base64格式图片。</span>\n});\n</code></pre>\n<ul>\n<li>怎么保存图片？</li>\n</ul>\n<p>不是已经生成图片了吗？生成就可以可以保存了。没错，但是业务问题，在生成的图片上还要包含可点击的按钮和一个超链接。可以想到，可以将按钮和超链接定位到生成的图片上。可是存在这样的问题，不同的移动端呈现的结果可能不一致，这会直接导致页面显示出现问题，进而影响使用体验。这种覆盖的想法最后放弃了。</p>\n<p>最后的做法：将生成的图片的透明度设置为0覆盖到原本要渲染的元素上，然后提高可点击按钮的层级。\n<img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/48887259-95fa8480-ee69-11e8-8564-ddbccc8f1e26.png\" alt=\"tim 20181015100607\" ></p>\n<ul>\n<li>存在无法分享到朋友圈的问题</li>\n</ul>\n<p>微信浏览器唤起的分享菜单，存在点击分享到朋友圈出现卡死问题。\n排查过程： 在页面操作第一步和第二步都不会有这个问题，在生成图片的第三步就出现无法分享的问题。在想是不是生成图片太大了导致太卡顿了？在开发调试过程，打开vue开发工具查看第三步data的时候，发现非常卡顿。这样就可以认定是图片造成的卡顿了。</p>\n<p>最后找到的原因：canvas生成的base64编码的图片码十分长，直接导致vue处理的时候出现卡顿严重进而影响页面分享效果。最后的解决方案：将base64转为file上传，最后展示返回的url图片。</p>\n<pre><code class=\"language-javascript\">  <span class=\"hljs-keyword\">const</span> base64Code = canvas.toDataURL(<span class=\"hljs-string\">&quot;image/png&quot;</span>)\n  <span class=\"hljs-comment\">// 去掉url的头，并转换为byte。以下步骤生成JavaScript blob文件</span>\n  <span class=\"hljs-keyword\">const</span> bytes = <span class=\"hljs-built_in\">window</span>.atob(base64Code.split(<span class=\"hljs-string\">&#x27;,&#x27;</span>)[<span class=\"hljs-number\">1</span>])\n  <span class=\"hljs-keyword\">const</span> ab = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ArrayBuffer</span>(bytes.length)\n  <span class=\"hljs-keyword\">const</span> ia = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Uint8Array</span>(ab)\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; bytes.length; i++) {\n    ia[i] = bytes.charCodeAt(i)\n  }\n  <span class=\"hljs-keyword\">let</span> files = self.blobToFile(<span class=\"hljs-keyword\">new</span> Blob([ab], { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;png&#x27;</span> }), <span class=\"hljs-string\">&#x27;post&#x27;</span>)\n  <span class=\"hljs-keyword\">let</span> formData = <span class=\"hljs-keyword\">new</span> FormData()\n  formData.append(<span class=\"hljs-string\">&quot;file&quot;</span>, files, <span class=\"hljs-string\">`myPost-<span class=\"hljs-subst\">${<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>().getTime()}</span>.png`</span>);\n  self.$http.post(config.fileUploadURL, formData, {\n    <span class=\"hljs-attr\">headers</span>: {\n      <span class=\"hljs-string\">&#x27;Content-Type&#x27;</span>: <span class=\"hljs-string\">&#x27;multipart/form-data&#x27;</span>\n    }\n  }).then (<span class=\"hljs-function\"><span class=\"hljs-params\">uploadRes</span> =&gt;</span> {\n    <span class=\"hljs-keyword\">if</span> (uploadRes.data.code === <span class=\"hljs-number\">200</span>) {\n      self.imageBase = uploadRes.data.url\n    }\n  })\n</code></pre>\n<pre><code class=\"language-javascript\">  <span class=\"hljs-comment\">// blob图片转为文件的函数</span>\n  blobToFile (theBlob, fileName){\n    theBlob.lastModifiedDate = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>();\n    theBlob.name = fileName;\n    <span class=\"hljs-keyword\">return</span> theBlob;\n  }\n</code></pre>\n<h3 id=\"成品\">成品</h3>\n<p>虽然国庆过了，但是还是贴出来哈哈。\n<a target='_blank'  href=\"http://xiaolu.ybj.com/wechat/html/gqyx/index.html\">活动</a></p>\n"},{"title":"防盗链的解析","slug":"2018_10_anti-theft","description":"最近涉及到了图片防盗链的问题，链接是特殊的，不能被其他网站解析为图片。说下来有几种办法，当然解决后发现还是最后那种简单便捷。唯一的缺点就是大概也许差不多可能无法访问到。这个没关系，只要保佑保佑，总会比加iframe轻松愉悦的。","keywords":"防盗链","labels":["前端"],"date":"2018-10-15","path":"2018/10/anti-theft.md","html":"<h3 id=\"前言\">前言</h3>\n<p>最近涉及到了图片防盗链的问题，链接是特殊的，不能被其他网站解析为图片。说下来有几种办法，当然解决后发现还是最后那种简单便捷。唯一的缺点就是大概也许差不多可能无法访问到。这个没关系，只要保佑保佑，总会比加iframe轻松愉悦的。  </p>\n<p>首先，你看到的图片会是这样的：</p>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://mmbiz.qpic.cn/mmbiz_jpg/cfehZicXpD0ib9BP0iafksSmxPcWm4ORDGkD5ibHIHeWSyWjHriaFGhHLFvZNwiau4icCOBvT56MktVFATAf1D8vuyOHw/0?wx_fmt=jpeg\" alt=\"例图\" >  </p>\n<p>实际上，如果你能看到上面这张图，说明你骨骼精奇，自带解锁功能。\n但是我们想直接看到：  </p>\n<p><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://images.weserv.nl/?url=//mmbiz.qpic.cn/mmbiz_jpg/cfehZicXpD0ib9BP0iafksSmxPcWm4ORDGkD5ibHIHeWSyWjHriaFGhHLFvZNwiau4icCOBvT56MktVFATAf1D8vuyOHw/0?wx_fmt=jpeg\" alt=\"例图\" >  </p>\n<p>那怎么做呢？</p>\n<h3 id=\"页面头部加入标签\">页面头部加入<mate>标签</h3>\n<pre><code class=\"language-html\">&lt;meta <span class=\"hljs-attribute\">name</span>=<span class=\"hljs-string\">&quot;referrer&quot;</span> <span class=\"hljs-attribute\">content</span>=<span class=\"hljs-string\">&quot;never&quot;</span>&gt;\n</code></pre>\n<p>这种办法通过控制referer绕过防盗链的检测。html可以通过这个参数决定http请求中的referer，要注意使用这个标签属性的时候，浏览器原有的referer策略就发生改变了。</p>\n<h3 id=\"图片在iframe内显示\">图片在iframe内显示</h3>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-built_in\">url</span>=<span class=\"hljs-string\">&#x27;防盗的链接&#x27;</span>;\n<span class=\"hljs-keyword\">let</span> finalUrl = displayImg(<span class=\"hljs-built_in\">url</span>);\n<span class=\"hljs-built_in\">console</span>.log(finalUrl);\n<span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;img&#x27;</span>).innerHTML = finalUrl;\n\ndisplayImg = (<span class=\"hljs-built_in\">url</span>) =&gt; {\n    <span class=\"hljs-keyword\">let</span> iFrameid = <span class=\"hljs-string\">&#x27;frameimg&#x27;</span> + <span class=\"hljs-built_in\">Math</span>.random();\n    <span class=\"hljs-built_in\">window</span>.img = <span class=\"hljs-string\">&#x27;&lt;img id=&quot;img&quot; src=\\&#x27;&#x27;</span> + <span class=\"hljs-built_in\">url</span> + <span class=\"hljs-string\">&#x27;?&#x27;</span> + <span class=\"hljs-built_in\">Math</span>.random() + <span class=\"hljs-string\">&#x27;\\&#x27; /&gt;&#x27;</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&#x27;&lt;iframe id=&quot;&#x27;</span> + iFrameid + <span class=\"hljs-string\">&#x27;&quot; src=&quot;javascript:parent.img;&quot; frameBorder=&quot;0&quot; scrolling=&quot;no&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&#x27;</span>;\n}\n</code></pre>\n<p>这样可以正常显示图片，除了多了iframe外也没啥太大的问题，但是我发现在Vue里面一旦数据更新iframe就会刷新，外加上插件vue-draggable没法用了所以我就放弃这个方法了。这也促使我找更好的方案👇。</p>\n<h3 id=\"传送门--跳板\">传送门 | 跳板</h3>\n<p>所以最后我还是找到了一个好的方法，搜索引擎下，发现大部分的跳板都被清理了。不要慌，总会有的，对于怎么找到这个跳板的话，我的建议是怎么不去对比一下开头的两张图？😄😄😄</p>\n"},{"title":"微信小程序踩坑","slug":"2018_05_mp-back","description":"大概写了大半年的React，回想起来还真是挺长的。一直都想找机会了解更多的项目内容，小程序就是一直想去了解的。不过，就算是更换了工作内容，我还是很喜欢开源技术的。对于React的关注也一直没有停止，打心底的喜欢React这一个充满活力的库。","keywords":"微信小程序","labels":["小程序"],"date":"2018-05-16","path":"2018/05/mp-back.md","html":"<h2 id=\"react-----微信小程序开发\">React -- &gt; 微信小程序开发</h2>\n<h3 id=\"因工作需要，这一段时间将进行小程序的开发工作\">因工作需要，这一段时间将进行小程序的开发工作</h3>\n<p>大概写了大半年的React，回想起来还真是挺长的。一直都想找机会了解更多的项目内容，小程序就是一直想去了解的。不过，就算是更换了工作内容，我还是很喜欢开源技术的。对于React的关注也一直没有停止，打心底的喜欢React这一个充满活力的库。<br>除了小程序外，Vue的开发有空会去了解并去写一些简单的Demo。额，这一篇内容还是记录一下小程序的踩坑过程。</p>\n<!--more-->\n\n<h3 id=\"小程序基本概况\">小程序基本概况</h3>\n<p>小程序的理念就是用完就走，不用多停留。从小程序面世到现在也过了几年了吧，在我注册一个个人开发者账号到写下第一行代码这个过程，比我想象中还是顺利的多。这得益于还是挺清晰的官方文档，里面也包含了一些基本的Demo。<br>槽点：<a target='_blank'  href=\"https://developers.weixin.qq.com/miniprogram/dev/\">官方文档</a>访问体验很差，难道是我电脑问题，搜索一个api有很大的几率拿不到正确返回。希望后面能有一个畅快的阅读文档体验。</p>\n<h3 id=\"小程序生态\">小程序生态</h3>\n<p>在github的repo搜索“小程序”，最多star的是<a target='_blank'  href=\"https://github.com/justjavac/awesome-wechat-weapp\">awesome-wechat-weapp</a>。这个repo起到一个导航作用，在github带awesome开头的一般都是以收集数据为主的仓库。可以得到的信息是，看起来小程序的开发生态很不错，但认真点进每一个仓库的链接，会发现并没有想象中那么多。这个应该是我被React的生态惯坏了。没关系，先看看小程序开发有哪些比较知名的repo吧。  </p>\n<ul>\n<li><a target='_blank'  href=\"https://github.com/Tencent/wepy\">WePY</a> ★10k+ - 支持组件化的小程序开发框架</li>\n<li><a target='_blank'  href=\"https://github.com/Meituan-Dianping/mpvue\">mpvue</a> ★8.7k - 基于 Vue.js 的小程序开发框架，从底层支持 Vue.js 语法和构建工具体系<br>槽点：原本打算用WePy做生产环境的开发，但是看到众多人吐槽bug我就吓退了。整体而言，小程序的生态还没有我想象中那么好。</li>\n</ul>\n<h3 id=\"开发体验\">开发体验</h3>\n<ul>\n<li>在Windows下使用官方小程序开发工具，可以快速搭建小程序结构，提供实时预览，以及小程序可以在手机可以进行实时运行。开发过程中出现有如预览和手机上的样式不一致等的问题。</li>\n<li>自带开发工具的控制台在调试样式选取元素的体验上很差。我选不到元素，只好从Wxml上按代码筛查需要改的选择器再进行修改。</li>\n<li>类似于MVVM的开发体验。一个页面对应一个page，页面以及app的生命周期分明。</li>\n<li>大部分的api都采取回调的方式返回内容，整体结构很清晰。</li>\n<li>路由跳转很轻松。</li>\n<li>很像React的一点就是state的存在方式，在小程序上就是Data。每个page都可以设置属于这个页面的数据。</li>\n<li>有类似与Vue的语法糖</li>\n<li>很多组件官方都封装好了，使用起来很方便。</li>\n</ul>\n<h3 id=\"目前踩的坑\">目前踩的坑</h3>\n<ul>\n<li>wx.getUserInfo()这个接口在我刚入门小程序的这段时间被砍了。对我影响不大，但是对开发而言这种底层的api的改动影响还是很大的。<br><img align=\"center\" style=\"width: 100%;margin-bottom: 20px;border-radius: 8px;background: #f8fdf3;\" data-zoomable src=\"https://user-images.githubusercontent.com/21136420/48886468-08b63080-ee67-11e8-8f63-83d81534d6ad.gif\" alt=\"default\" ></li>\n<li>高度适配上没考虑好问题，所以有那么一点时间是花在适配如iphoneX上。</li>\n<li>如何去掉小程序按钮的边框？<pre><code>selector<span class=\"hljs-selector-pseudo\">::after</span>{\n<span class=\"hljs-attribute\">border</span>: none;\n}\n</code></pre>\n</li>\n<li>怎么修改checkbox的大小？<pre><code><span class=\"hljs-selector-class\">.checkbox</span> {\n<span class=\"hljs-attribute\">transform</span>: <span class=\"hljs-built_in\">scale</span>(<span class=\"hljs-number\">0.6</span>, <span class=\"hljs-number\">0.6</span>);\n}\n</code></pre>\n<h3 id=\"后语\">后语</h3>\n</li>\n</ul>\n<p>目前还没对接数据接口，不知道会有什么坑等着我。而且如果后期需要封装组件的话，还不知道会发生什么问题呢。也很希望官方多为开发者着想下，不要轻易动底层api，不然又要多熬几天夜的人就不少了。再接再厉，好好学习。</p>\n"},{"title":"Ubuntu的搜狗输入法出现候选词乱码的问题","slug":"2018_04_ubuntu-sougou","description":"ubuntu的搜狗输入法会出现候选词乱码的情况，只会出现在中文上，怎么解决呢？","keywords":"ubuntu,sougou,code","labels":["工具"],"date":"2018-04-08","path":"2018/04/ubuntu-sougou.md","html":"<pre><code>$ rm -rf ~<span class=\"hljs-regexp\">/.config/</span>SogouPY ~<span class=\"hljs-regexp\">/.config/</span>sogou*\n</code></pre>\n<p>然后重启reboot</p>\n"},{"title":"每次重装Linux Mint减少90%时间","slug":"2017_12_linux-mint","description":"每次重装Linux Mint减少90%时间","keywords":"linux,mint,soft,tools","labels":["工具"],"date":"2017-12-21","path":"2017/12/linux-mint.md","html":"<h2 id=\"系统\">系统</h2>\n<ol>\n<li><a target='_blank'  href=\"https://www.google.com/chrome/browser/desktop/index.html\">Google</a><br> 谷歌页面缩放125%</li>\n<li><a target='_blank'  href=\"https://pinyin.sogou.com/linux/?r=pinyin\">搜狗输入法</a><br> 重启-输入法设置成功-QQ登录同步词库</li>\n<li>安装扩展透明状态栏<br> 设置-面板-扩展</li>\n<li>terminal<br> ctrl + shift + c --&gt; ctrl + c  </li>\n<li>创建ssh key  </li>\n</ol>\n<p><a target='_blank'  href=\"https://github.com/settings/keys\">粘贴到github</a></p>\n<pre><code class=\"language-bash\"><span class=\"hljs-keyword\">sh-keygen </span>-t rsa -<span class=\"hljs-keyword\">b </span><span class=\"hljs-number\">4096</span> -C <span class=\"hljs-string\">&quot;gzy.guy@gmail.com&quot;</span>\n</code></pre>\n<ol start=\"6\">\n<li>安装oh my zsh</li>\n</ol>\n<pre><code class=\"language-bash\">https:<span class=\"hljs-regexp\">//gi</span>thub.com<span class=\"hljs-regexp\">/robbyrussell/</span>oh-my-zsh\nsudo apt-get install zsh\nsudo apt-get install git\n</code></pre>\n<ol start=\"7\">\n<li>设置小飞机<br> <a target='_blank'  href=\"https://github.com/GzhiYi/frontend-log/issues/2\">#链接</a>  </li>\n<li>安装vscode<br> <a target='_blank'  href=\"https://code.visualstudio.com/\">vsCode</a><br> 下载安装扩展setting-sync 需要token 和 gistId</li>\n<li>字体问题<br> <a target='_blank'  href=\"http://tieba.baidu.com/p/5128932851\">链接</a><br> 软件管理器 - 删除 Fonts-arphic-ukai  Fonts-arphic-uming</li>\n</ol>\n<h2 id=\"项目\">项目</h2>\n<ol>\n<li>安装nvm</li>\n</ol>\n<pre><code class=\"language-bash\">sudo apt-<span class=\"hljs-built_in\">get</span> <span class=\"hljs-keyword\">update</span>\nsudo apt-<span class=\"hljs-built_in\">get</span> install build-essential libssl-dev\ncurl -sL http<span class=\"hljs-variable\">s:</span>//raw.githubusercontent.<span class=\"hljs-keyword\">com</span>/creationix/nvm/v0.<span class=\"hljs-number\">31.0</span>/install.<span class=\"hljs-keyword\">sh</span> -<span class=\"hljs-keyword\">o</span> install_nvm.<span class=\"hljs-keyword\">sh</span>\nbash install_nvm.<span class=\"hljs-keyword\">sh</span>\nnvm use <span class=\"hljs-number\">6.11</span>.<span class=\"hljs-number\">5</span>\n</code></pre>\n<ol start=\"2\">\n<li>换源<br> <a target='_blank'  href=\"https://github.com/GzhiYi/frontend-log/issues/4\">链接</a></li>\n<li>安装postgres</li>\n</ol>\n<pre><code class=\"language-bash\">sudo apt-<span class=\"hljs-keyword\">get</span> install postgresql-client\nsudo apt-<span class=\"hljs-keyword\">get</span> install postgresql\nsudo apt-<span class=\"hljs-keyword\">get</span> install pgadmin3\nsudo su - postgres\npsql\n<span class=\"hljs-keyword\">create</span> <span class=\"hljs-keyword\">role</span> gzhiyi <span class=\"hljs-keyword\">login</span>;\n</code></pre>\n<ol start=\"4\">\n<li>安装virtualenv  </li>\n</ol>\n<pre><code class=\"language-bash\">sudo apt-<span class=\"hljs-builtin-name\">get</span> install virtualenv\n</code></pre>\n<h2 id=\"问题\">问题</h2>\n<p>ubuntu 系的chrome有个闪屏的问题， 原因还是因为显卡。\n有解决办法：</p>\n<ol>\n<li>关闭chrome设置中的硬件加速。</li>\n<li>打开 chrome://flags， 找到GPU rasterization，选择Force enable for layers。\n第二个不知道有没用。</li>\n</ol>\n<p>只是没有闪的问题，但是还有些异常的</p>\n"},{"title":"前端搭建win10-ubuntu双系统的小记","slug":"2017_11_win10-ubuntu","description":"笔记本安装win10和ubuntu做开发本","keywords":"前端,win10,ubuntu,gnome","labels":["工具"],"date":"2017-11-09","path":"2017/11/win10-ubuntu.md","html":"<h2 id=\"首先版本是ubuntu-1604lts非麒麟版本。\">首先版本是Ubuntu 16.04(LTS)非麒麟版本。</h2>\n<p>由于时间不多，主要拿Ubuntu进行web开发。其他发行版并未尝试。也好记录一下配置Ubuntu以及gnome的走过的坑。</p>\n<h3 id=\"安装ubuntu\">安装Ubuntu</h3>\n<p>可到官网安装，版本看个人喜欢，麒麟版本自带中文以及拼音输入法等。</p>\n<p><a target='_blank'  href=\"http://cn.ubuntu.com/download/\">Download</a></p>\n<p>下载好之后用软碟通写入U盘映像。无论双系统与否都必须关闭secure Boot。\n解释算好也基本上上每个懂折腾Linux的都会看过这一篇文章\n<a target='_blank'  href=\"http://www.ruanyifeng.com/blog/2013/01/secure_boot.html\">反Secure Boot垄断：兼谈如何在Windows 8电脑上安装Linux</a></p>\n<p>自行划分硬盘空间。\n硬盘划好，电脑开机选快捷启动就进入安装，分区的时候主要有几个分区点（以下只是在双系统下分配硬盘空间较小的建议，实际看个人需要）:</p>\n<p>/：存储系统文件，建议15G;</p>\n<p>swap：交换分区，即Linux系统的虚拟内存，建议是物理内存的1～2倍；</p>\n<p>/home：home目录，存放音乐、图片及下载等文件的空间，建议最后分配所有剩下的空间；</p>\n<p>/boot：包含系统内核和系统启动所需的文件，实现双系统的关键所在，建议200M。</p>\n<p>均可选择为逻辑分区。\n一路下来就可以开机了。\n由于没有记录图片所以不再多说。</p>\n<h3 id=\"安装gnome\">安装gnome</h3>\n<p>安装完Ubuntu如果足够开发就不需要Gnome，自带的是Untiy，Gnome只是美化和方便。因为有大量的扩展可以使用。</p>\n<pre><code><span class=\"hljs-bullet\">1.</span> Ctrl+Alt+T 打开终端\n</code></pre>\n<pre><code><span class=\"hljs-number\">2</span>. $ sudo apt-<span class=\"hljs-keyword\">get</span> install gnome-<span class=\"hljs-keyword\">shell</span>  //安装gnome-<span class=\"hljs-keyword\">shell</span>\n</code></pre>\n<pre><code><span class=\"hljs-number\">3.</span> $ sudo apt-<span class=\"hljs-keyword\">get</span> install ubuntu-gnome-desktop  <span class=\"hljs-comment\">//安装gnome-desktop</span>\n</code></pre>\n<pre><code><span class=\"hljs-number\">4.</span> $ sudo apt-<span class=\"hljs-keyword\">get</span> install unity-tweak-tool  <span class=\"hljs-comment\">//安装 unity-tweak-tool</span>\n</code></pre>\n<pre><code><span class=\"hljs-number\">5.</span> $ sudo apt-<span class=\"hljs-keyword\">get</span> install gnome-tweak-tool   <span class=\"hljs-comment\">//安装gnome-tweak-tool</span>\n</code></pre>\n<h3 id=\"重启请选择-gnome经典桌面\">重启请选择 Gnome经典桌面</h3>\n<p>输密码那有个齿轮的，不选择的话会有坑。一开始自己默认进入的是Ubuntu桌面，只能应用主题图标，扩展都没办法应用。\ngnome拓展到<a target='_blank'  href=\"https://extensions.gnome.org/\">gnome拓展中心</a>下载安装。\n如果没有安装浏览器插件，火狐和chrome的应用或者说插件中心搜索gnome shell extensoins 安装就可以。</p>\n<h3 id=\"扩展推荐和注意\">扩展推荐和注意</h3>\n<p>推荐(必装)： <a target='_blank'  href=\"https://extensions.gnome.org/extension/307/dash-to-dock/\">Dash to Dock</a>、<a target='_blank'  href=\"https://extensions.gnome.org/extension/545/hide-top-bar/\">Hide Top Bar自动隐藏顶栏</a></p>\n<p>底栏去除：</p>\n<p>到目录</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-regexp\">/usr/</span>share<span class=\"hljs-regexp\">/gnome-shell/</span>extensions\n</code></pre>\n"},{"title":"如何在ubuntu下使用shadowsocks","slug":"2017_11_ubuntu-shadowsocks","description":"如何在ubuntu下使用shadowsocks","keywords":"ubuntu,shadowsocks","labels":["工具"],"date":"2017-11-09","path":"2017/11/ubuntu-shadowsocks.md","html":"<h3 id=\"提示：\">提示：</h3>\n<ol>\n<li>测试环境：Ubuntu 16.04 (gnome桌面环境)</li>\n<li>需要ss出国，就需要有ss账号。有很多的出售账号的地方。当然也可以自己搭建个人ss服务器，这里就不再赘述。</li>\n<li>需要下载软件Shadowsocks-Qt5,具体下面会列出。</li>\n<li>提供SwitchyOmega配置文件，不需要自己配置。</li>\n<li>每次开机需要手动连接Qt5，除非设置自动连接。</li>\n<li><a target='_blank'  href=\"https://github.com/GzhiYi/frontend-log/releases/tag/ss\">文件</a><h2 id=\"步骤steps\">步骤(Steps):</h2>\n</li>\n</ol>\n<ul>\n<li>下载Shadowsocks-Qt5：  <pre><code>sudo<span class=\"hljs-built_in\"> add-apt-repository </span>ppa:hzwhuang/ss-qt5\nsudo apt-get update\nsudo apt-get install shadowsocks-qt5\n</code></pre>\n</li>\n<li>打开Qt5，右键空白选择添加。对应填上自己的ss账号信息。<br>有多种添加账号的方式，哪种合适用哪种。账号信息填好就点击新建的账号连接。如果ip能连通一般有延迟显示。</li>\n<li>下载SwitchyOmega<br>可以提供gfw过滤等，在chrome下使用体验很不错。<br><a target='_blank'  href=\"https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?utm_source=chrome-ntp-icon\">chrome上车</a><br><a target='_blank'  href=\"https://addons.mozilla.org/zh-CN/firefox/addon/switchyomega/\">fireFox上车</a><br>文件在提示第六条有release下载。</li>\n<li>配置SwitchyOmega<br>点击选项--导入/导出--从备份文件恢复。选择文件  <pre><code><span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">OmegaOptionsChrome</span>.</span></span>bak\n</code></pre>\n</li>\n<li>开启switchyOmega<br>选择switchyOmega的自动切换</li>\n</ul>\n<h2 id=\"开机自启方法\">开机自启方法</h2>\n<ol>\n<li>选择Qt5添加的项目右键--编辑，勾选程序启动时自动连接</li>\n<li>Qt5  设置--常规设置--登录时启动</li>\n</ol>\n"}]