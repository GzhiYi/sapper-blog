[{"title":"2020-06/vscode-up-down-quickly.md","path":"2020-06/vscode-up-down-quickly","slug":"2020-06_vscode-up-down-quickly","fmData":{"attributes":{"title":"Visual Studio Code快速上下滚动光标","description":"默认上下按键滚动光标是在太慢，有方法可以加快滚动速度。","keywords":"vs code, scroll,speed up, up,down,cursor","labels":["工具"],"date":"2020-06-30T00:00:00.000Z"},"body":"设置光标快速滚动，可以在少动鼠标的情况下快速滚动到目标代码处，结合常用的快捷键，可以提高编码效率。\n\n## 设置\n\n在vscode，打开设置-键盘快捷方式，点击下图打开[keybindings.json](https://code.visualstudio.com/docs/getstarted/keybindings#_advanced-customization)。\n\n![Xnip2020-06-30_17-21-04.jpg](https://i.loli.net/2020/06/30/5IA78WnLfSpmeJP.jpg)\n\n在json底部添加：\n\n```json\n  {\n    \"key\": \"cmd+up\",\n    \"command\": \"cursorMove\",\n    \"args\": {\n      \"to\": \"up\",\n      \"by\": \"line\",\n      \"value\": 3\n    },\n    \"when\": \"editorTextFocus\"\n  },\n  {\n    \"key\": \"cmd+down\",\n    \"command\": \"cursorMove\",\n    \"args\": {\n      \"to\": \"down\",\n      \"by\": \"line\",\n      \"value\": 3\n    },\n    \"when\": \"editorTextFocus\"\n  }\n```\n\n可以将cmd更改为未占用或者舒服的按键。\n\n可以将value更改为自己舒适的一次按键滚动行数。\n\n找了好久的办法，就想实现快速滚动，因为平时如果键盘和鼠标切换多了，总有种**代码输出伤害溢出大**的感觉。\n\n","bodyBegin":9,"frontmatter":"title: Visual Studio Code快速上下滚动光标\ndescription: 默认上下按键滚动光标是在太慢，有方法可以加快滚动速度。\nkeywords: vs code, scroll,speed up, up,down,cursor\nlabels: ['工具']\ndate: 2020-06-30"}},{"title":"2020-06/valine-and-notifications.md","path":"2020-06/valine-and-notifications","slug":"2020-06_valine-and-notifications","fmData":{"attributes":{"title":"博客评论更改为valine并增加评论推送","description":"评论模块由gitalk转为valine，通过techulus的push进行评论推送","keywords":"sapper,blog,techulus push,valine,comments","labels":["前端"],"date":"2020-06-29T00:00:00.000Z"},"body":"通过一点时间的使用，发现gitalk可以解决静态博客评论问题，是挺方便的，但综合考虑下，存在以下两个缺点：\n\n1. 需要github账号登录。\n2. 访问非常慢。\n\n有意间，发现一个评论插件很适合静态博客植入：[Valine](https://valine.js.org/)。\n\n新样式\n\n![style](https://i.loli.net/2020/06/29/RiSBpcyAQD1kXCN.jpg)\n\n新评论模块默认很清新，和我当前的样式较为符合，只做了一点点的样式覆盖。\n\n```css\n/* valine 样式覆盖 */\n.v[data-class=v] .vwrap {\n\tborder: 1px solid rgba(255, 62, 0, 0.1) !important;\n}\n.v[data-class=v] .vwrap .vheader .vinput {\n\tborder-bottom: none !important;\n}\n.v[data-class=v] .txt-right {\n\tdisplay: none !important;\n}\n```\n\n## 推送\n\n在valine的文档中，有提到可以用一个扩展的valine-admin以实现评论通知功能。我在leancloud尝试了发现比较麻烦。外加之前使用GitHub Actions用到了一个推送服务实现了在action成功之后推送部署成功的通知到手机上。那是不是可以通过下面的思路去实现评论推送呢？\n\n> [PUSH注册](https://push.techulus.com/)注册后使用免费的plan，可以每月100条推送限额。要推送到手机，只需要调用提供的接口还有下载一个手机APP就好了。\n\n要知道，做到推送到手机，只需要POST下面的接口：\n\n```bash\nhttps://push.techulus.com/api/v1/notify/{YOU API KEY}?title=Push by Techulus&body=This is your first push notification\n```\n\n\n\n1. 在评论接口POST请求之后，在lean端通过类似拦截/触发的方法调用推送接口。\n2. 在网页端拦截POST请求，在评论发出之后，在调用推送接口。\n\n在查看对应文档之后，第一种方式我找不到可行的入口。我想确定数据库入库的逻辑在哪处理的也找不到，所以采用第二种方法。\n\n## 拦截评论请求\n\n1. 博客引入ajax-hook全局拦截请求\n\n```html\n<script src=\"https://unpkg.com/ajax-hook@2.0.3/dist/ajaxhook.min.js\"></script>\n```\n\n2. 在ajax-hook实例上，处理onRequest钩子。\n\n   ```javascript\n   ah.proxy({\n\t\t\t//请求发起前进入\n\t\t\tonRequest: (config, handler) => {\n\t\t\t\tif (config.url.includes('classes/Comment') && config.method === 'POST') {\n\t\t\t\t\tconsole.log('请求发起前', config.body)\n\t\t\t\t\tfetch(\n\t\t\t\t\t\t`https://push.techulus.com/api/v1/notify/${YOU API KEY}?title=${location.pathname || '文章'}有新回复&body=${config.body.substr(12, 30)}`,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tmode: 'cors',\n\t\t\t\t\t\t\theaders: new Headers({\n\t\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t\thandler.next(config);\n\t\t\t},\n\t\t\t//请求发生错误时进入，比如超时；注意，不包括http状态码错误，如404仍然会认为请求成功\n\t\t\tonError: (err, handler) => {\n\t\t\t\t\thandler.next(err)\n\t\t\t},\n\t\t\t//请求成功后进入\n\t\t\tonResponse: (response, handler) => {\n\t\t\t\t\thandler.next(response)\n\t\t\t}\n\t\t})\n   ```\n\n   更多关于ajax-hook的文档，参阅：[ajax-hook](https://github.com/wendux/Ajax-hook)\t\n\n## 缺点提示\n\n第一种方式可以很好的保护推送的API KEY，因为有限额，暴露后可以随意调用。第二种比较简单易行。不过，反正push服务免费的话，也不会有损失。如果push服务付费就不要用第二种方法了。\n\n完成以上操作就可以收到评论推送啦，还是很方便的。如果有更好的免费push服务提供的，可以评论留言，我会很快看到的。","bodyBegin":9,"frontmatter":"title: 博客评论更改为valine并增加评论推送\ndescription: 评论模块由gitalk转为valine，通过techulus的push进行评论推送\nkeywords: sapper,blog,techulus push,valine,comments\nlabels: ['前端']\ndate: 2020-06-29"}},{"title":"2020-06/firebase.md","path":"2020-06/firebase","slug":"2020-06_firebase","fmData":{"attributes":{"title":"用firebase给静态博客页面增加点赞功能","description":"用firebase给静态博客页面增加点赞功能","keywords":"firebase,like","labels":["前端"],"date":"2020-06-28T00:00:00.000Z"},"body":"想给博客增加一个点赞功能。最后，看起来就是这样：\n\n![like](https://i.loli.net/2020/06/28/Ej9in7gr5uNHIJO.jpg)\n\n实现这个功能要考虑几个问题：\n\n1. 没有服务器，接口怎么编写部署？\n2. 博客没有登录，数据库设计的时候怎么识别用户唯一性。\n\n## Firebase\n\n对于firebase的介绍，最好是直接进入[主站](https://firebase.google.com)开通spark版尝试。\n\n使用firebase，就可以很好的解决第一个问题。spark方案提供免费的空间支持，对于博客这种量级小，交互少的页面来说再适合不过了。\n\n如果用过tx云的云开发，就可以知道，其实概念有些相似，甚至在云函数的编写上也有几分相似。\n\n## fingerprintjs2\n\n利用[fingerprintjs2](https://github.com/fingerprintjs/fingerprintjs2)，可以通过user agent等信息生成用户唯一的一个ID，虽然不能100%保证用户唯一性，但对于无需登录的博客而言，已经足够了。\n生成指纹的主要用法：\n\n```javascript\nFingerprint2.x64hash128(values.join(''), 31)\n```\n\n## 过程\n\n整个过程，时间大部分花在云函数执行数据库操作语法上。以下前提是开通了firebase的spark方案，开通方式直接明了就不赘述啦。\n\n### 控制台\n\n需要在控制台创建你的一个项目，创建好项目之后再执行下面的步骤。\n\n### 函数（functions）编写\n\n相关代码可以查看：[blog-like](https://github.com/GzhiYi/blog-like/blob/master/functions/index.js)\n\n1. 安装Firebase CLI工具以初始化函数仓库。\n\n```bash\nnpm install -g firebase-tools\n```\n2. 登录\n\n```bash\nfirebase login\n```\n\n3. 创建一个空目录，然后初始化这个目录，例如目录名为blog-like\n\n```bash\nmkdir blog-like && cd blog-like && firebase init\n```\n\n执行init命令后会提示选择新建项目的一些规则。（以下是规则过程）\n\n`q: Which Firebase CLI features do you want to set up for this folder? Press Space to select features, then Enter to confirm your choices.`\n`a: 选择Firestore: Deploy rules and create indexes for Firestore以及Functions: Configure and deploy Cloud Functions`  \n\n`q: Please select an option:`\n`a: Use an existing project，随后选择在控制台创建的项目。`\n\n随后几个按enter就好了。\n\n4. 函数编写。\n\n需要两个接口，一个是新增点赞接口，路由为：`/newLike`，一个是获取点赞数据的接口，路由为：`/getLikes`。\n\n - newLike。先判断该用户是否已经点过赞。需要存储的数据：文章标题、点赞时间、用户指纹。\n - getLikes。先获取该文章点赞总数，在判断用户是否已经点过赞。\n\n有了以下基本代码：\n\n点赞数据表：\n\n```json\n{\n    id: 用户指纹，\n    likeTime：点赞时间，\n    postTitle：文章标题\n}\n```\n\n\n\nnewLike，创建点赞数据：\n\n```javascript\ndb.collection('like')\n  .where(\"postTitle\", \"==\", request.body.title)\n  .get()\n  .then(res => {\n  let isLike = false\n  try {\n    // 判断是否已经点赞过\n    res.forEach(doc => {\n      if (doc.id === request.body.id && !isLike) {\n        isLike = true\n      }\n    })\n    if (!isLike) {\n      let docRef = db.collection('like').doc(params.id);\n      docRef.set({\n        postTitle: params.title,\n        likeTime: new Date().toLocaleString()\n      });\n      response.send({\n        data: 'like success!',\n        code: 0\n      })\n    } else {\n      response.send({\n        data: '',\n        message: 'like 过啦',\n        code: 1\n      })\n    }\n  } catch (error) {\n    console.log('error', error)\n  }\n})\n```\n\ngetLikes，获取点赞数据：\n\n```javascript\ndb.collection('like')\n  .where(\"postTitle\", \"==\", title)\n  .get()\n  .then(res => {\n  let isLike = false\n  try {\n    res.forEach(doc => {\n      if (doc.id === id && !isLike) {\n        isLike = true\n      }\n    })\n  } catch (error) {\n    console.log('error', error)\n  }\n  response.send({\n    data: res.size,\n    isLike,\n    message: 'oooooooook',\n    code: 0\n  })\n})\n  .catch(error => {\n  response.send({\n    data: error,\n    message: request.body,\n    code: 1\n  })\n})\n```\n\n在函数编写之后，执行命令就可以部署到云端啦。\n\n```bash\nfirebase deploy --only functions\n```\n\n## 用户端\n\n在博客页面上生成用户唯一ID后用fetch请求点赞接口就可以了。\n\n另外，跨域问题需要函数端用上cors处理。详细的都可以在[仓库](https://github.com/GzhiYi/blog-like)看到。\n\n## 体验\n\n最后说一下体验。整个开发过程比较愉快，花了点点时间查阅数据库操作语法。上线尝试访问，发现google的果然访问好慢！\n\n你可以点击下面clap按钮试试，如果没有，说明网络问题，unreachable。","bodyBegin":9,"frontmatter":"title: 用firebase给静态博客页面增加点赞功能\ndescription: 用firebase给静态博客页面增加点赞功能\nkeywords: firebase,like\nlabels: ['前端']\ndate: 2020-06-28"}},{"title":"2020-06/apple-wwdc-2020.md","path":"2020-06/apple-wwdc-2020","slug":"2020-06_apple-wwdc-2020","fmData":{"attributes":{"title":"2020年苹果开发者大会","description":"2020 Apple Worldwide Developers Conference","keywords":"apple,2020,wwdc","labels":["随笔"],"date":"2020-06-23T00:00:00.000Z"},"body":"昨晚苹果线上直播了2020年开发者大会。本次大会给了不少的东西出来。其中最引瞩目的就是宣布自研Mac ARM芯片，从Intel中跳出来。\n\n这是苹果想统一多平台下的一个大棋。在会之前就有不少的人分析arm架构的处理器会给市场带来什么影响。用户无需考虑太多，而开发者倒会更多的考虑开发兼容性的问题。\n\n## 苹果生态\n\n毫无疑问，苹果在生态上走的越来越靠拢，强化多平台优秀的体验拉拢了越来越多的用户。我个人觉得iOS很流畅，能稳定的运行不会忽然卡顿就已经很满足了。但也非常不喜欢苹果的一些缺失的功能。拿着超前的体验做着安卓好几年前就有的功能，不知道iOS开发的执行力是不是不够，但个别地方的体验真的不尽人意。短信不能未读提示，电量不足20%还强制弹窗提示...有好多地方在产品的设计上就有问题。\n\n后面接触了macOS，我常将它比作是ui更精致，系统更稳定的linux。开发体验非常好，从此告别了windows。windows在开发过程总会遇到不明不白的卡顿问题，terminal也总是让人觉得帧数很低不顺畅。还有一个很重要的优点就是macOS没有广告弹窗，这点就不得不吐槽windows下国产应用肆意妄为弹窗、捆绑了。未来会一直用macOS开发，总结一个词就是相见恨晚。\n\n![007S8ZIlgy1gg24hxohtfj31c00u07wn.jpg](https://i.loli.net/2020/06/23/Agv9hHwZI4eMyqT.jpg)\n\n新的macOS ui有了更新，图标改为了圆角矩形，和ipadOS、iOS越来越相似。个人觉得改动并不会丑，大概率又会是真香体验。\n\n","bodyBegin":9,"frontmatter":"title: 2020年苹果开发者大会\ndescription: 2020 Apple Worldwide Developers Conference\nkeywords: apple,2020,wwdc\nlabels: ['随笔']\ndate: 2020-06-23"}},{"title":"2020-06/sapper-github-actions.md","path":"2020-06/sapper-github-actions","slug":"2020-06_sapper-github-actions","fmData":{"attributes":{"title":"使用github actions自动编译部署sapper-blog","description":"使用github actions打包部署sapper项目并部署到github pages。","keywords":"github actions,sapper,github pages","labels":["前端"],"date":"2020-06-22T00:00:00.000Z"},"body":"之前构建好了的[博客](/blog/2020-06_build-blog)，通过编写一个脚本实现本地自动化部署。脚本实现的功能就是在本地处理项目的打包并将静态文件推送到远端的`gh-pages`分支以实现静态文件部署。在了解github actions之后，决定增加一个自动化打包部署的workflow。这样就可以将编译打包的操作完全放置在”云端“。\n\n## 编写workflow配置文件\n\n在项目根目录创建`.github/workflows/main.yml`\n\n```yaml\nname: Deploy GitHub Pages\n\non:\n  push:\n  \t# push钩子监听的分支，为编译打包的分支\n    branches:\n      - feat/dev\n\n# 任务\njobs:\n  build-and-deploy:\n    # 服务器环境：最新版 Ubuntu\n    runs-on: ubuntu-latest\n    steps:\n      # 拉取代码\n      - name: Checkout\n        uses: actions/checkout@v2\n        with:\n          persist-credentials: false\n\n      # 生成静态文件\n      - name: Build\n        run: npm install && npm run export && cp -i CNAME __sapper__/export\n\n      # 部署到 GitHub Pages\n      - name: Deploy\n        uses: JamesIves/github-pages-deploy-action@releases/v3\n        with:\n          ACCESS_TOKEN: ${{ secrets.GH_PAGES }}\n          BRANCH: gh-pages\n          FOLDER: __sapper__/export\n```\n\n上面配置有个别要注意的点：\n\n1. branches需要设置为要处理的分支。\n\n2. with/ACCESS_TOKEN为github生成的token。\n\n   生成步骤：\n\n   [github右上角的Settings-Developer settings-Personal access tokens](https://github.com/settings/tokens) 点击`Generate new token`，为了和配置文件对应，token的note需要填写为GH_PAGES，然后勾选scope为repo。\n\n   在博客的仓库的setting设置secret。\n\n   ![Xnip2020-06-22_14-12-10.jpg](https://i.loli.net/2020/06/22/jurxoLcUY7p5C8a.jpg)\n\n3. with/FOLDER为sapper导出export的静态文件目录。\n\n以上完成之后，将代码push到远端仓库，就可以在Actions看到名字为`Deploy Github Pages`的workflow。\n\n![Xnip2020-06-22_14-15-32.jpg](https://i.loli.net/2020/06/22/bCxitLWKVlgHD8P.jpg)\n\n## 体会\n\nGithub Actions比在公司使用gitlab cicd快了不少，体验非常不错。在写完博客之后，只需要做的，只有将更新的内容push到github就可以了。\n\n","bodyBegin":9,"frontmatter":"title: 使用github actions自动编译部署sapper-blog\ndescription: 使用github actions打包部署sapper项目并部署到github pages。\nkeywords: github actions,sapper,github pages\nlabels: ['前端']\ndate: 2020-06-22"}},{"title":"2020-06/eclipse.md","path":"2020-06/eclipse","slug":"2020-06_eclipse","fmData":{"attributes":{"title":"日环食","description":"日环食，10年一遇，还有自己的一点小思考。","keywords":"日环食","labels":["随笔"],"date":"2020-06-21T00:00:00.000Z"},"body":"或许是不留意，像日环食、日全食这样难得一见的新闻像是突然冒出来一样。今天遇上了10年一遇的日环食。\n\n当然是不能用眼睛直视啦，不过我在的屋子刚好下午是看不到阳光，外加上兴趣也不是十分大（没有工具，手机也拍不到好，外面又很热很热），就没有特意跑到楼下去看了。倒是朋友圈和微博都有非常多的直播，看他们发的，其实也就够了。新闻也提到了可以用小孔成像原理，就是拿一个带小孔的“东西”放在阳光下就可以看到日食的样子。恰巧有人路过拍下下面有意思的画面。\n\n![IMG_6668.JPG](https://i.loli.net/2020/06/21/3y8KMzdDhmQWBtq.jpg)\n\n也不是我现场看到，但如果这是日环食通过小孔成像体验的模样，就颇为奇妙了，奇妙的不仅仅是这一自然现象，还有的是大千世界无与伦比的恰巧带来奇妙的画面。\n\n## 小思考\n\n自己也常常浮想联翩。就拿今天的日环食，我会想为啥星球都是如此的圆；为什么会有那么巧的情况，让太阳被某个星球所刚好阻挡住光线。《星际穿越》是我最喜欢的电影，对于浩瀚太空的探索，显得我们那么渺小，就像男主结尾疑惑是谁把空间放在那的，我也在想，所有的一切都是自然发生的吗？还是有更高的物质将我们赋予生命、时间、还有空间？恐怕人类从开始到结束，都不会知道。走出浮想，想想今天也是天气很好的一天，我总可以好好享受自然带来的乐趣，觉得人类到底也是幸运的。","bodyBegin":9,"frontmatter":"title: 日环食\ndescription: 日环食，10年一遇，还有自己的一点小思考。\nkeywords: 日环食\nlabels: ['随笔']\ndate: 2020-06-21"}},{"title":"2020-06/build-blog.md","path":"2020-06/build-blog","slug":"2020-06_build-blog","fmData":{"attributes":{"title":"用sapper构建一个博客","description":"用sapper构建一个博客，相关技术：svelte、sapper、tailwindcss、typescript。编写markdown后一键部署到github pages。","keywords":"sapper，博客，svelte，tailwindcss，typescript，github pages，markdown","labels":["前端","技术"],"date":"2020-06-20T00:00:00.000Z"},"body":"发现自己好久没有写博客了。之前在github开了一个仓库，在仓库的[issue区](https://github.com/GzhiYi/blog/issues)写一些内容。issue区体验挺好的，可以refer上项目代码，也可以追加评论。但我想自己写一个博客，不需要很多花里胡哨的功能，只对内容专注，极大的好处是，可以随心所欲的编写自己喜欢的页面样式。刚好最近有接触了下[svelte](https://svelte.dev/)，就顺带的用[sapper](https://sapper.svelte.dev/)写一个静态页面。\n\n实现需要用到的知识点/技术：\n\n1. svelte\n2. sapper\n3. tailwindcss\n4. typescript\n\n后面两点非必须，可以根据自己需要进行增减。\n\n## 思路\n整体的思路比较简单。\n\nsapper支持export出静态文件，我只需要将静态文件部署到一个静态站点，首选的就是github pages。sapper导出export有一个好处：\n\n> Static doesn't mean non-interactive — your Svelte components work exactly as they do normally, and you still get all the benefits of client-side routing and prefetching.\n\nsapper默认的template就是一个blog，这不是刚好可以拿来起手嘛！但默认的template的 blog内容是固定的数据，大致内容是一个js文件，export一个blog的array。\n\n```javascript\nexport const [\n  {\n    title: '2020-06/build-blog.md',\n    slug: '2020-06_build-blog', // 生成的路由路径\n    html: '<h1 id=\\\"用sapper构建一个博客\\\">用sapper构建一个博客</h1>'\n  }\n]\n```\n\n在sapper export之后，可以在`__sapper__/export/blog`看到生成html静态文件。也就意味着最后需要部署到github pages的目录，就是`__sapper__`目录啦。\n\n**可如果要写博客，那肯定也优先选择Markdown。**\n\n所以需要解决的也就是将Markdown文件转为上面提到的js文件。\n\n## 将Markdown转为js文件\n\n需要用到[Markedjs](https://github.com/markedjs/marked)。\n\n使用也是简单粗暴：\n\n```javascript\nconst marked = require('marked')\nmarked.setOptions({\n  renderer: new marked.Renderer(),\n  highlight: function(code, language) {\n    const hljs = require('highlight.js')\n    const validLanguage = hljs.getLanguage(language) ? language : 'plaintext'\n    return hljs.highlight(validLanguage, code).value\n  },\n  // ...(more options)\n});\nmarked(markdownString)\n```\n\n例如markdownString为：\n\n```\n*hello world*\n```\n\n将会被转为：\n\n```html\n<p><em>hello world</em></p>\n```\n\n知道用法之后，只需要通过fs文件操作，将目标的Markdown文件全部push进一个数组，最后将数组写入一个js文件。\n\n## 读取Markdown并写入文件\n\nnode对操作文件提供了`readir`、`readFile`、`writeFile`等函数。\n\n其中核心的处理逻辑如下：\n\n```javascript\n// 获取所有文件\nconst getAllFiles = function (dirPath, arrayOfFiles) {\n\tfiles = fs.readdirSync(dirPath)\n\tarrayOfFiles = arrayOfFiles || []\n\tfiles.forEach(function (file) {\n\t\tif (fs.statSync(dirPath + \"/\" + file).isDirectory()) {\n\t\t\tarrayOfFiles = getAllFiles(dirPath + \"/\" + file, arrayOfFiles)\n\t\t} else {\n\t\t\tarrayOfFiles.push(path.join(dirPath, \"/\", file))\n\t\t}\n\t})\n\treturn arrayOfFiles\n}\n// 将markdown转为js文件\nconst compile = () => {\n\ttry {\n\t\tconst dirs = getAllFiles('./') // 读取所有文件\n\t\tconst inPosts = [] // 文章数组\n\t\tfor (let fileName of dirs) {\n\t\t\tif (/.md/.test(fileName)) {\n\t\t\t\tconst fileData = fs.readFileSync(`./${fileName}`, 'utf-8') // markdown内容\n\t\t\t\tconst fmData = fm(fileData) // 此处可以忽略fm（fm是处理markdown front matter的，可有可无）\n\t\t\t\tconst rmSuffix = fileName.split('.')[0] // 移除文件名后缀\n\t\t\t\tinPosts.push({\n\t\t\t\t\ttitle: fileName,\n\t\t\t\t\tpath: rmSuffix,\n\t\t\t\t\tslug: rmSuffix.replace('/', '_'),\n\t\t\t\t\thtml: marked(fmData.body),\n\t\t\t\t\tfmData\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tinPosts.forEach(post => {\n\t\t\tpost.html = post.html.replace(/^\\t{3}/gm, '');\n\t\t});\n\t\tconst outPutContent = `export default ${JSON.stringify(inPosts)}`\n\t\tfs.writeFile('../routes/blog/_posts.js', outPutContent, err => {\n\t\t\tif (err) return console.log('生成post失败', err)\n\t\t\tconsole.log('已生成_posts.js')\n\t\t})\n\t} catch (error) {\n\t\tconsole.error('error', error)\n\t}\n}\nconst watcher = chokidar.watch('./')\nwatcher\n\t.on('all', () => {\n\t\tcompile()\n\t})\n```\n\n## 部署到github pages\n\n对于sapper，执行export命令生成静态文件。\n\n```bash\nnpm run export\n```\n\n将`__sapper__/export`推送到仓库的gh-pages分支。\n\n```bash\ngit subtree push --prefix __sapper__/export origin gh-pages\n```\n\n最后在仓库设置出将gh-pages分支设置为部署分支就好了。\n\n以上完成了从写Markdown到可以看到文章，后续页面的编写就可以随心所欲啦！","bodyBegin":9,"frontmatter":"title: 用sapper构建一个博客\ndescription: 用sapper构建一个博客，相关技术：svelte、sapper、tailwindcss、typescript。编写markdown后一键部署到github pages。\nkeywords: sapper，博客，svelte，tailwindcss，typescript，github pages，markdown\nlabels: ['前端', '技术']\ndate: 2020-06-20"}},{"title":"2020-05/element-ui-table-header-sticky.md","path":"2020-05/element-ui-table-header-sticky","slug":"2020-05_element-ui-table-header-sticky","fmData":{"attributes":{"title":"Element-ui table组件表头sticky","description":"不用js处理，css实现element-ui表头sticky。","keywords":"element-ui,table,header,表头,sticky,position,overflow hidden","labels":["前端"],"date":"2020-05-29T00:00:00.000Z"},"body":"element组件表头未支持sticky相关api。可以通过如下css处理：\n\n```css\n// 表头sticky\n.el-table__footer-wrapper,\n.el-table__header-wrapper {\n  position: sticky;\n  top: 48px;\n  overflow: inherit !important;\n  z-index: 99;\n}\n.el-table--small {\n  overflow: inherit;\n}\n```\n\n说明：\n\n`position: sticky`如果没有效果，检查：\n\n1. `top`、`right`、`left`或者`bottom`属性是否有设置。\n2. 在table组件中设置层级，以免被遮挡。\n3. sticky对象的祖先元素不能设置`overflow: hidden;`","bodyBegin":9,"frontmatter":"title: Element-ui table组件表头sticky\ndescription: 不用js处理，css实现element-ui表头sticky。\nkeywords: element-ui,table,header,表头,sticky,position,overflow hidden\nlabels: ['前端']\ndate: 2020-05-29"}},{"title":"2020-01/docker-easymock.md","path":"2020-01/docker-easymock","slug":"2020-01_docker-easymock","fmData":{"attributes":{"title":"Docker部署nuxtjs应用","description":"为了方便本地mock接口，需要在本地用docker跑一个easy-mock服务。第一时间想到docker运行，方便管理和使用。基本上是非常简单就可以跑起来的。所以在这记录一下安装easy-mock的步骤，也为了下次更快的安装。","keywords":"docker,esaymock,api","labels":["前端"],"date":"2020-01-20T00:00:00.000Z"},"body":"为了方便本地mock接口，需要在本地用docker跑一个easy-mock服务。第一时间想到docker运行，方便管理和使用。基本上是非常简单就可以跑起来的。所以在这记录一下安装easy-mock的步骤，也为了下次更快的安装。\n\n> 假设在目录`/Users/{{用户目录名}}/easymock`存放easy-mock配置。\n> 当然需要先安装好docker啦，不再赘述。\n\n## Docker compose文件\n\nx在easymock目录下新建一个docker-compose.yml文件，内容如下：\n\n```yml\nversion: '3'\n\nservices:\n  mongodb:\n    image: mongo:3.4.1\n    volumes:\n      # ./data/db 数据库文件存放地址，根据需要修改为本地地址\n      - './data/db:/Users/{{用户目录名}}/easymock/data/db'\n    networks:\n      - easy-mock\n    restart: always\n\n  redis:\n    image: redis:4.0.6\n    command: redis-server --appendonly yes\n    volumes:\n      # ./data/redis redis 数据文件存放地址，根据需要修改为本地地址\n      - './data/redis:/Users/{{用户目录名}}/easymock/data'\n    networks:\n      - easy-mock\n    restart: always\n\n  web:\n    image: easymock/easymock:1.6.0\n    command: /bin/bash -c \"npm start\"\n    ports:\n      - 7300:7300\n    volumes:\n      # 日志地址，根据需要修改为本地地址\n      - './logs:/Users/{{用户目录名}}/easymock/easy-mock/logs'\n      # 配置地址，请使用本地配置地址替换\n      - './production.json:/Users/{{用户目录名}}/easymock/easy-mock/config'\n    networks:\n      - easy-mock\n    restart: always\n\nnetworks:\n  easy-mock:\n```\n\n## 运行\n\n`docker-compose up -d`即可运行。\n\n```bash\neasymock_redis_1 is up-to-date\neasymock_mongodb_1 is up-to-date\neasymock_web_1 is up-to-date\n```\n后打开`localhost:7300`","bodyBegin":9,"frontmatter":"title: Docker部署nuxtjs应用\ndescription: 为了方便本地mock接口，需要在本地用docker跑一个easy-mock服务。第一时间想到docker运行，方便管理和使用。基本上是非常简单就可以跑起来的。所以在这记录一下安装easy-mock的步骤，也为了下次更快的安装。\nkeywords: docker,esaymock,api\nlabels: ['前端']\ndate: 2020-01-20"}},{"title":"2019-12/docker-nuxtjs.md","path":"2019-12/docker-nuxtjs","slug":"2019-12_docker-nuxtjs","fmData":{"attributes":{"title":"Docker部署nuxtjs应用","description":"有个主页的项目需要用到ssr。所以选择nuxtjs进行主页开发。关于nextjs的使用可以到官方文档进行查看。这里主要是记录一下docker部署nuxtjs应用的一些小事情。","keywords":"docker,nuxtjs,ssr","labels":["前端"],"date":"2019-12-25T00:00:00.000Z"},"body":"有个主页的项目需要用到ssr。所以选择nuxtjs进行主页开发。关于nextjs的使用可以到官方文档进行查看。这里主要是记录一下docker部署nuxtjs应用的一些小事情。\n\n## Dockerfile\n\n通过dockerfile可以build一个docker镜像。dockerfile内容如下：\n```dockerfile\nFROM node:11.13.0-alpine\n\n# create destination directory\nRUN mkdir -p /app\nWORKDIR /app\n\n# copy the app, note .dockerignore\nCOPY . /app\nRUN npm install\n\n# build necessary, even if no static files are needed,\n# since it builds the server as well\nRUN npm run build\n\n# expose 3000 on container\nEXPOSE 3000\n\n# set app serving to permissive / assigned\nENV NUXT_HOST=0.0.0.0\n# set app port\nENV NUXT_PORT=3000\n\n# start the app\nCMD [ \"npm\", \"start\" ]\n```\n\n注意：\n1. 部署 Nuxt.js 服务端渲染的应用不能直接使用 nuxt 命令，而应该先进行编译构建，然后再启动 Nuxt 服务。\n2. 在build之前，需要ignore以下三个规则文件（手动创建.dockerignore文件）：\n\n```\nnode_modules\nnpm-debug*\n.nuxt\n```\n\n否则会出现镜像build失败的情况。\n\n运行命令：docker run -it -d -p 3000:3000 gzhiyi/nuxt-homepage  后面为镜像build后的名称，注意按实际情况进行更改。\n\n## nginx配置\n\nDocker运行node服务，如果需要外部访问的话，需要nginx反向代理。具体配置：\n\n```nginx\nserver {\n    listen 80;\n    server_name *your servername*;\n    location / {\n        proxy_pass http://localhost:3000;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection 'upgrade';\n        proxy_set_header Host $host;\n        proxy_cache_bypass $http_upgrade;\n    }\n}\n```\n## 访问\n需要配置host才能访问，如下：\n\n```hosts\n*your serverip* *your servername*\n```","bodyBegin":9,"frontmatter":"title: Docker部署nuxtjs应用\ndescription: 有个主页的项目需要用到ssr。所以选择nuxtjs进行主页开发。关于nextjs的使用可以到官方文档进行查看。这里主要是记录一下docker部署nuxtjs应用的一些小事情。\nkeywords: docker,nuxtjs,ssr\nlabels: ['前端']\ndate: 2019-12-25"}},{"title":"2019-11/http-cache.md","path":"2019-11/http-cache","slug":"2019-11_http-cache","fmData":{"attributes":{"title":"Http缓存","description":"Http缓存","keywords":"http,缓存","labels":["学习"],"date":"2019-11-28T00:00:00.000Z"},"body":"## 缓存相关头\n\n### 响应头\n\n- Expire。资源过期时间。\n- Cache-Control。缓存控制字段，精确控制缓存策略。\n- Last-Modified。资源最近修改时间。\n- Etag。资源标识。\n\n### 请求头\n\n- Cache-Control。缓存控制字段，精确控制缓存策略。\n- If-Modified-Since。资源最新修改时间。\n- If-None-Match。缓存资源标识。\n\n### 字段匹配\n\nIf-Modified-Since和Last-Modified\nEtag和If-None-Match\n\n## 浏览器和服务器约定资源过期时间\n\n服务器和浏览器之间约定文件的过期时间，控制的字段为：Expires。在这个时间未到之前，浏览器对同一个文件不会向服务器发起请求。\n\n**缺点：**Expire到期后，如果文件未进行过改动，浏览器还是会向服务器请求读取文件。\n\n## 服务器告诉浏览器资源上次的修改时间（解决上面的问题）\n\n服务器返回文件的时候，在响应头上增加一个最近修改时间（Last-Modified）。浏览器在Expires时间到之后，会向服务器发起文件请求，这时带上一个最近修改时间（If-Modified-Since = Last-Modified）。服务器在接受到请求之后，会拿这个时间和服务器上目标文件的上一次修改时间做对比：\n- 相等。进行304跳转，不要读取服务器文件了，读取缓存就行了。\n- 不相等。读取服务器上的文件。\n**缺点：**\n1. Expires过期时间浏览器断可以修改，这样会导致缓存不准确。\n2. Last-Modified过期时间只能精确到秒。（一秒内可能多次改动，这样会造成两个可能的问题：文件一秒内改动多次，但还是通知浏览器读缓存。如果文件修改了，但内容不变，那就会去读服务器文件了。）\n\n## 增加相对时间控制，引入Cache-Control\n\n服务器在返回资源给浏览器的时候，会增加一个相对时间：Cache-Control：max-age=1000s。这个的意思是告诉浏览器，1000s内使用浏览器缓存的文件。\n\n**优先级：** \nCache-Control优先于Expires。有Cache-Control就以Cache-Control为准。\n\n## 继续升级缓存机制\n\n带上Etag-可以理解为文件的唯一Id，由服务器返回到浏览器上。\n在有效期过后，带上一个等同于Etag值的If-None-Match请求头，比较后处理是否读取文件。\n\n## 最后是我前端的一个技巧啦\n\n由于上面那么多的缓存判断条件，都不能满足一个情况，既浏览器永远无法主动知道服务器的文件已经更新。那好：静态资源在请求链接上更新就行了。\n\n```javascript\n<script src=\"http://test.com/a.【hash值】.js\"></script>\n```","bodyBegin":9,"frontmatter":"title: Http缓存\ndescription: Http缓存\nkeywords: http,缓存\nlabels: ['学习']\ndate: 2019-11-28"}},{"title":"2019-09/js-asset-import.md","path":"2019-09/js-asset-import","slug":"2019-09_js-asset-import","fmData":{"attributes":{"title":"JS引入资源的一点总结","description":"很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。","keywords":"javascript,script,阻塞渲染,defer,async,动态引入","labels":["前端"],"date":"2019-09-28T00:00:00.000Z"},"body":"## JS引入的时候放在哪比较好呢？\n\n很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。\n\n## 浏览器渲染\n\n在知道放在哪最好之前，需要知道下浏览器渲染的过程。有以下的步骤：\n\n- 处理文档中的标签并构建DOM（Document Object Model）树。\n- 处理文档中的css并构建CSSOM（CSS Object Model）树。\n- 合并DOM和CSSOM为一个渲染树。\n- 处理渲染树没一个节点的布局。\n- 最后将没一个节点渲染（绘制）到浏览器上。\n\n### 阻塞渲染：CSS和JavaScript\n\n浏览器资源阻塞是一个常见的问题。要知道，资源在大多数浏览器上都是并行加载的，这种情况下，当Html文档被javascript阻塞时，Html文档会终止构建，但仍会`识别阻塞脚本后面的资源，进行预加载`。有以下要点需要注意：\n\n- css加载不会阻塞dom树解析，但会阻塞dom树渲染。\n- 浏览器dom构建会在遇到script标签的时候暂停，直到script内的脚本执行完毕。\n- CSSOM在构建的时候，JavaScript的执行会暂停，直到CSSOM准备就绪。\n\n以上正好说明了，我该把js脚本放在哪😄。我们就得出这样的原则以加快文档构建渲染：\n\n1. CSS优先渲染。将css放在JavaScript资源之上，也就是普遍的放在 < head > 标签内。\n2. 为减少script脚本对dom构建的影响，应该把script尽可能的放到最后（文档底部）。\n\n## defer和async\n\nscript标签的这两个属性，均是为解决上面问题的。defer和async的使用有所不同。\n`defer`：DOM元素的加载和脚本的 ** 加载 ** 异步执行。但是脚本的执行需要在所有dom元素解析完成之后，在`DOMContentLoaded`事件触发之前执行。\n`async`：DOM元素的加载和脚本的加载 ** 以及执行 ** 异步执行。\n\n![284aec5bb7f16b3ef4e7482110c5ddbb_articlex](https://user-images.githubusercontent.com/21136420/65817605-0ae1dc00-e23c-11e9-890b-e70207d371b6.jpeg)\n\n  - 无async和defer的时候，dom渲染被脚本~~加载以及执行~~所中断。\n  - defer的时候，dom渲染未被阻塞，但脚本执行将会到最后。这个特性可以对需求有所利用。\n  - async的时候，dom渲染和脚本加载和执行异步。\n\n## 有时候要用到动态引入？\n\n  统计脚本，广告脚本这类第三方嵌入脚本会在文档底部引入脚本文件。但都是以js生成script标签的形式进行动态引入。\n  先来看下百度统计脚本是怎么引入的：\n  ```javascript\n(function() {\n    var hm = document.createElement(\"script\");\n    hm.src = \"https://hm.baidu.com/hm.js?10dbf7bc9ad86276329db7b\";\n    var s = document.getElementsByTagName(\"script\")[0];\n    s.parentNode.insertBefore(hm, s);\n  })();\n```\n这就是动态创建script标签进行引入的方式。那么为什么要这样引入而不是直接:\n  ```html\n<script src=\"source_url\" async></script>\n```\n  ** 其实，这既不是自执行函数的问题，也不是阻塞渲染的问题。是为了防止用户把脚本放置在文档不规范的地方导致文档被阻塞，并不是所有的脚本嵌入用户都知道这个脚本应该嵌入在哪的。而这样动态引入就可以避免这样的问题。**\n","bodyBegin":9,"frontmatter":"title: JS引入资源的一点总结\ndescription: 很常见的情况是把script放在body右闭合标签的上方，都是这样加载不阻塞页面解析和渲染，达到最优的效果。见得多，用的也多，我比较想理解下其中原因。\nkeywords: javascript,script,阻塞渲染,defer,async,动态引入\nlabels: ['前端']\ndate: 2019-09-28"}},{"title":"2019-09/codereview.md","path":"2019-09/codereview","slug":"2019-09_codereview","fmData":{"attributes":{"title":"CodeReview","description":"公司能有CodeReview的实践是非常好的。它最终的作用是促进工程师日常代码交流和提升工程师的代码能力。","keywords":"代码,codeReview","labels":["学习"],"date":"2019-09-17T00:00:00.000Z"},"body":">There are about 15-20 common mistakes made by programmers.\n> A checklist is a useful means of ensuring that common mistakes are identified.\n\n公司能有CodeReview的实践是非常好的。它最终的作用是促进工程师日常代码交流和提升工程师的代码能力。\n\n## 明确代码规范\n\n无论前端还是后端，代码规范是很重要的。不应该把过多的CodeReview时间放在诸如代码空格、缩进等问题，这都是可以通过代码规范去约束的。各个开发人员都要尽力去写出符合公司代码规范的代码，减少CodeReview时间。\n\n## CodeReview 检查项\n\n有一个简单明确的检查项可以快速对代码进行检查，不用担心遗漏某些必要的项。以下的列表提供建议，可以按公司内要求进行优化添加等。\n\n### 一般\n\n- 代码是否符合预期的功能，逻辑是否正确。\n- 所写的代码是否容易理解。\n- 代码是否符合规定的编码规范。\n- 是否有冗余或者重复编写的代码。\n- 是否尽可能的模块化/组件化。\n- 全局变量是否全局定义（可以快速修改不必多处查找遗漏）。\n- 是否留下注释的代码（视情况保留，一般不要存在好些）。\n- 循环是否正确设置了结束条件。\n- 代码设置的变量命名是否符合语义，易于理解。\n\n### 性能上\n\n- 是否还有更好的能提升既有性能的有效方法。\n- 是否有内置函数或者成熟的库/组件能替换已有代码。\n- 是否已移除掉日志和debug代码。\n\n### 安全上\n\n- 输入类型的代码是否检查了类型、长度、提交格式等，后台是否对输入进行编码（encode）。（防xss）\n- 使用的第三方库有无错误异常捕获处理。\n- 容易出错的地方是否进行异常捕获处理。\n- 代码是否对变量做了空值判断处理。\n\n### 解释说明上\n\n- 代码的作用是否有注释留下描述。\n- 所有函数都做了注释吗？\n- 有没对所有代码异常和边缘情况做好判断处理。\n- 引入的第三方库/组件是否做了必要的用途和引入说明。\n- 有没有不完整的代码？如果有，那代码可不可以删除或者标记TODO等？\n\n### Reviewer && Author\n\n这部分原文在：[戳](https://phauer.com/2018/code-review-guidelines/)\n\n- **用I-Messages**\n\n> You are not your code.\n\n要知道 `You !== Your Code`。给代码review错误不是对人review错误，不要把人自身价值和人写的代码连接起来。每个人都是团队中有价值的一部分。  \n在Author和Reviewer之间应该交换业务最好的实践、经验、一些踩坑点还有一些提示。  \nReviewer在代码反馈上，有一个小规则我觉得挺有意思的：用I-Messages代替I-Messages。\n\n错误: “**你**写的这段代码存在黑魔法。”\n\n正确: “这段代码**我**不是很理解哦。”\n\n- **讨论对象是代码不是人呐**\n\n只讨论代码可以增加review反馈的可接受度。\n\n错误: “**你**写的这代码请求了多次接口，这会影响性能。”\n\n正确: “**这段代码**触发多次请求了，应该会影响性能。”\n\n-  **提问题**\n\n好的方式提问题，让人更好的接受。\n\n错误: “这变量就应该命名为UserId。”\n\n正确: “如果这变量命名为UserId是不是好理解多了？”\n","bodyBegin":9,"frontmatter":"title: CodeReview\ndescription: 公司能有CodeReview的实践是非常好的。它最终的作用是促进工程师日常代码交流和提升工程师的代码能力。\nkeywords: 代码,codeReview\nlabels: ['学习']\ndate: 2019-09-17"}},{"title":"2019-09/mp-env-seperate.md","path":"2019-09/mp-env-seperate","slug":"2019-09_mp-env-seperate","fmData":{"attributes":{"title":"分离小程序环境","description":"官方文档很模糊，搜索到了几条关于小程序环境分离的问题，大部分吐槽官方怎么没有一个好的办法分离开发和生产环境。","keywords":"小程序,环境,分离,云开发","labels":["小程序"],"date":"2019-09-08T00:00:00.000Z"},"body":"官方文档很模糊，搜索到了几条关于小程序环境分离的问题，大部分吐槽官方怎么没有一个好的办法分离开发和生产环境。\n\n## 分离方式\n\n1. 云函数在调用的时候指定环境，依据云函数所在的环境进行动态设置。\n\n```javascript\nconst wxContext = cloud.getWXContext()\n  cloud.updateConfig({\n    env: wxContext.ENV\n  })\n  // 初始化数据库\n  const db = cloud.database({\n    env: wxContext.ENV\n  })\n```\n\n2. 小程序端起到起立环境的主要作用。在appjs中。\n\n```javascript\n     wx.cloud.init({\n        traceUser: true,\n        env: 'release-wifo3', // 测试环境\n        // env: 'dandan-zdm86' // 正式环境\n      })\n```\n预览小程序的时候开启测试环境的env，在部署上线发布的时候再切换为正式环境。","bodyBegin":9,"frontmatter":"title: 分离小程序环境\ndescription: 官方文档很模糊，搜索到了几条关于小程序环境分离的问题，大部分吐槽官方怎么没有一个好的办法分离开发和生产环境。\nkeywords: 小程序,环境,分离,云开发\nlabels: ['小程序']\ndate: 2019-09-08"}},{"title":"2019-08/mp-pass.md","path":"2019-08/mp-pass","slug":"2019-08_mp-pass","fmData":{"attributes":{"title":"我想要小程序过审","description":"小程序审核是很多小程序开发者的痛。怎么让小程序审核通过，这里有一个小技巧。","keywords":"mp,小程序,审核","labels":["小程序"],"date":"2019-08-23T00:00:00.000Z"},"body":"![cover](http://tva1.sinaimg.cn/large/007X8olVly1g69pnw5ai1j30mu05cmxx.jpg)\n小程序审核就是一个痛。资质、内容没问题的自然感受不到这样的痛苦。\n\n尤其是个人小程序，不给你过，因为你小程序有UGC；不给你过，因为你诱导用户分享...\n\n如果类目多还好，个人小程序就那几个能用（感兴趣）的类目，还能怎么办。反正上线过多次小程序，也尝试过很多次审核不通过，对于怎么避开审核组哥哥姐姐的法眼，我有一个代码级绕过的方法。\n\n## 什么内容导致审核不过\n\n要十分清楚什么内容导致小程序没法审核通过。审核不过会简单把驳回原因返回，无外乎是资质、内容之类的问题。有时候觉得描述的模凌两可，我的小程序没有这些违规的，怎么审核还是不过呢！不怕，多试几次之后，很有可能审核组会给一张审核不过的“证据图”。一般是小程序的截图。\n\n## 怎么避开\n\n知道什么原因后，就想办法绕开审核。希望你的小程序不是很违规，只想上线满足自己那种程度，不要干坏事！ \n\n我自己总结了两种办法，两种办法的核心都是：`不要在审核员在审核期间看到不该看到的内容`。\n\n1. 使用延迟显示。\n\n定义一个时间戳，你的内容将在时间戳到达后显示出来。基本的代码可以如下：\n\n```javascript\n// 判断是否在审核期间\nconst nowTime = Date.parse(new Date())\nif (nowTime < 1565078400000) { // 2019-08-06 16:00:00\n  this.globalData.isEscape = false // true 的时候就放开内容\n}\n```\n\n这样就可以屏蔽掉并保证在isEscape为false的时候不显示违规内容。当然这么做还是有缺点的：你不能保证你的小程序审核时候处于审核期，有可能审核周期很长，那怎么办？\n\n2. 使用接口控制显示。\n\n接口这个总该稳了吧？\n\n```javascript\nwx.request({\n  url: '##',\n  method: 'GET',\n  success(res) {\n    getApp().globalData.isEscape = res.data.isEscape\n  }\n})\n```\n\n这其实也不是很好，毕竟接口存在延迟。多少会有。尤其是在云开发的免费配额上，这基本是会影响体验。判断究竟用那种方法，取决于你小程序上线的周期安排等。\n\n## 提示\n\n小程序审核应该能绕过页面逻辑直接打开全部pages定义的页面的，所以要针对这个做一些跳转屏蔽处理。","bodyBegin":9,"frontmatter":"title: 我想要小程序过审\ndescription: 小程序审核是很多小程序开发者的痛。怎么让小程序审核通过，这里有一个小技巧。\nkeywords: mp,小程序,审核\nlabels: ['小程序']\ndate: 2019-08-23"}},{"title":"2019-06/mp-egg.md","path":"2019-06/mp-egg","slug":"2019-06_mp-egg","fmData":{"attributes":{"title":"小程序egg后台简要文档","description":"如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。","keywords":"mp,小程序,eggjs,微信开发后台","labels":["小程序"],"date":"2019-06-06T00:00:00.000Z"},"body":"如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。\n\n如果未接触过node编写接口，首先还是需要基本过一下[egg官方文档](https://eggjs.org/zh-cn/intro/)，至少得把快速入门看完。\n\n不会从头开始把每一步都详细写下来，只针对微信对接的一些处理列出来。\n\n## 数据库\n\n使用mongo，示例通过[egg-mongoose](https://github.com/eggjs/egg-mongoose)进行连接处理。\n\n安装插件后，在`/config/plugin.js`进行基本配置：\n\n```javascript\nmongoose: {\n  enable: true,\n  package: 'egg-mongoose'\n}\n```\n\n在`/config/config.default.js`文件中配置mongodb的连接（保证本地测试环境数据库连接好）：\n\n```javascript\n// connect mongo\n  config.mongoose = {\n    client: {\n      url: 'mongodb://127.0.0.1/fulishe',\n      options: {},\n    }\n  }\n```\n\n在`/app/models`文件夹编写相关的model，在程序运行时会自动在mongo上创建对应的表。也可以优先创建好数据库和表设计等。\n\n## 编写接口\n\n在`controller`写主要的业务逻辑，接受接口请求参数并返回。\n对于入参，需要进行验证的可以做验证处理，需要处理返回结果，即使请求出错也不要返回非200的状态码。\n可以将处理结果设置为一个函数，如：\n\n```javascript\n// data: 返回给前端的数据，code: 状态，1为成功，0为失败，message：状态信息\nformatResponse: function (data, code, message) {\n  return {\n    code,\n    data,\n    message\n  }\n}\n```\n\n!> 为避免出现出现问题而导致程序中断，最好在每一个容易出现问题的地方进行`try catch`将异常抛出并返回到前端。\n\n在`service`编写数据库操作函数等，通过在`controller`进行调用，统一管理数据库数据进出。\n注意在数据新增的时候需要进行`save`操作：\n\n```javascript\nconst addUser = await this.ctx.model.Users(data)\naddUser.save() // 不要遗漏\n```\n\n相关的增删改查操作，需要直接点的可以看仓库`app/service`下的写法。\n\n## 小程序接口相关\n\n以下是eggjs对小程序包括获取openId、获取unionId、获取手机号码、判断用户是否关注公众号、客服信息发送进行编写说明。  \n如果某个对象不知道是什么，一般都是可以根据名字找到对于的js文件或者通过npm引入，不再表述引入什么了。\n\n### 获取openId\n\n参数说明：\n\n- APPID： 小程序的appId\n- SECRET： 小程序的secret，跟appId在同一个地方能找到\n- CODE：小程序在前端通过wx.login()获取的jscode\n\n```javascript\nconst openIdRes = await rp(`https://api.weixin.qq.com/sns/jscode2session?appid=${APPID}&secret=${SECRET}&js_code=${CODE}&grant_type=authorization_code`)\nconst openId = JSON.parse(openIdRes).openId // 在处理错误判断后，返回的数据是json字符串，需要转化\n```\n\n### 获取unionId\n\nunionId，属于微信端通用的账号唯一标识，举个例子就是同一个微信号，唯一对应一个unionId。而在每一个小程序上，用户openId都不一样。可以用于判断在小程序上的用户是否关注公众号等。\n\n在第一个获取`openId`的时候，会返回`openId`以及`session_key`，通过小程序前端传过来的`encryptedData`以及`iv`就可以拿到`unionId`。\n\n参数说明：\n\n- APPID： 小程序的appId\n- sessionKey：获取openId的时候，一并返回了sessionKey\n- encryptedData：小程序在前端通过获取用户信息返回\n- iv：小程序在前端通过获取用户信息返回\n\n```javascript\nconst pc = new WXBizDataCrypt(APPID, sessionKey)\nconst data = pc.decryptData(encryptedData, iv)\nconst unionId = data.unionId\n```\n\n### 获取手机号码\n\n获取手机号码的步骤跟获取unionId一样。\n\n只需要注意的是，`encryptedData`、`iv`是在小程序端通过`getPhoneNumber`获取。\n\n### 判断用户是否关注公众号\n\n这里单独在小程序后台无法判断。需要在对于的公众号后台提供一个接口用于判断该unionId是否已经关注了公众号。\n\n### 客服信息发送\n\n在小程序开发设置中配置消息推送。\n\n配置参考： \n\n参数 | 值 |  备注  \n-|-|-\nURL(服务器地址) | https://*.*.com/message/check | 微信那边与你服务器通信的接口 |\nToken(令牌) | isToken | 自定义 |\nEncodingAESKey(消息加密密钥) | ****** | 填写那可以自动生成 |\n消息加密方式 | \t兼容模式 | 涉及信息安全 |\n数据格式 | \tJSON | 一般是这个吧 |\n\n在`controller`层编写一个`get`接口，对应`/message/check`，用以给微信进行服务器验证。\n完整验证函数接口可如下：\n\n```javascript\nasync index() {\n  const { ctx } = this\n  // 1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr\n  const {\n    signature,\n    timestamp,\n    nonce,\n    echostr\n  } = ctx.query\n\n  // 2.将token、timestamp、nonce三个参数进行字典序排序\n  let array = ['线上配置的令牌', timestamp, nonce]\n  array.sort() // JavaScript sort函数就是字典序排序的\n\n  // 3.将三个参数字符串拼接成一个字符串进行sha1加密\n  const tempStr = array.join('')\n  const hashCode = crypto.createHash('sha1') //创建加密类型\n  const resultCode = hashCode.update(tempStr, 'utf8').digest('hex')\n\n  // 4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信\n  if (resultCode === signature) {\n    ctx.body = echostr\n  } else {\n    // 非微信服务器请求\n    ctx.body = format.formatResponse({\n      resultCode,\n      req: ctx.query\n    }, 0, '验证失败1')\n  }\n}\n```\n\n自动回复操作：\n在`controller`层编写一个`post`接口，对应`/message/check`，用于自动回复。\n完整处理自动回复接口：\n\n```javascript\nasync handle() {\n  const { ctx } = this\n  const { FromUserName, MsgType, Content } = ctx.request.body // 这是从微信转发过来的用户发送的信息参数\n  const { openid } = ctx.query\n  // 获取accessToken\n  const tokenRes = await rp(`https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${CONST.appId}&secret=${CONST.secret}`)\n  if (!('errcode' in JSON.parse(tokenRes))) {\n    if (MsgType === 'text') {\n      const postData = {\n        touser: openid,\n        msgtype: \"link\",\n        link: {\n          title: '链接标题',\n          description: '链接描述',\n          url: '链接',\n          thumb_url: '链接封面图'\n        }\n      }\n      const sendRes = await rp({\n        uri: `https://api.weixin.qq.com/cgi-bin/message/custom/send?access_token=${JSON.parse(tokenRes).access_token}`,\n        method: 'post',\n        body: postData,\n        json: true\n      })\n    }\n  }\n  ctx.body = 'success'\n}\n```\n!> 注意：需要在自动回复的最后返回`success`，否则会在聊天窗口看到提示：`该小程序提供的服务出现故障，请稍后再试`\n","bodyBegin":9,"frontmatter":"title: 小程序egg后台简要文档\ndescription: 如果不需要后端java或者其他语言支持，对于小型的小程序后台，可以使用eggjs框架快速搭建简要的数据后台。\nkeywords: mp,小程序,eggjs,微信开发后台\nlabels: ['小程序']\ndate: 2019-06-06"}},{"title":"2019-04/history-api.md","path":"2019-04/history-api","slug":"2019-04_history-api","fmData":{"attributes":{"title":"修改浏览器回退历史","description":"有个需求，需要修改短链跳转到落地页后，在落地页返回的历史记录。避免出现跳转到落地页后返回还是出现短链中转的问题。","keywords":"浏览器,回退历史，history api,pushState,replaceState","labels":["前端"],"date":"2019-04-12T00:00:00.000Z"},"body":"![无标题绘图](https://user-images.githubusercontent.com/21136420/56006752-c05db900-5d08-11e9-94c3-61938d3f2eeb.png)\n\n有个需求，需要修改短链跳转到落地页后，在落地页返回的历史记录。避免出现跳转到落地页后返回还是出现短链中转的问题。\n\n要求：\n1. 无法控制落地页的所有代码。\n2. 回退页面可在短链内进行定义。 \n\n### History Api\n\nhistory api提供浏览器修改历史记录功能。简单罗列下api的一些使用。\n\n```javascript\n// 返回上一个历史记录\nwindow.history.back()\nwindow.history.go(-1)\n\n// 前进一个历史记录\nwindow.history.forward()\nwindow.history.go(1)\n\n// 添加或者替换历史记录条目，注意这【并不会刷新页面】。\nhistory.pushState(state, title, url);\n// state：网址相关的状态Object，在popstate事件触发时，会在回调函数中接收到这个对象。不需要的话可以设为null。\n// title：新页面的title属性，填null。\n// url：新的页面地址，必须必须和上一个页面处于同域，否则抛出异常。\n\n// 替换当前的历史记录，注意这【并不会刷新页面】。\nhistory.replaceState(state, title, url);\n// 参数同上。\n```\n\n### 实现的思考\n\n1. 第一次尝试。既然要实现在落地页返回的历史，可不可以在短链中转页上监听一下上一页面的url，当然在跳转到落地页之前可以在落地页的url上带上参数，可以在短链中转页上通过是否带这个参数进行判断。放弃，理由是麻烦而且不稳定，可能出现难以预料的问题。\n\n2. 第二次尝试。使用历史记录api修改历史记录。要修改的页面是短链中转页的历史记录，需要替换【当前】短链中转页的历史，使得跳转到落地页到上一个历史是短链所配置到页面。\n\n需要注意到是，历史记录不能replace或者push不同域的url。所以需要通过一个queryString进行判断。所以做法是：\n```javascript\nwindow.onload = function() {\n      if (getParam('backUrl', location.href)) {\n        console.log('进入跳转到预定回退页')\n        location.replace(getParam('backUrl', location.href))\n      } else {\n        console.log('进入跳转到落地页并改写历史')\n        history.replaceState(null, null,  \"[域名、处理返回逻辑页面]?backUrl=https://www.baidu.com\")\n        document.getElementById('jump-id').click() // 跳转到落地页\n      }\n    }\n// getParam是获取链接qs参数的函数。\n```","bodyBegin":9,"frontmatter":"title: 修改浏览器回退历史\ndescription: 有个需求，需要修改短链跳转到落地页后，在落地页返回的历史记录。避免出现跳转到落地页后返回还是出现短链中转的问题。\nkeywords: 浏览器,回退历史，history api,pushState,replaceState\nlabels: ['前端']\ndate: 2019-04-12"}},{"title":"2019-04/project-down.md","path":"2019-04/project-down","slug":"2019-04_project-down","fmData":{"attributes":{"title":"项目突然跑不起来","description":"项目突然跑不起来","keywords":"node,dev,network,shadowsocks","labels":["前端"],"date":"2019-03-08T00:00:00.000Z"},"body":"## 突遇node建本地开发服务的项目跑不起来\n今天早上来上班，发现平时跑的一个项目突然跑不了。症状如下：\n1. command无任何异常。\n2. autoOpenBrowser正常，打开浏览器后一直转加载。\n3. console无任何报错。\n4. network仅有一个document处理一直pending的状态。\n5. 理应不是端口问题，如果端口被占用会自动选一个的。\n\n## 找问题\n1. 查看本机ip变了没有？\n2. 这个项目不行，再跑一个其他的同类项目，还是有这个问题？\n3. 重启个电脑试一下吧？\n4. 最后，问题是：`shadowsocks开了全局代理忘了关`。\n![WX20190401-093546](https://user-images.githubusercontent.com/21136420/55298682-903d2d00-5461-11e9-8c7f-6cdb66b0dea2.png)\n","bodyBegin":9,"frontmatter":"title: 项目突然跑不起来\ndescription: 项目突然跑不起来\nkeywords: node,dev,network,shadowsocks\nlabels: ['前端']\ndate: 2019-03-08"}},{"title":"2019-03/hackintosh.md","path":"2019-03/hackintosh","slug":"2019-03_hackintosh","fmData":{"attributes":{"title":"黑苹果计划","description":"小米笔记本 13.3 指纹版 i5 7200U；目标系统：macOS High Sierra 10.13","keywords":"hackintosh,xiaomi,sierra 10.13,i5 7200U,13.3,macos","labels":["折腾"],"date":"2019-03-08T00:00:00.000Z"},"body":"![macos-high-sierra](https://user-images.githubusercontent.com/21136420/53999869-1a0a1b00-4180-11e9-8c8b-8b564e12ff99.jpg)\n__看到米本现在黑苹果貌似可以挺稳定的工作，所以想折腾的心就沸腾起来了。也为了方便前端开发！__\n## 机器\n\n小米笔记本 13.3 指纹版 i5 7200U；目标系统：macOS High Sierra 10.13\n\n## 前期工作\n\n由于原本在windows上进行开发，还有之前装过windows和mint的双系统，所以现在的状态是GNU 启动。前期有很多的工作要做，是否要重新格盘安装也是未知数。现在前期工作的基本流程是：移除linux分区，移除GNU引导启动，进行备份工作。以上有风险的是：\n1. 完全移除linux，稍有不慎可能就启动不了两个系统了。自己在处理这部分的知识不是很足，所以谨慎为妙。\n2. 备份工作使用移动硬盘进行备份，主要是工作文档的备份。下面会罗列在windows上进行备份的一些软件链接和配置等。\n\n## windows软件配置列表\n\n- [Google Chrome](https://www.google.com/chrome/)\n- Adobe Photoshop CS6\n- [Axure RP8](https://www.axure.com/)\n- [Bandizip](https://cn.bandisoft.com/bandizip/)\n- [ConEmu](https://conemu.github.io/)\n- [Foxmail](https://www.foxmail.com/)\n- Git version\n- Go programming\n- KMPlayer\n- Logitech 游戏软件\n- Microsoft Office Professional Plus 2013\n- Microsoft Visual Studio Code \n- Mozilla Firefox\n- Node.js\n- PostgreSQL 11\n- PremiumSoft Navicat Premium\n- Fiddler\n- PuTTY\n- PxCook\n- Python 3.7.0\n- Ruby\n- TIM\n- TortoiseSVN\n- WinHTTrack Website Copier\n- XMind\n- Yarn\n- 火绒安全软件\n- 企业微信\n- 贴吧、网易云音乐、微信\n- 微信web开发者工具\n- 迅雷极速版\n- Shadowsocks\n\n## 主要进行开发配置备份\n\n__Chrome__:保证所有内容同步到谷歌服务器。\n__Logitech 游戏软件__:关闭鼠标背光，灯光设置-关闭标识。\n__Microsoft Visual Studio Code__:确保配置Settings Sync，保存gist以及token。\n__PuTTY__: IP:144.34.221.194 Port:28333 Connection type: SSH\n\n## 进度\n\n[教程链接](https://blog.str-mo.com/tech/217/)\n- 数据备份------ 0%\n- 安装准备 ------ 10%，已刻录mac os镜像\n- 原系统处理 ------ 0%\n\n## 关于esp(EFI)分区的扩容\n\n如果是win10和黑果双系统的话，需要保证安装黑果的硬盘内的esp分区大小不小于200M。而win10一般都是100M，所以就必须要进行esp扩容，否则没法对硬盘进行抹除操作。对于这部分，我昨天查了不少的资料，属于点门外汉吧。经过测试，一般的做法是：\n1. 在windows下，打开DiskGenius。在windows自带的磁盘管理上，分出一个未分配的磁盘空间，大小够200M即可（压缩卷）。在未分配的磁盘上新建一个esp分区（右键未分配的分区，点击新建分区，后选EFI那个选项），大小为未分配磁盘空间的大小，保存。\n2. 在DiskGenius下，浏览原esp分区的文件，将原来的文件复制到桌面，再从桌面复制到新的esp分区上。然后删除原来的100M的esp分区，保存，重启还是可以进入windows的。  \n到此，esp分区扩容就完成了。接着按教程走就行。\n\n## 镜像说明\n\n字节莫的镜像存在无法选择Apple安装的问题，在黑果小兵的博客上找到这个镜像的发布说明。[镜像地址](https://blog.daliansky.net/macOS-High-Sierra-10.13.6-17G65-Release-Version-with-Clover-4596-original-mirror.html)。\n里面有对这个问题进行说明：  \n> 重要提示：由于CLOVER新版的缘故，原来的HD3000/HD4000的配置文件不支持新版，会造成进CLOVER后卡住的情况，请降低CLOVER版本，或者直接删除掉所有的HD3000/HD4000开头的配置文件；\n\n按照上面引用的做法，就不用字节莫的efi文件了，直接用原来的efi然后删除上面的配置文件。删除文件的方法不用说了吧。接着重启就可以选择苹果进入安装了。\n\n## 替换驱动\n\n在mac系统内操作，用访达打开字节莫或者其他好的EFI，依次找路径：EFI-CLOVER-kexts-other文件夹，里面有很多驱动。\n1. 触摸板驱动：`ApplePS2SmartTouchPad.kext`。效果：触摸板ok。  \n\n将驱动拖动到Kext Utility，不要拖几次，一次就行，只是有其他加载工作在，等到第二次输入密码的时候就是安装的时候。  \n安装后重启驱动效果就有了。\n\n我试了两个ALC的驱动都不能驱动声音。。如果有知道的可以提一下。\n亮度也不敢弄，怕显卡驱动不好开不到机，目前配置好了很多开发工具，不大敢冒险了。  \n目前亮度的调节是用App Store里面的`Brightness slider`进行调节。治标不治本！\n\n2. 声卡解决：\n下载下面这个声卡驱动。按上面一楼的安装方法，完成后重启就行。\n链接: https://pan.baidu.com/s/1pkaaUN3hCbxJhkVhX4kn9w 提取码: kiur \n3. 其他：  \n如果发现耳机杂音，可以在设置-输出-将平衡拖动到最左或者最右即可。","bodyBegin":9,"frontmatter":"title: 黑苹果计划 \ndescription: 小米笔记本 13.3 指纹版 i5 7200U；目标系统：macOS High Sierra 10.13\nkeywords: hackintosh,xiaomi,sierra 10.13,i5 7200U,13.3,macos\nlabels: ['折腾']\ndate: 2019-03-08"}},{"title":"2019-02/new-year.md","path":"2019-02/new-year","slug":"2019-02_new-year","fmData":{"attributes":{"title":"新的一年，加油","description":"新的一年，加油","keywords":"new year,新的一年","labels":["随笔"],"date":"2019-02-10T00:00:00.000Z"},"body":"![cover](https://media.socastsrm.com/wordpress/wp-content/blogs.dir/348/files/2019/01/crop635w_college-scholarships-2019-edition.jpg)\n\n过去2018年，是自己进步非常大的一年。进了新的公司，认识一批新的同事。在众多的业务中能得到不少的帮助。自己也趁机学习和实践了很多的开发技术，最多而且最有印象的就是小程序的开发了。上一年的进步离不开自己对开源和技术的热爱，以及同事之间的帮助，当然很重要的是有不错的感情寄托。\n\n在慢慢的进步中，来到了2019年，我的本命年。\n\n很不幸，遇到了比较大的打击，导致心态崩溃了吧😭。\n\n往后的生活工作还是需要自己好好把握好好争取，有些事情需要自己去挖掘去熟悉，这样才会成长起来。很重要的一部分就是需要自己的自律，外加就是有计划的生活了。\n\n我在知乎上也写了一些关于自己在2019上的学习计划，其中TS和Flutter是自己需要好好学习的，尤其是TS需要跟着Vue 3.0的发布而运用到项目中。对于偏后端的应用上，会主动的学习Egg.js，最好是能找机会能在项目中应用上。\n\n开年的打击还是会伴着我一段比较长的时间，但生活还得继续，自己的坚持还要持续下去，无论多难，身边总会有朋友，家人的鼓励支持，这将是我2019年甚至是往后很重要的支柱了。\n\n2019年，给猪年的自己，加一份油😁。\n","bodyBegin":9,"frontmatter":"title: 新的一年，加油\ndescription: 新的一年，加油\nkeywords: new year,新的一年\nlabels: ['随笔']\ndate: 2019-02-10"}},{"title":"2019-01/chrome-provisional-header.md","path":"2019-01/chrome-provisional-header","slug":"2019-01_chrome-provisional-header","fmData":{"attributes":{"title":"chrome出现Caution provisional headers are shown的问题","description":"chrome出现Caution provisional headers are shown的问题","keywords":"chrome,caution,provisional,headers are shown","labels":["前端"],"date":"2019-01-07T00:00:00.000Z"},"body":"开发的一个项目出现一个Caution：\n```bash\nCaution provisional headers are shown\n```\n注：这个提示出现在chrome开发者工具的每一个接口请求上。这也只是个警告，还要理它干啥？先看看Google“热搜”的第一个解答：\n[“CAUTION: provisional headers are shown” in Chrome debugger](https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger)\n“请求被阻塞，东西发不出去，自然没有东西回来”  \n在答者那的例子他说是被adblock拦截了。\n\n## 问题\n\n在项目上线的这段时间内，前期由于使用的少，并未将问题暴露出来，后面使用的人数多了之后，就会出现一个高概率的事情：\n**个别接口请求一直处于pending状态，数据无法回流**  \n这个问题比较严重，后面一直在找解决方案。我的思路历程是：\n1. 一开始发现这个问题的时候，有些不可思议，第一次遇到，如果这是一个普遍的问题，为啥又只会出现在个别接口（非固定的个别接口）？\n2. 调试工具出现`provisional headers are shown`的警告，瞄准这个警告入手。找到了大量相关的问题描述和方法，在前端这边的处理都未解决。在拦截器修改头，在`net-internals`抓起日志等就差在每个请求后加上时间戳了（怀疑是前端缓存cache出现异常）。\n3. 开始怀疑是后端的问题。与后端商量后，在日志打印那发现每一个请求返回都在几毫秒内。当然这个好像没有什么参考性，因为前端貌似这边请求并未成功发出。\n4. 发现除chrome默认模式外，其它浏览器比如firefox、Edge都没这个问题。甚至在chrome无痕模式也没有这个问题。这时候觉得解决问题比找到原因更重要了（因为已经上线了）。\n5. 经过后端前端的协调与商量，发现这大概率是因为前后端跨域而出现的问题。\n\n## 解决\n\n**设置请求接口与静态文件处于同源状态（需要nginx配置），警告消失，经过一段时间观察，问题解决。**","bodyBegin":9,"frontmatter":"title: chrome出现Caution provisional headers are shown的问题\ndescription: chrome出现Caution provisional headers are shown的问题\nkeywords: chrome,caution,provisional,headers are shown\nlabels: ['前端']\ndate: 2019-01-07"}},{"title":"2018-12/koa-async.md","path":"2018-12/koa-async","slug":"2018-12_koa-async","fmData":{"attributes":{"title":"koa异步写文件遇到的小问题","description":"最近用koa写个微信小程序二维码生成接口，出现了一个小坑：由于小程序二维码生成接口返回的是二进制流，需要通过fs操作生成图片返回给前端下载。期间反复出现下载文件大小为0（零 / 大小未知）的情况。","keywords":"koa,async,file","labels":["前端"],"date":"2018-12-13T00:00:00.000Z"},"body":"![koa](https://github.com/koajs/koa/raw/master/docs/logo.png)\n最近用koa写个微信小程序二维码生成接口，出现了一个小坑：由于小程序二维码生成接口返回的是二进制流，需要通过fs操作生成图片返回给前端下载。期间反复出现下载文件大小为0（零 / 大小未知）的情况。  \n\n**主要生成二维码代码如下**\n\n```javascript\n// 其余代码省略\nconst writeS = fs.createWriteStream('qrcode.png')\nawait request({\n  uri: `https://api.weixin.qq.com/wxa/getwxacode?access_token=${token}`,\n  method: 'post',\n  body: data,\n  json: true\n}).pipe(writeS)\n// 其余代码省略\n```\n需要有个先后顺序问题，必须先等到文件写完后才能进行图片下载接口调用。处理方法是在前端调用生成二维码的接口，而接口的操作需要有个等待过程，即要在`createWriteStream`结束后**生成二维码接口**才返回数据。  \n\n前端在接收到**生成二维码接口**返回数据后才调用下载二维码接口。  \n\nkoa端等待写文件结束后返回，这里koa要用promise在callback后触发返回数据：\n\n```javascript\n ctx.body = await new Promise((resolve, reject) => {\n    writeS.on('finish', function () {\n      resolve({\n        code: 1\n      })\n    })\n  })\n```\n前端监听操作：\n\n```javascript\nif (res.data.code === 1) {\n  window.open('图片下载地址')\n}\n```\n\n具体接口代码（[查看](https://github.com/GzhiYi/wxqrcode-generater/blob/master/index.js)）","bodyBegin":9,"frontmatter":"title: koa异步写文件遇到的小问题\ndescription: 最近用koa写个微信小程序二维码生成接口，出现了一个小坑：由于小程序二维码生成接口返回的是二进制流，需要通过fs操作生成图片返回给前端下载。期间反复出现下载文件大小为0（零 / 大小未知）的情况。\nkeywords: koa,async,file\nlabels: ['前端']\ndate: 2018-12-13"}},{"title":"2018-12/es6-module.md","path":"2018-12/es6-module","slug":"2018-12_es6-module","fmData":{"attributes":{"title":"ES6 Module语法小结","description":"ES6 Module语法小结","keywords":"es6,ES6,module","labels":["前端"],"date":"2018-12-12T00:00:00.000Z"},"body":"## `export`\n\n1. 输出变量。\n\n```javascript\nexport const name = 'GzhiYi';\nexport const job = 'Frontend';\n```\n以上可简写（荐）：\n```javascript\nconst name = 'GzhiYi';\nconst job = 'Frontend';\n\nexport { name, job };\n```\n2. 输出函数或者类`class`。\n\n```javascript\nexport function exportMe () {}\nexport class exportMeToo {}\n```\n\n3. 关键字`as`重命名输出。\n\n```javascript\nconst name = 'GzhiYi';\nconst job = 'Frontend';\n\nexport {\n   name as changeName,\n   job as changeJob  \n};\n```\n\n## `import`\n\n1. 导入`export`输出的接口。\n\n```javascript\nimport { name, job } from 'filePath';\n// import 进来的变量均是readOnly，也不建议改写引入的其它类型数据。\n```\n2. 关键字`as`重命名输入。\n\n```javascript\nimport { name as changName } from 'filePath';\n```\n\n## 整体引入\n\n```javascript\n// 假设demo.js文件有如下内容\nfunction funA () {}\nfunction funB () {}\n\nexport { funA, funB };\n\n// 平常加载\nimport { funA, funB } from './demo';\n\n// 整体引入\nimport * as allFun from './demo';\nallFun.funA();\nallFun.funB();\n```\n\n## `export defalut` 指定默认输出\n\n```javascript\n// demo.js\nexport default function () {};\n\n// 引入\nimport funName from 'demo'; \n// 不需要知道封装demo.js包含的函数名，import后无需接大括号，因为默认输出的只有一个。\n```\n","bodyBegin":10,"frontmatter":"title: ES6 Module语法小结\ndescription: ES6 Module语法小结\nkeywords: es6,ES6,module\nlabels: ['前端']\ndate: 2018-12-12"}},{"title":"2018-11/git-usage-in-work.md","path":"2018-11/git-usage-in-work","slug":"2018-11_git-usage-in-work","fmData":{"attributes":{"title":"git在工作中的一些用处","description":"git内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。","keywords":"git,工作中,用处,git工作流,分支,git rebase,git merge","labels":["学习"],"date":"2018-11-28T00:00:00.000Z"},"body":"![banner](https://images.vrm.cn/2018/11/26/banner.png)\n\n本周四分享会主题：__git在工作中的一些用处__。  \n\ngit内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。**基本的概念不会多说**，都能在入门教程那些学习到。接下来会说下git在工作中比较常用的功能，会发现，其实git能做的事情还是非常多的。\n\n### git在开发中常用的命令\n__编辑和代码提交__\n\n```bash\n# 为git初始化一个代码库\ngit init\n\n# 将目录的所有文件提交到暂存区\ngit add .\n\n# 提交暂存区到代码仓库区，并添加提交信息\ngit commit -m \"commit message\"\n```\n\n__分支处理__\n\n```bash\n\n# 列出本地所有的分支\ngit branch\n\n# 列出远程仓库的所有分支\ngit branch -r\n\n# 列出仓库的所有分支（包含远端和本地分支）\ngit branch -a\n\n# 切换到指定分支，并更新工作区\ngit checkout [branchName]\n\n# 新建一个分支并切换到该分支\ngit checkout -b [branchName]\n\n# 删除一个分支\ngit branch -d [branchName]\n\n# 强制删除一个分支\ngit branch -D [branchName]\n```\n\n__查看状态信息__\n\n```bash\n# 查看变更的文件，可多用这个命令查看当前文件改动状态\ngit status\n\n# 查看当前分支提交历史，可以得到加密的commit_id\ngit log\n\n# 查看暂存区和工作区的对比\ngit diff\n```\n\n__同步远程仓库__\n\n```bash\n# 同步远程仓库的所有更新\ngit fetch [remote]\n\n# 显示所有远程仓库\ngit remote -v\n\n# 增加一个新的远程仓库，并定义一个远程仓库名，shortName常用origin，当然可自定义\ngit remote add [shortName] url\n\n# 拉取远端分支，并与本地分支合并\ngit pull [remote] [branchName]\n\n# 上传本地分支到远端\ngit push [remote] [branchName]\n```\n\n__撤销操作__\n\n```bash\n# 恢复暂存区的指定文件到工作区\ngit checkout [file]\n\n# 恢复暂存区的所有文件到工作区\ngit checkout .\n\n```\n\n![image](https://user-images.githubusercontent.com/21136420/49006081-37a00f80-f1a3-11e8-982e-c02cd71c1495.png)\n\ngit工作中常用命令基本可以上图概括。\n________\n\n__其它常用的命令__\n单独拿出来说是因为平常知道用的可能不会很多，但实际用起来会非常有用。\n\n1. `git stash`\n\n当你在工作的时候，累计了比较多的改动，但是突然间需要临时切换到其它分支工作，可是又不好把中途工作的内容提交，那怎么办？这时候git stash就有用了。\n\n```bash\n# 查看文件变更状态\ngit status\n\n# 储藏变更，这时候会提示已储藏变更\ngit stash\n\n# 当在其它分支工作完回到原来分支的时候，可以查看储藏列表\ngit stash list\n\n# 恢复储藏，这时候文件变更就回来了，listNum为列表序号\ngit stash apply stash@{listNum}\n```\n\n2. `git rebase`\n\n一般我们完成代码后，需要将分支的改动进行整合，会用到合并（merge）操作，但这不是唯一的方式，Rebase就是其中的代替方式。  \n先来说说merge。我们在需要合并的时候，会有如下的两种基本情况： \n\n![情况1](https://images.vrm.cn/2018/11/27/starting-situation-fast-forward.gif)\n其中一个分支没有新的改动，而另一个分支却有改动。这个时候进行整合的话，git仅仅只是添加所有改动的分支的新提交即可。\n\n![情况2](https://images.vrm.cn/2018/11/27/starting-situation-merge-commit.gif)\n第二种就是我们开发过程经常遇到的情况，两个分支都有不同的开发轨迹。为了完成合并，git会创建一个新的提交来涵括它们之间的差异，这就是整合提交。\n\n有人不喜欢这个合并的方式，希望项目有一个单一的开发轨迹，在流程上是一条直线，不希望在开发历史记录上看到被分成过多个分支。这时候就可以用到rebase操作了。\n\n我们还是看第一个例子：\n\n![情况1](https://images.vrm.cn/2018/11/27/starting-situation-fast-forward.gif)\n如果我们想合并分支B到A分支上，可以用到下面这个命令：\n\n```bash\ngit rebase branchB\n```\n\ngit会进行这样的操作：  \n“撤销”所有分支A上与分支B开发分叉后的更改，这并不是真的checkout掉更改，后面还会用到。\n![rebase1](https://images.vrm.cn/2018/11/27/rebase-step-1.gif)\n\n然后它将整合分支B上的提交到A上，这要看，分支A和分支B就会像一条线一样。\n![rebase2](https://images.vrm.cn/2018/11/27/rebase-step-2.gif)\n\n最后，在分支A上的那些新的提交会被重新应用回来。\n![rebase3](https://images.vrm.cn/2018/11/27/rebase-step-3.gif)\n\n3. `git reset`和`git revert`\n\n开发期间难免会有提交出错代码的情况，如何进行版本回退呢？git reset命令就派上用场了.  \n- git reset 为重置提交，可以将版本回退到某一个commit记录上。git reset 命令后面是需要加2种参数的：–-hard 和 –-soft。这条命令默认情况下是 -–soft。  \n__区别：__\n\n默认参数 -soft,所有commit的修改都会退回到git暂存区。\n参数--hard，所有commit的修改直接丢弃，小心用。\n\n```bash\ngit reset --hard commit_id\ngit push origin [branchName] --force\n```\n当然如果--hard错了，也还有救，`git reflog`命令记录你的所有git操作，能获取到原有的移除掉的commit_id。\n\n- git revert 为还原提交，可以将某个commit还原然后创建一个新的还原commit。字面意思已经很好理解了。比如：\n\n```bash\n# 某个commit的文件a增加两行文字\n\ngit revert commit_id\n\n# 执行该命令后，还原了这个commit文件a的更改，新增一个revert的commit，更改为增加的两行文字被移除。\n```\n\n### git工作流\n\n这里只说下最广泛应用的git工作流，也就是git flow。  \n在开发的初期，我们定两个分支：\n\n- __主分支master__\n- __开发分支develop__\n\n规定，master分支为版本发布的分支，提供上线的版本。develop分支为日常开发分支，存放最新的开发版本。一般的develop分支会切出如下的三个短期分支：\n\n1. 功能分支（feature）\n2. 修bug分支（hotfix或者fix）\n3. 预发布分支（release）\n\n**还有其它工作流？**\n\n当然有！下面就继续说一个挺不错的工作流：  \n\n> 功能分支工作流  \n\n这个工作流的核心思路是所有的功能开发都应该独立一个分支，而主分支一样是master。这样的隔离开发不会扰乱主分支上的代码，也能保证主分支的代码准确无误。\n\n这种方式让pull request变得更加有效果。过多的就不解释，通过一个例子看看这个工作流到底是如何工作的。\n\n__小红开始开发一个新功能__  \n理所当然，从master切出一个独立功能分支：\n\n```bash\ngit checkout -b feature-new master\n```\n\n持续打码，中途完成部分:\n\n```bash\ngit status\ngit add [file]\ngit commit -m 'xxx'\n```\n\n__中午去吃个饭__  \n在吃午饭前，小红把自己的功能分支推到了远端仓库。好习惯，多学习。\n\n```bash\ngit push origin feature-new\n```\n\n__小红完成开发__\n在合并之前，小红保证远端仓库有自己功能分支的最新代码。\n\n```bash\ngit push origin feature-new\n```\n\n接下来，可以发起一个合并请求，在github或者gitlab都有快捷的合并请求操作。合并功能分支feature-new到master。发起后，团队都可以收到合并请求的通知。\n\n这时候团队可以code review，有问题就可以继续提示小红去修正。\n\n修正后小红可以持续推代码到功能分支，commit记录也会一并出现在pull request处。\n\n__小红发布功能__  \n经过紧张的讨论修改，终于完成功能开发，要发布功能：\n\n```bash\ngit checkout master\ngit pull\ngit pull origin feature-new\ngit push\n```\n完毕。\n\n### 还能怎么发挥git作用？\n\n__webhooks__\n\n根据github的介绍，webhooks可以通过使用github的事件被触发时通过http post的形式调用服务器上的接口，服务器接受到推送事件之后就可以执行构建，更新项目代码，进而部署生产服务器等等。\n\n> 这一切能限制的只有你的想象力。\n\n一般而言，比如说我部署一个node程序到服务器上需要怎么操作？\n\n1. 本地代码开发完毕，准备上线，上传本地代码到git远端仓库。\n\n2. ssh连接远程服务器，登录管理员账号密码后进入命令行界面。\n\n3. 进入项目目录，拉取最新提交的代码。\n\n4. 执行部署操作。\n\n5. 需要代码更新，重复此操作。\n\n__而我通过webhooks之后，这些操作得到很大的简化。__\n\n1. 配置webhooks的push事件，因为我要在本地push代码后执行后续操作。\n\n![image](https://user-images.githubusercontent.com/21136420/49086433-78755280-f28f-11e8-98ee-a1279e427c8e.png)\n\n2. 在服务器上编写一个自动部署脚本，这里举个简单的脚本`deploy.sh`。\n\n```bash\n#！/bin/bash\necho 'enter project'\ncd [your project dir]\n\necho 'pull code'\ngit pull origin master\n\necho 'deploy'\npm2 start deploy.js\npm2 logs deploy\n\necho 'deploy finished'\n```\n\n3. 用node写一个监听接口，不一定要node，只要能跑出个接口能监听到事件即可。需要提到：\n\n```javascript\nconst createHandler = require('node-github-webhook')\nconst config = {\n  path: '/hook',\n  secret: 'your srcret'\n}\nconst handler = createHandler(config)\n...\n\nhandler.on('push', function (event) {\n  execFunc('sh ./deploy.sh')\n})\n\n```\n这里的path和secret都需要在github webhooks那边对应配置上。\n\n4. 完成之后，一旦代码提交到master的话，就会触发事件，然后自动执行后续操作。\n\n### git工具推荐\n\n有几个个人认为不错的git工具或者项目可以提高git的使用。\n\n1. [gitignore](https://github.com/github/gitignore)。在项目根目录新建一个`.gitignore`文件，将不需要提交到git上的文件路径添加到这个文件。在这个项目中可以快速找到自己所属项目的通用gitignore文件\n\n![gitignore](https://images.vrm.cn/2018/11/27/微信截图_20181127222540.png)\n\n2. [`VS Code`] gitignore。可以右键将文件夹或者文件添加到.gitignore文件中。\n\n![gitignore](https://images.vrm.cn/2018/11/27/微信截图_20181127222733.png)\n\n3. [`VS Code`] GitLens。可以让每一行代码都显示历史记录等。\n\n![Gitlens](https://images.vrm.cn/2018/11/27/微信截图_20181127223043.png)\n\n4. [`Chrome`] octotree。浏览github上的代码更加轻松便捷。\n\n![octotree](https://images.vrm.cn/2018/11/27/微信截图_20181127223252.png)\n\n5. Sourcetree。git图形界面工具，讲了那么多命令应该可以不用图形界面了吧😀。\n![sourcetree](https://images.vrm.cn/2018/11/28/微信截图_20181128215137.png)\n\n### 最后\n分享内容大概如此了，欢迎补充，也希望内容有些帮助。😄\n\n> 参考\n> [Rebase 代替合并 ](https://www.git-tower.com/learn/git/ebook/cn/command-line/advanced-topics/rebase)\n> [git 工作流-阮老师的](http://www.ruanyifeng.com/blog/2015/12/git-workflow.html)\n> [git 工作流](https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md)","bodyBegin":9,"frontmatter":"title: git在工作中的一些用处\ndescription: git内容有非常多，如果要每个命令都去熟悉和记忆的话，我觉得是没有必要的，掌握基本的用法，在团队合作中能快速定位问题和解决才是重要的。\nkeywords: git,工作中,用处,git工作流,分支,git rebase,git merge\nlabels: ['学习']\ndate: 2018-11-28"}},{"title":"2018-11/qiniu-download-pic.md","path":"2018-11/qiniu-download-pic","slug":"2018-11_qiniu-download-pic","fmData":{"attributes":{"title":"七牛回收测试域名后，下载图片","description":"月中就收到了七牛测试域名被回收的邮件。没多瞥几眼，直接拖到了过期时间，错过了下载图片的时间。","keywords":"七牛,qiniu,下载,图片,域名回收,windows","labels":["前端"],"date":"2018-11-22T00:00:00.000Z"},"body":"![_20181122152425](https://user-images.githubusercontent.com/21136420/48887594-d3134680-ee6a-11e8-9721-b46722c63f88.png)\n\n## 测试域名回收\n\n月中就收到了七牛测试域名被回收的邮件。没多瞥几眼，直接拖到了过期时间，错过了下载图片的时间。\n\n现在考虑不用hexo那个github pages了，转移到github issue区进行记录。博客嘛，不搞花里胡巧了，issue几乎满足所有要求。对于图片挂了这回事，还是要处理的，所以找了下补救措施，也在这记录下。\n\n## 主要步骤（系统环境Windows）\n\n1. 在对象存储处，新建一个新的存储空间，假设名为`backup`，过期的空间名为`images`。注意存储区域选择和原有过期空间一致。\n2. 下载[qshell](https://github.com/qiniu/qshell)。下载解压后应该包含以下几端的qshell文件（以下载回来的文件为主）。\n![image](https://user-images.githubusercontent.com/21136420/48888437-aa408080-ee6d-11e8-8a4b-ab02b58a6f7d.png)\n3. 根据对于系统选择对应的qshell文件。注意windows不要双击打开，应该在该目录处打开shell脚本，输入文件名代替qshell命令。\n\n查看qshell版本检查qshell是否可用：\n![image](https://user-images.githubusercontent.com/21136420/48888591-2f2b9a00-ee6e-11e8-8732-14a97de2baac.png)\n\n4. 按以下命令格式配置七牛账号信息，注意命令包含AK（access_key）、SK（secret_key）以及账户名（注册邮箱）。\n```bash\n qshell_windows_x64.exe account AK SK NAME\n```\n![image](https://user-images.githubusercontent.com/21136420/48888794-c133a280-ee6e-11e8-9edb-db6b3db9188c.png)\n[命令account参考](https://github.com/qiniu/qshell/blob/master/docs/account.md)\n\n5. 导出图片信息列表到txt文件。\n```bash\nqshell_windows_x64.exe -v  listbucket images -o tocopy.txt\n```\n[命令listbucket参考](https://github.com/qiniu/qshell/blob/master/docs/listbucket.md)\n完成后，tocopy.txt就包含了原有过期空间images的所有文件信息。\n\n6. 只保留tocopy.txt每行内的文件名，其余的去掉。\n\n7. 使用batchcopy命令迁移。\n```bash\nqshell_windows_x64.exe -v  batchcopy images backup -i tocopy.txt\n```\n[命令batchcopy参考](https://github.com/qiniu/qshell/blob/master/docs/batchcopy.md)\n自此，空间文件迁移成功，可以到新空间查看图片或者下载图片了。\n","bodyBegin":9,"frontmatter":"title: 七牛回收测试域名后，下载图片\ndescription: 月中就收到了七牛测试域名被回收的邮件。没多瞥几眼，直接拖到了过期时间，错过了下载图片的时间。\nkeywords: 七牛,qiniu,下载,图片,域名回收,windows\nlabels: ['前端']\ndate: 2018-11-22"}},{"title":"2018-10/mp-countdown.md","path":"2018-10/mp-countdown","slug":"2018-10_mp-countdown","fmData":{"attributes":{"title":"用小程序做个动态倒计时","description":"最近由于业务需要，需要做一个倒计时的小插件，想想自己在很久以前用JavaScript写过，操作dom，很快就可以修改对应的数字了。现在换到小程序后，主要的还是去更改data的值，进而修改对应的图片。","keywords":"小程序,倒计时,编写","labels":["小程序"],"date":"2018-10-15T00:00:00.000Z"},"body":"### 写在前\n\n最近由于业务需要，需要做一个倒计时的小插件，想想自己在很久以前用JavaScript写过，操作dom，很快就可以修改对应的数字了。现在换到小程序后，主要的还是去更改data的值，进而修改对应的图片。  \n\n<!--more-->\n\n### 效果\n\n![counter](https://images.vrm.cn/2018/11/22/微信截图_20181122151328.png)\n具体：  \n\n- 精度为天时分秒\n- 初始时间可以从接口获取\n\n### 代码\n```html\n  <view class=\"counter\">\n    距离活动结束仅剩\n    <image bindload=\"showPicture\" class=\"clock\" mode=\"widthFix\" src=\"../../src/images/clock/num{{count.dayBegin}}.png\"></image>\n    <image bindload=\"showPicture\" class=\"clock\" mode=\"widthFix\" src=\"../../src/images/clock/num{{count.dayEnd}}.png\"></image>\n    天\n    <image bindload=\"showPicture\" class=\"clock\" mode=\"widthFix\" src=\"../../src/images/clock/num{{count.hourBegin}}.png\"></image>\n    <image bindload=\"showPicture\" class=\"clock\" mode=\"widthFix\" src=\"../../src/images/clock/num{{count.hourEnd}}.png\"></image>\n    时\n    <image bindload=\"showPicture\" class=\"clock\" mode=\"widthFix\" src=\"../../src/images/clock/num{{count.minuteBegin}}.png\"></image>\n    <image bindload=\"showPicture\" class=\"clock\" mode=\"widthFix\" src=\"../../src/images/clock/num{{count.minuteEnd}}.png\"></image>\n    分\n    <image bindload=\"showPicture\" class=\"clock\" mode=\"widthFix\" src=\"../../src/images/clock/num{{count.secondBegin}}.png\"></image>\n    <image bindload=\"showPicture\" class=\"clock\" mode=\"widthFix\" src=\"../../src/images/clock/num{{count.secondEnd}}.png\"></image>\n    秒\n  </view>\n```\n```javascript\n// 初始值\ntimer: null,\ndata: {\n  count: {\n    expireDate: 172800, // s\n    dayBegin: 0,\n    dayEnd: 0,\n    hourBegin: 0,\n    hourEnd: 0,\n    minuteBegin: 0,\n    minuteEnd: 0,\n    secondBegin: 0,\n    secondEnd: 0\n  }\n}\n\n// 接口回调处\nlet { count } = this.data\ndelele count[`expireDate`] // 删除原count中的expireDate\nthis.setData({\n  ...count,\n  expireDate: newExpireDate\n})\nthis.timer = setInterval(function() {\n  let expireDate = this.data.count.expireDate - 1\n  this.setData({\n    count: {\n      dayBegin: this.convertTime(expireDate)[0][0],\n      dayEnd: this.convertTime(expireDate)[0][1],\n      hourBegin: this.convertTime(expireDate)[1][0],\n      hourEnd: this.convertTime(expireDate)[1][1],\n      minuteBegin: this.convertTime(expireDate)[2][0],\n      minuteEnd: this.convertTime(expireDate)[2][1],\n      secondBegin: this.convertTime(expireDate)[3][0],\n      secondEnd: this.convertTime(expireDate)[3][1],\n      expireDate,\n    }\n  })\n}, 1000)\n\n/**\n * 时间转化函数，时间戳入参为秒\n*/\nconvertTime: function (sec) {\n  let time\n  if (sec > -1) {\n    let hour = Math.floor(sec / 3600)\n    let min = Math.floor(sec / 60) % 60\n    let second = sec % 60\n    let day = parseInt(hour / 24)\n    hour = hour - 24 * day\n    hour = hour < 10 ? `0${hour}` : hour\n    time = day < 10 ? `0${day}:${hour}:`: `${day}:${hour}:`\n    if (min < 10) {\n      time += \"0\"\n    }\n    time += min + \":\";\n    if (second < 10) {\n      time += \"0\"\n    }\n    time += second\n    return time.split(':') // 返回一个包含天时分秒的数组\n  }\n}\n// 最后不要忘记在周期销毁处清空计时器\nonUnload: function () {\n  clearInterval(this.timer)\n}\n```\n```javascript\n// 时间转 **前的函数\n  getDateDiff: function(dateTimeStamp){\n    let result = ''\n    let minute = 1000 * 60\n    let hour = minute * 60\n    let day = hour * 24\n    let halfamonth = day * 15\n    let month = day * 30\n    let now = new Date().getTime()\n    let diffValue = now - dateTimeStamp\n    if(diffValue < 0) { return; }\n    let monthC = diffValue / month\n      let weekC = diffValue / (7 * day)\n      let dayC = diffValue / day\n      let hourC = diffValue / hour\n      let minC = diffValue / minute\n      if(monthC>= 1){\n    result = \"\" + parseInt(monthC) + \"月前\"\n    }\n      else if (weekC >= 1) {\n      result = \"\" + parseInt(weekC) + \"周前\"\n    }\n    else if (dayC >= 1) {\n      result = \"\" + parseInt(dayC) + \"天前\"\n    }\n    else if (hourC >= 1) {\n      result = \"\" + parseInt(hourC) + \"小时前\"\n    }\n    else if (minC >= 1) {\n      result = \"\" + parseInt(minC) + \"分钟前\"\n    } else\n      result = \"刚刚\"\n    return result\n  },\n```\n### 最后\n相关思路适用于所有mvvm框架。","bodyBegin":9,"frontmatter":"title: 用小程序做个动态倒计时 \ndescription: 最近由于业务需要，需要做一个倒计时的小插件，想想自己在很久以前用JavaScript写过，操作dom，很快就可以修改对应的数字了。现在换到小程序后，主要的还是去更改data的值，进而修改对应的图片。 \nkeywords: 小程序,倒计时,编写\nlabels: ['小程序']\ndate: 2018-10-15"}},{"title":"2018-10/month-pass.md","path":"2018-10/month-pass","slug":"2018-10_month-pass","fmData":{"attributes":{"title":"不知不觉一个月了","description":"很忙。最近在业务上花的时间很多，公司内有一批业务陆陆续续到来，只好花了时间去做好来。也就大半个月的时间吧，有了很多的事情，我也没有常来这里看看，所以就遗忘了。心想也是，在Google、Baidu都很难搜索到我的帖子所以不管了吧。当作自己的一个小地方得了。","keywords":"不知不觉一个月了","labels":["随笔"],"date":"2018-10-15T00:00:00.000Z"},"body":"### 上一篇发布于2018-08-20 \n\n很忙。最近在业务上花的时间很多，公司内有一批业务陆陆续续到来，只好花了时间去做好来。也就大半个月的时间吧，有了很多的事情，我也没有常来这里看看，所以就遗忘了。\n心想也是，在Google、Baidu都很难搜索到我的帖子所以不管了吧。当作自己的一个小地方得了。\n\n### 技术栈\n\n说一下最近在前端的实践：Jquery Vue 小程序之间来回切换，自身所负责的前端项目大概有3~4个，逐渐的对这样的开发情况熟悉起来了。最近小程序开放了云开发后台，非常\n感兴趣，在打开vscode去实践的时候，猛然发现博客没写好久了，所以就上来写两句。待会就去实践云开发啦。  \n![微信截图_20180913213730](https://images.vrm.cn/2018/11/22/微信截图_20180913213730.png)\n\n### Infinite\n未来会更好，专注前端开发。多接触好的技术，创造无限。\n![微信图片_20180913213837](https://images.vrm.cn/2018/11/22/微信图片_20180913213837.jpg)","bodyBegin":10,"frontmatter":"title: 不知不觉一个月了\ndescription: 很忙。最近在业务上花的时间很多，公司内有一批业务陆陆续续到来，只好花了时间去做好来。也就大半个月的时间吧，有了很多的事情，我也没有常来这里看看，所以就遗忘了。心想也是，在Google、Baidu都很难搜索到我的帖子所以不管了吧。当作自己的一个小地方得了。\nkeywords: 不知不觉一个月了\nlabels: ['随笔']\ndate: 2018-10-15"}},{"title":"2018-10/h5-step.md","path":"2018-10/h5-step","slug":"2018-10_h5-step","fmData":{"attributes":{"title":"一次h5开发踩坑记录","description":"这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。","keywords":"h5,踩坑,vue,vux","labels":["前端"],"date":"2018-10-15T00:00:00.000Z"},"body":"### 时间\n这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。\n\n### 使用框架\n\n原本想直接了当用jQuery，毕竟用jQuery开发是真的快而且紧急情况可控。缺点是写起来会比较乱，维护也比较麻烦。但最后还是放弃，想尝试新的技术。最后试用了几套框架|库后，决定使用vux进行编写。\n<!--more-->\n### Vux\n![tim 20181015093748](https://user-images.githubusercontent.com/21136420/48887191-5af85100-ee69-11e8-84e9-fc534223e75b.png)\n\n使用原因：  \n\n1. 使用vue-cli构建，几乎不用配置其余东西，内建命令让开发和打包生产版十分便捷。\n2. vux有大量组件而且github上有非常多的issue记录，遇到问题可以快速定位解决。\n3. vue生态给力，写起来舒舒服服。\n\n### 主要坑\n\n由于第一次用vux写h5，难免会遇到不少问题，不仅是框架本身的问题，还有其他业务上需要攻克的问题。就记录下踩过的坑：\n\n- background-image在部署的时候路径不对。\n\n修改vue-cli的build文件夹下的utils.js为如下：\n![util](https://user-images.githubusercontent.com/21136420/48887225-7b281000-ee69-11e8-85a0-6e465667d9c4.png)\n\n这样在 CSS 中：background-image: url(\"./assets/bg.jpg\")，不管是在开发环境下还是在生产环境下，背景图都可以读出来\n\n- 怎么生成图片并在微信端支持长按保存图片？  \n\n以前也做过类似的，但没做过微信支持长按保存图片的。首先当然是要用到将html转为canvas然后再考虑转为图片。\n\n1. 库：[html2canvas](https://html2canvas.hertzen.com/documentation)\n2. 用法非常简单，指定挂载的元素进行转化。\n\n```javascript\nhtml2canvas(document.body).then((canvas) => {\n    console.log(canvas);    // 这个是生成的canvas\n    const base64Code = canvas.toDataURL(\"image/png\");    //将生成的canvas通过api`toDataURL`转为base64格式图片。\n});\n```\n\n- 怎么保存图片？\n\n不是已经生成图片了吗？生成就可以可以保存了。没错，但是业务问题，在生成的图片上还要包含可点击的按钮和一个超链接。可以想到，可以将按钮和超链接定位到生成的图片上。可是存在这样的问题，不同的移动端呈现的结果可能不一致，这会直接导致页面显示出现问题，进而影响使用体验。这种覆盖的想法最后放弃了。\n\n最后的做法：将生成的图片的透明度设置为0覆盖到原本要渲染的元素上，然后提高可点击按钮的层级。\n![tim 20181015100607](https://user-images.githubusercontent.com/21136420/48887259-95fa8480-ee69-11e8-8564-ddbccc8f1e26.png)\n\n- 存在无法分享到朋友圈的问题\n\n微信浏览器唤起的分享菜单，存在点击分享到朋友圈出现卡死问题。\n排查过程： 在页面操作第一步和第二步都不会有这个问题，在生成图片的第三步就出现无法分享的问题。在想是不是生成图片太大了导致太卡顿了？在开发调试过程，打开vue开发工具查看第三步data的时候，发现非常卡顿。这样就可以认定是图片造成的卡顿了。\n\n最后找到的原因：canvas生成的base64编码的图片码十分长，直接导致vue处理的时候出现卡顿严重进而影响页面分享效果。最后的解决方案：将base64转为file上传，最后展示返回的url图片。\n```javascript\n  const base64Code = canvas.toDataURL(\"image/png\")\n  // 去掉url的头，并转换为byte。以下步骤生成JavaScript blob文件\n  const bytes = window.atob(base64Code.split(',')[1])\n  const ab = new ArrayBuffer(bytes.length)\n  const ia = new Uint8Array(ab)\n  for (let i = 0; i < bytes.length; i++) {\n    ia[i] = bytes.charCodeAt(i)\n  }\n  let files = self.blobToFile(new Blob([ab], { type: 'png' }), 'post')\n  let formData = new FormData()\n  formData.append(\"file\", files, `myPost-${new Date().getTime()}.png`);\n  self.$http.post(config.fileUploadURL, formData, {\n    headers: {\n      'Content-Type': 'multipart/form-data'\n    }\n  }).then (uploadRes => {\n    if (uploadRes.data.code === 200) {\n      self.imageBase = uploadRes.data.url\n    }\n  })\n```\n```javascript\n  // blob图片转为文件的函数\n  blobToFile (theBlob, fileName){\n    theBlob.lastModifiedDate = new Date();\n    theBlob.name = fileName;\n    return theBlob;\n  }\n```\n### 成品\n虽然国庆过了，但是还是贴出来哈哈。\n[活动](http://xiaolu.ybj.com/wechat/html/gqyx/index.html)","bodyBegin":9,"frontmatter":"title: 一次h5开发踩坑记录\ndescription: 这个h5开发时间是在国庆前两天，通过比较短的时间完成开发、设计稿还原以及上线。在这记一下踩过的一些小坑或者说是小技巧。\nkeywords: h5,踩坑,vue,vux\nlabels: ['前端']\ndate: 2018-10-15"}},{"title":"2018-10/anti-theft.md","path":"2018-10/anti-theft","slug":"2018-10_anti-theft","fmData":{"attributes":{"title":"防盗链的解析","description":"最近涉及到了图片防盗链的问题，链接是特殊的，不能被其他网站解析为图片。说下来有几种办法，当然解决后发现还是最后那种简单便捷。唯一的缺点就是大概也许差不多可能无法访问到。这个没关系，只要保佑保佑，总会比加iframe轻松愉悦的。","keywords":"防盗链","labels":["前端"],"date":"2018-10-15T00:00:00.000Z"},"body":"### 前言\n\n最近涉及到了图片防盗链的问题，链接是特殊的，不能被其他网站解析为图片。说下来有几种办法，当然解决后发现还是最后那种简单便捷。唯一的缺点就是大概也许差不多可能无法访问到。这个没关系，只要保佑保佑，总会比加iframe轻松愉悦的。  \n\n首先，你看到的图片会是这样的：\n\n![例图](https://mmbiz.qpic.cn/mmbiz_jpg/cfehZicXpD0ib9BP0iafksSmxPcWm4ORDGkD5ibHIHeWSyWjHriaFGhHLFvZNwiau4icCOBvT56MktVFATAf1D8vuyOHw/0?wx_fmt=jpeg)  \n\n实际上，如果你能看到上面这张图，说明你骨骼精奇，自带解锁功能。\n但是我们想直接看到：  \n\n![例图](https://images.weserv.nl/?url=//mmbiz.qpic.cn/mmbiz_jpg/cfehZicXpD0ib9BP0iafksSmxPcWm4ORDGkD5ibHIHeWSyWjHriaFGhHLFvZNwiau4icCOBvT56MktVFATAf1D8vuyOHw/0?wx_fmt=jpeg)  \n\n那怎么做呢？\n\n### 页面头部加入<mate>标签\n\n```html\n<meta name=\"referrer\" content=\"never\">\n```\n\n这种办法通过控制referer绕过防盗链的检测。html可以通过这个参数决定http请求中的referer，要注意使用这个标签属性的时候，浏览器原有的referer策略就发生改变了。\n\n### 图片在iframe内显示\n\n```javascript\nlet url='防盗的链接';\nlet finalUrl = displayImg(url);\nconsole.log(finalUrl);\ndocument.getElementById('img').innerHTML = finalUrl;\n\ndisplayImg = (url) => {\n    let iFrameid = 'frameimg' + Math.random();\n    window.img = '<img id=\"img\" src=\\'' + url + '?' + Math.random() + '\\' />';\n    return '<iframe id=\"' + iFrameid + '\" src=\"javascript:parent.img;\" frameBorder=\"0\" scrolling=\"no\" width=\"100%\"></iframe>';\n}\n```\n\n这样可以正常显示图片，除了多了iframe外也没啥太大的问题，但是我发现在Vue里面一旦数据更新iframe就会刷新，外加上插件vue-draggable没法用了所以我就放弃这个方法了。这也促使我找更好的方案👇。\n\n### 传送门 | 跳板\n\n所以最后我还是找到了一个好的方法，搜索引擎下，发现大部分的跳板都被清理了。不要慌，总会有的，对于怎么找到这个跳板的话，我的建议是怎么不去对比一下开头的两张图？😄😄😄","bodyBegin":9,"frontmatter":"title: 防盗链的解析 \ndescription: 最近涉及到了图片防盗链的问题，链接是特殊的，不能被其他网站解析为图片。说下来有几种办法，当然解决后发现还是最后那种简单便捷。唯一的缺点就是大概也许差不多可能无法访问到。这个没关系，只要保佑保佑，总会比加iframe轻松愉悦的。 \nkeywords: 防盗链\nlabels: ['前端']\ndate: 2018-10-15"}},{"title":"2018-05/mp-back.md","path":"2018-05/mp-back","slug":"2018-05_mp-back","fmData":{"attributes":{"title":"微信小程序踩坑","description":"大概写了大半年的React，回想起来还真是挺长的。一直都想找机会了解更多的项目内容，小程序就是一直想去了解的。不过，就算是更换了工作内容，我还是很喜欢开源技术的。对于React的关注也一直没有停止，打心底的喜欢React这一个充满活力的库。","keywords":"微信小程序","labels":["小程序"],"date":"2018-05-16T00:00:00.000Z"},"body":"## React -- > 微信小程序开发\n\n### 因工作需要，这一段时间将进行小程序的开发工作\n\n大概写了大半年的React，回想起来还真是挺长的。一直都想找机会了解更多的项目内容，小程序就是一直想去了解的。不过，就算是更换了工作内容，我还是很喜欢开源技术的。对于React的关注也一直没有停止，打心底的喜欢React这一个充满活力的库。  \n除了小程序外，Vue的开发有空会去了解并去写一些简单的Demo。额，这一篇内容还是记录一下小程序的踩坑过程。\n\n<!--more-->\n\n### 小程序基本概况\n\n小程序的理念就是用完就走，不用多停留。从小程序面世到现在也过了几年了吧，在我注册一个个人开发者账号到写下第一行代码这个过程，比我想象中还是顺利的多。这得益于还是挺清晰的官方文档，里面也包含了一些基本的Demo。  \n槽点：[官方文档](https://developers.weixin.qq.com/miniprogram/dev/)访问体验很差，难道是我电脑问题，搜索一个api有很大的几率拿不到正确返回。希望后面能有一个畅快的阅读文档体验。\n\n### 小程序生态\n\n在github的repo搜索“小程序”，最多star的是[awesome-wechat-weapp](https://github.com/justjavac/awesome-wechat-weapp)。这个repo起到一个导航作用，在github带awesome开头的一般都是以收集数据为主的仓库。可以得到的信息是，看起来小程序的开发生态很不错，但认真点进每一个仓库的链接，会发现并没有想象中那么多。这个应该是我被React的生态惯坏了。没关系，先看看小程序开发有哪些比较知名的repo吧。  \n- [WePY](https://github.com/Tencent/wepy) ★10k+ - 支持组件化的小程序开发框架\n- [mpvue](https://github.com/Meituan-Dianping/mpvue) ★8.7k - 基于 Vue.js 的小程序开发框架，从底层支持 Vue.js 语法和构建工具体系  \n槽点：原本打算用WePy做生产环境的开发，但是看到众多人吐槽bug我就吓退了。整体而言，小程序的生态还没有我想象中那么好。\n\n### 开发体验\n\n* 在Windows下使用官方小程序开发工具，可以快速搭建小程序结构，提供实时预览，以及小程序可以在手机可以进行实时运行。开发过程中出现有如预览和手机上的样式不一致等的问题。\n* 自带开发工具的控制台在调试样式选取元素的体验上很差。我选不到元素，只好从Wxml上按代码筛查需要改的选择器再进行修改。\n* 类似于MVVM的开发体验。一个页面对应一个page，页面以及app的生命周期分明。\n* 大部分的api都采取回调的方式返回内容，整体结构很清晰。\n* 路由跳转很轻松。\n* 很像React的一点就是state的存在方式，在小程序上就是Data。每个page都可以设置属于这个页面的数据。\n* 有类似与Vue的语法糖\n* 很多组件官方都封装好了，使用起来很方便。\n\n### 目前踩的坑\n\n* wx.getUserInfo()这个接口在我刚入门小程序的这段时间被砍了。对我影响不大，但是对开发而言这种底层的api的改动影响还是很大的。  \n![default](https://user-images.githubusercontent.com/21136420/48886468-08b63080-ee67-11e8-8f63-83d81534d6ad.gif)\n* 高度适配上没考虑好问题，所以有那么一点时间是花在适配如iphoneX上。\n* 如何去掉小程序按钮的边框？\n```\nselector::after{\n  border: none;\n}\n```\n* 怎么修改checkbox的大小？\n```\n.checkbox {\n  transform: scale(0.6, 0.6);\n}\n```\n### 后语\n\n目前还没对接数据接口，不知道会有什么坑等着我。而且如果后期需要封装组件的话，还不知道会发生什么问题呢。也很希望官方多为开发者着想下，不要轻易动底层api，不然又要多熬几天夜的人就不少了。再接再厉，好好学习。","bodyBegin":9,"frontmatter":"title: 微信小程序踩坑\ndescription: 大概写了大半年的React，回想起来还真是挺长的。一直都想找机会了解更多的项目内容，小程序就是一直想去了解的。不过，就算是更换了工作内容，我还是很喜欢开源技术的。对于React的关注也一直没有停止，打心底的喜欢React这一个充满活力的库。 \nkeywords: 微信小程序\nlabels: ['小程序']\ndate: 2018-05-16"}},{"title":"2018-04/ubuntu-sougou.md","path":"2018-04/ubuntu-sougou","slug":"2018-04_ubuntu-sougou","fmData":{"attributes":{"title":"Ubuntu的搜狗输入法出现候选词乱码的问题","description":"ubuntu的搜狗输入法会出现候选词乱码的情况，只会出现在中文上，怎么解决呢？","keywords":"ubuntu,sougou,code","labels":["工具"],"date":"2018-04-08T00:00:00.000Z"},"body":"```\n$ rm -rf ~/.config/SogouPY ~/.config/sogou*\n```\n然后重启reboot","bodyBegin":9,"frontmatter":"title: Ubuntu的搜狗输入法出现候选词乱码的问题\ndescription: ubuntu的搜狗输入法会出现候选词乱码的情况，只会出现在中文上，怎么解决呢？\nkeywords: ubuntu,sougou,code\nlabels: ['工具']\ndate: 2018-04-08"}},{"title":"2017-12/linux-mint.md","path":"2017-12/linux-mint","slug":"2017-12_linux-mint","fmData":{"attributes":{"title":"每次重装Linux Mint减少90%时间","description":"每次重装Linux Mint减少90%时间","keywords":"linux,mint,soft,tools","labels":["工具"],"date":"2017-12-21T00:00:00.000Z"},"body":"## 系统\n\n1. [Google](https://www.google.com/chrome/browser/desktop/index.html)  \n    谷歌页面缩放125%\n2. [搜狗输入法](https://pinyin.sogou.com/linux/?r=pinyin)  \n    重启-输入法设置成功-QQ登录同步词库\n3. 安装扩展透明状态栏  \n    设置-面板-扩展\n4. terminal  \n    ctrl + shift + c --> ctrl + c  \n5. 创建ssh key  \n\n[粘贴到github](https://github.com/settings/keys)\n\n```bash\nsh-keygen -t rsa -b 4096 -C \"gzy.guy@gmail.com\"\n```\n6. 安装oh my zsh\n\n```bash\nhttps://github.com/robbyrussell/oh-my-zsh\nsudo apt-get install zsh\nsudo apt-get install git\n```\n7. 设置小飞机  \n    [#链接](https://github.com/GzhiYi/frontend-log/issues/2)  \n8. 安装vscode   \n    [vsCode](https://code.visualstudio.com/)  \n    下载安装扩展setting-sync 需要token 和 gistId\n9. 字体问题  \n    [链接](http://tieba.baidu.com/p/5128932851)  \n    软件管理器 - 删除 Fonts-arphic-ukai  Fonts-arphic-uming\n\n## 项目\n\n1. 安装nvm\n\n```bash\nsudo apt-get update\nsudo apt-get install build-essential libssl-dev\ncurl -sL https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh -o install_nvm.sh\nbash install_nvm.sh\nnvm use 6.11.5\n```\n2. 换源  \n    [链接](https://github.com/GzhiYi/frontend-log/issues/4)\n3. 安装postgres\n\n```bash\nsudo apt-get install postgresql-client\nsudo apt-get install postgresql\nsudo apt-get install pgadmin3\nsudo su - postgres\npsql\ncreate role gzhiyi login;\n```\n\n4. 安装virtualenv  \n\n```bash\nsudo apt-get install virtualenv\n```\n\n## 问题\n\nubuntu 系的chrome有个闪屏的问题， 原因还是因为显卡。\n有解决办法：\n1. 关闭chrome设置中的硬件加速。\n2. 打开 chrome://flags， 找到GPU rasterization，选择Force enable for layers。\n第二个不知道有没用。\n\n只是没有闪的问题，但是还有些异常的","bodyBegin":9,"frontmatter":"title: 每次重装Linux Mint减少90%时间\ndescription: 每次重装Linux Mint减少90%时间\nkeywords: linux,mint,soft,tools\nlabels: ['工具']\ndate: 2017-12-21"}},{"title":"2017-11/win10-ubuntu.md","path":"2017-11/win10-ubuntu","slug":"2017-11_win10-ubuntu","fmData":{"attributes":{"title":"前端搭建win10-ubuntu双系统的小记","description":"笔记本安装win10和ubuntu做开发本","keywords":"前端,win10,ubuntu,gnome","labels":["工具"],"date":"2017-11-09T00:00:00.000Z"},"body":"## 首先版本是Ubuntu 16.04(LTS)非麒麟版本。\n\n由于时间不多，主要拿Ubuntu进行web开发。其他发行版并未尝试。也好记录一下配置Ubuntu以及gnome的走过的坑。\n\n### 安装Ubuntu\n\n可到官网安装，版本看个人喜欢，麒麟版本自带中文以及拼音输入法等。\n\n[Download](http://cn.ubuntu.com/download/)\n\n下载好之后用软碟通写入U盘映像。无论双系统与否都必须关闭secure Boot。\n解释算好也基本上上每个懂折腾Linux的都会看过这一篇文章\n[反Secure Boot垄断：兼谈如何在Windows 8电脑上安装Linux](http://www.ruanyifeng.com/blog/2013/01/secure_boot.html)\n\n自行划分硬盘空间。\n硬盘划好，电脑开机选快捷启动就进入安装，分区的时候主要有几个分区点（以下只是在双系统下分配硬盘空间较小的建议，实际看个人需要）:\n\n/：存储系统文件，建议15G;\n\nswap：交换分区，即Linux系统的虚拟内存，建议是物理内存的1～2倍；\n\n/home：home目录，存放音乐、图片及下载等文件的空间，建议最后分配所有剩下的空间；\n\n/boot：包含系统内核和系统启动所需的文件，实现双系统的关键所在，建议200M。\n\n均可选择为逻辑分区。\n一路下来就可以开机了。\n由于没有记录图片所以不再多说。\n\n### 安装gnome\n\n安装完Ubuntu如果足够开发就不需要Gnome，自带的是Untiy，Gnome只是美化和方便。因为有大量的扩展可以使用。\n\n```\n1. Ctrl+Alt+T 打开终端\n```\n\n```\n2. $ sudo apt-get install gnome-shell  //安装gnome-shell\n```\n\n```\n3. $ sudo apt-get install ubuntu-gnome-desktop  //安装gnome-desktop\n```\n\n```\n4. $ sudo apt-get install unity-tweak-tool  //安装 unity-tweak-tool\n```\n\n```\n5. $ sudo apt-get install gnome-tweak-tool   //安装gnome-tweak-tool\n```\n\n### 重启请选择 Gnome经典桌面\n\n输密码那有个齿轮的，不选择的话会有坑。一开始自己默认进入的是Ubuntu桌面，只能应用主题图标，扩展都没办法应用。\ngnome拓展到[gnome拓展中心](https://extensions.gnome.org/)下载安装。\n如果没有安装浏览器插件，火狐和chrome的应用或者说插件中心搜索gnome shell extensoins 安装就可以。\n\n### 扩展推荐和注意\n\n推荐(必装)： [Dash to Dock](https://extensions.gnome.org/extension/307/dash-to-dock/)、[Hide Top Bar自动隐藏顶栏](https://extensions.gnome.org/extension/545/hide-top-bar/)\n\n底栏去除：\n\n到目录\n\n```bash\n/usr/share/gnome-shell/extensions\n```","bodyBegin":9,"frontmatter":"title: 前端搭建win10-ubuntu双系统的小记\ndescription: 笔记本安装win10和ubuntu做开发本\nkeywords: 前端,win10,ubuntu,gnome\nlabels: ['工具']\ndate: 2017-11-09"}},{"title":"2017-11/ubuntu-shadowsocks.md","path":"2017-11/ubuntu-shadowsocks","slug":"2017-11_ubuntu-shadowsocks","fmData":{"attributes":{"title":"如何在ubuntu下使用shadowsocks","description":"如何在ubuntu下使用shadowsocks","keywords":"ubuntu,shadowsocks","labels":["工具"],"date":"2017-11-09T00:00:00.000Z"},"body":"### 提示：\n1. 测试环境：Ubuntu 16.04 (gnome桌面环境)\n2. 需要ss出国，就需要有ss账号。有很多的出售账号的地方。当然也可以自己搭建个人ss服务器，这里就不再赘述。\n3. 需要下载软件Shadowsocks-Qt5,具体下面会列出。\n4. 提供SwitchyOmega配置文件，不需要自己配置。\n5. 每次开机需要手动连接Qt5，除非设置自动连接。\n6. [文件](https://github.com/GzhiYi/frontend-log/releases/tag/ss)\n## 步骤(Steps):\n- 下载Shadowsocks-Qt5：  \n```\nsudo add-apt-repository ppa:hzwhuang/ss-qt5\nsudo apt-get update\nsudo apt-get install shadowsocks-qt5\n```  \n- 打开Qt5，右键空白选择添加。对应填上自己的ss账号信息。  \n有多种添加账号的方式，哪种合适用哪种。账号信息填好就点击新建的账号连接。如果ip能连通一般有延迟显示。\n- 下载SwitchyOmega  \n可以提供gfw过滤等，在chrome下使用体验很不错。  \n[chrome上车](https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?utm_source=chrome-ntp-icon)  \n[fireFox上车](https://addons.mozilla.org/zh-CN/firefox/addon/switchyomega/)    \n文件在提示第六条有release下载。\n- 配置SwitchyOmega  \n点击选项--导入/导出--从备份文件恢复。选择文件  \n```\nOmegaOptionsChrome.bak\n```  \n- 开启switchyOmega  \n选择switchyOmega的自动切换\n\n## 开机自启方法\n\n1. 选择Qt5添加的项目右键--编辑，勾选程序启动时自动连接\n2. Qt5  设置--常规设置--登录时启动\n","bodyBegin":9,"frontmatter":"title: 如何在ubuntu下使用shadowsocks\ndescription: 如何在ubuntu下使用shadowsocks\nkeywords: ubuntu,shadowsocks\nlabels: ['工具']\ndate: 2017-11-09"}}]